<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="NIO,">










<meta name="description" content="主要转自：https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html 流与块的比较面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节流的数据，一个输出流消费一个字节流的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，">
<meta name="keywords" content="NIO">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础-NIO">
<meta property="og:url" content="http://yoursite.com/2018/11/03/java/IO/java基础-NIO/index.html">
<meta property="og:site_name" content="Coder_Wang&#39;s blog">
<meta property="og:description" content="主要转自：https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html 流与块的比较面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节流的数据，一个输出流消费一个字节流的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-02-18T12:07:45.563Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java基础-NIO">
<meta name="twitter:description" content="主要转自：https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html 流与块的比较面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节流的数据，一个输出流消费一个字节流的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/03/java/IO/java基础-NIO/">





  <title>java基础-NIO | Coder_Wang's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coder_Wang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/java/IO/java基础-NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java基础-NIO</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-03T08:43:24+08:00">
                2018-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>主要转自：<a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html</a></p>
<h2 id="流与块的比较"><a href="#流与块的比较" class="headerlink" title="流与块的比较"></a>流与块的比较</h2><p>面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节流的数据，一个输出流消费一个字节流的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>Channel 是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。 所有数据都通过 Buffer 对象来处理。永远不会将字节直接写入通道中，相反，是将数据写入包含一个或者多个字节的缓冲区。同样，也不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。<br>通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道可以用于读、写或者同时用于读写。<br>常见的Channel有： FileChannel、SelectableChannel、ServerSocketChannel、SocketChannel、DatagramChannel、Pipe.SinkChannel、Pipe.SourceChannel。 所有 Channel 都不应该使用构造器来直接创建，而是通过传统的节点流 InputStream/OutputStream 的 <code>getChannel</code> 方法来返回对应的Channel。不同的节点流获取的 Channel 不一样， FileInputStream/FileOutputStream-&gt;FileChannel; PipedInputStream-&gt;Pipe.SinkChannel; PipedOutputStream-&gt;Pipe.SourceChannel 。<br>Channel中最常用的方法：</p>
<ul>
<li>map: 将Channel对应的部分或全部数据映射到 ByteBuffer</li>
<li>read: 有很多重载方法，从Channel中读取数据到给定 buffer</li>
<li>write: 有很多重载方法，将 buffer 中的数据写入到 Channel</li>
</ul>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中。</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，都是将它放到缓冲区中。</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<h3 id="缓冲区的状态变量"><a href="#缓冲区的状态变量" class="headerlink" title="缓冲区的状态变量"></a>缓冲区的状态变量</h3><p>可以用三个值指定缓冲区在任意时刻的状态：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。</p>
<h4 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h4><p>缓冲区的 capacity 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。<br>limit 决不能大于 capacity。</p>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。<br>同样，在写入通道时，您是从缓冲区中获取数据。 position 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 position 将被设置为5，指向数组的第六个元素。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit 变量表明还有多少数据需要取出。(在从缓冲区写入通道时)limit等于缓冲区中数据的数量，或者还有多少空间可以放入数据(在从通道读入缓冲区时)，limit应该等于capacity。<br>position 总是小于或者等于 limit。</p>
<h4 id="flip方法"><a href="#flip方法" class="headerlink" title="flip方法"></a>flip方法</h4><p>现在我们要将数据写到输出通道中。在这之前，我们必须调用 flip() 方法。这个方法做两件非常重要的事：</p>
<ul>
<li>它将 limit 设置为当前 position。</li>
<li>它将 position 设置为 0。</li>
</ul>
<h4 id="clear方法"><a href="#clear方法" class="headerlink" title="clear方法"></a>clear方法</h4><p>从通道读入数据到缓冲区之前，这个方法重设缓冲区以便接收更多的字节。 Clear 做两件非常重要的事情：</p>
<ul>
<li>它将 limit 设置为与 capacity 相同。</li>
<li>它设置 position 为 0。</li>
</ul>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h4><p>ByteBuffer 类中有四个 get() 方法：</p>
<ul>
<li>byte get(): 获取单个字节</li>
<li>ByteBuffer get(byte[] dst): 将一组字节读到一个数组中</li>
<li>ByteBuffer get(byte[] dst, int offset, int length): 将一组字节读到一个数组中，从 offset 开始的 length 个字节</li>
<li>byte get( int index ): 从缓冲区中的特定位置获取字节</li>
</ul>
<p>此外，我们认为前三个 get() 方法是相对的，而最后一个方法是绝对的。 相对意味着 get() 操作服从 limit 和 position 值 ― 更明确地说，字节是从当前 position 读取的，而 position 在 get 之后会增加。另一方面，一个 绝对方法会忽略 limit 和 position 值，也不会影响它们。事实上，它完全绕过了缓冲区的统计方法。<br>上面列出的方法对应于 ByteBuffer 类。其他类有等价的 get() 方法，这些方法除了不是处理字节外，其它方面是是完全一样的，它们处理的是与该缓冲区类相适应的类型。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><p>ByteBuffer 类中有五个 put() 方法：</p>
<ul>
<li>ByteBuffer put( byte b );</li>
<li>ByteBuffer put( byte src[] );</li>
<li>ByteBuffer put( byte src[], int offset, int length );</li>
<li>ByteBuffer put( ByteBuffer src );</li>
<li>ByteBuffer put( int index, byte b );<br>第一个方法 写入（put） 单个字节。第二和第三个方法写入来自一个数组的一组字节。第四个方法将数据从一个给定的源 ByteBuffer 写入这个 ByteBuffer。第五个方法将字节写入缓冲区中特定的 位置 。那些返回 ByteBuffer 的方法只是返回调用它们的缓冲区的 this 值。</li>
</ul>
<p>与 get() 方法一样，我们将把 put() 方法划分为 相对 或者 绝对 的。前四个方法是相对的，而第五个方法是绝对的。</p>
<p>上面显示的方法对应于 ByteBuffer 类。其他类有等价的 put() 方法，这些方法除了不是处理字节之外，其它方面是完全一样的。它们处理的是与该缓冲区类相适应的类型。</p>
<h4 id="缓冲区分配和包装"><a href="#缓冲区分配和包装" class="headerlink" title="缓冲区分配和包装"></a>缓冲区分配和包装</h4><p>在能够读和写之前，必须有一个缓冲区。要创建缓冲区;</p>
<ol>
<li><p>分配它。我们使用静态方法 allocate() 来分配缓冲区：</p>
<p> ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
</li>
<li><p>还可以将一个现有的数组转换为缓冲区，如下所示：</p>
<p> byte array[] = new byte[1024];<br> ByteBuffer buffer = ByteBuffer.wrap( array );</p>
</li>
</ol>
<h2 id="NIO-网络编程的一般步骤"><a href="#NIO-网络编程的一般步骤" class="headerlink" title="NIO 网络编程的一般步骤"></a>NIO 网络编程的一般步骤</h2><h3 id="服务器端打开一个-ServerSocketChannel"><a href="#服务器端打开一个-ServerSocketChannel" class="headerlink" title="服务器端打开一个 ServerSocketChannel"></a>服务器端打开一个 ServerSocketChannel</h3><p>为了接收连接，我们需要一个 <code>ServerSocketChannel</code> 。事实上，我们要监听的每一个端口都需要有一个 <code>ServerSocketChannel</code> 。对于每一个端口，我们打开一个 <code>ServerSocketChannel</code> ，不能直接使用 <code>ServerScocket</code> 的 getChannel 方法来获得 ServerSocketChannel 对象，也不能直接绑定到端口，必须使用 socket() 方法获得关联的 ServerScocket 对象，然后再用该 ServerScocket 对象来绑定端口。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking( false );</span><br><span class="line">ServerSocket ss = ssc.socket();</span><br><span class="line">InetSocketAddress address = new InetSocketAddress( ports[i] );</span><br><span class="line">ss.bind( address );</span><br></pre></td></tr></table></figure></p>
<p>第一行创建一个新的 <code>ServerSocketChannel</code> ，最后三行将它绑定到给定的端口。第二行将 <code>ServerSocketChannel</code> 设置为<em>非阻塞</em>的 。我们必须对每一个要使用的套接字通道调用这个方法，否则异步 I/O 就不能工作。</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p><code>Selector</code> 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。<br>我们关心某个channel是否发生了读写或者Accept事件，就把这个channel和相应的事件通过channel的register方法注册到selector对象上，这样selector会在这些channel上发生了你感兴趣的事件时通知你。</p>
<p>所以，我们需要做的第一件事就是创建一个 Selector，通过 Selector 类的静态方法 opeb() 来获得系统默认的 Selector：</p>
<pre><code>Selector selector = Selector.open();
</code></pre><p>然后，我们将对不同的<em>通道对象</em>调用 <code>register()</code> 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。<code>register()</code> 的第一个参数总是这个 Selector。Selector可以同时监控注册到其上的多个 SelectableChannel 的IO状况，是非阻塞IO的核心。一个 Selector 有三个SelectionKey的集合：</p>
<ol>
<li>所有SelectionKey的集合：代表了注册在改Selector上的Channel，可以通过 keys() 获取该集合</li>
<li>所有选择的SelectionKey集合：代表了所有监测到的、需要进行IO处理的Channel，调用select()方法会检测哪些Channel需要IO处理，然后通过 selectedKeys()方法可以获取该集合</li>
<li>被取消的SelectionKey的集合：代表了所有被取消了注册关系的Channel，程序通常不需要直接访问该集合。<br>同时，Selector 还提供了系列和 select() 相关的方法：</li>
</ol>
<ul>
<li>int select(): 监控检测所有注册的Channel，将那些需要进行IO处理的Channel所对应的 SelectionKey 添加到所有选择的SelectionKey集合中，返回需要IO处理的Channel的数量。如果没有需要IO处理的Channel，该方法将阻塞线程</li>
<li>int select(long timeout): 可以设置超时时长的select</li>
<li>int selectNow(): 立即返回的select，不会阻塞线程</li>
<li>Selector wakeup(): 使一个未返回的 select() 方法立即返回。</li>
</ul>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>SelectionKey代表的是 SelectableChannel 和 Selector 之间的注册关系。通过它可以或得对应的 SelectableChannel 和 Selector:</p>
<ul>
<li>Selector selector(): 获取 Selector</li>
<li>SelectableChannel channel(): 获取 SelectableChannel</li>
</ul>
<p>所以，下一步是将新打开的 <code>ServerSocketChannel</code> 注册到 <code>Selector</code> 上。为此我们使用 <code>SelectableChannel.register()</code> 方法，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</span><br></pre></td></tr></table></figure></p>
<p><code>register()</code> 的第一个参数总是这个 <code>Selector</code> 。第二个参数是 <code>OP_ACCEPT</code> ，这里它指定我们想要监听 accept 事件，也就是在新的连接建立时所发生的事件。这是适用于 <code>ServerSocketChannel</code> 的唯一事件类型。<br>请注意对 <code>register()</code> 的调用的返回值。 <code>SelectionKey</code> 代表这个通道在此 <code>Selector</code> 上的这个注册。当某个 <code>Selector</code> 通知您某个传入事件时，它是通过提供对应于该事件的 <code>SelectionKey</code> 来进行的。<code>SelectionKey</code> 还可以用于取消通道的注册。</p>
<h3 id="内部循环"><a href="#内部循环" class="headerlink" title="内部循环"></a>内部循环</h3><p>现在已经注册了我们对一些 I/O 事件的兴趣，下面将进入主循环。使用 <code>Selector</code> 的几乎每个程序都像下面这样使用内部循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int num = selector.select();</span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator it = selectedKeys.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">     SelectionKey key = (SelectionKey)it.next();</span><br><span class="line">     // ... deal with I/O event ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，我们调用 <code>Selector</code> 的 <code>select()</code> 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， <code>select()</code> 方法将返回所发生的事件的数量。</p>
<p>接下来，我们调用 <code>Selector</code> 的 <code>selectedKeys()</code> 方法，它返回发生了事件的 <code>SelectionKey</code> 对象的一个集合 。</p>
<p>我们通过迭代 <code>SelectionKeys</code> 并依次处理每个 <code>SelectionKey</code> 来处理事件。对于每一个 <code>SelectionKey</code> ，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p>
<h3 id="监听新连接"><a href="#监听新连接" class="headerlink" title="监听新连接"></a>监听新连接</h3><p>程序执行到这里，我们仅注册了 <code>ServerSocketChannel</code> ，并且仅注册它们“接收”事件。为确认这一点，我们对 SelectionKey 调用 <code>readyOps()</code> 方法，并检查发生了什么类型的事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</span><br><span class="line">     == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line">     // Accept the new connection</span><br><span class="line">     // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以肯定地说， <code>readOps()</code> 方法告诉我们该事件是新的连接。</p>
<h3 id="接受新的连接"><a href="#接受新的连接" class="headerlink" title="接受新的连接"></a>接受新的连接</h3><p>因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 accept() 操作会阻塞：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</span><br><span class="line">SocketChannel sc = ssc.accept();</span><br></pre></td></tr></table></figure></p>
<p>下一步是将新连接的 SocketChannel 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 SocketChannel 注册到 Selector上，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.configureBlocking( false );</span><br><span class="line">SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );</span><br></pre></td></tr></table></figure></p>
<p>注意我们使用 register() 的 OP_READ 参数，将 SocketChannel 注册用于 <strong>读取</strong> 而不是 <strong>接受</strong> 新连接。</p>
<h3 id="删除处理过的-SelectionKey"><a href="#删除处理过的-SelectionKey" class="headerlink" title="删除处理过的 SelectionKey"></a>删除处理过的 SelectionKey</h3><p>在处理 SelectionKey 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的 <code>remove()</code> 方法来删除处理过的 SelectionKey：</p>
<pre><code>it.remove();
</code></pre><p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的 I/O 事件)了。</p>
<h3 id="处理传入的-I-O-数据"><a href="#处理传入的-I-O-数据" class="headerlink" title="处理传入的 I/O 数据"></a>处理传入的 I/O 数据</h3><p>当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 Selector.select()，并返回一个或者多个 I/O 事件。这一次， SelectionKey 将被标记为 OP_READ 事件，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ((key.readyOps() &amp; SelectionKey.OP_READ)</span><br><span class="line">     == SelectionKey.OP_READ) &#123;</span><br><span class="line">     // Read the data</span><br><span class="line">     SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">     // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与以前一样，我们取得发生 I/O 事件的通道并处理它。在本例中，由于这是一个 echo server，我们只希望从套接字中读取数据并马上将它发送回去。</p>
<h3 id="回到主循环"><a href="#回到主循环" class="headerlink" title="回到主循环"></a>回到主循环</h3><p>每次返回主循环，我们都要调用 select 的 Selector()方法，并取得一组 SelectionKey。每个键代表一个 I/O 事件。我们处理事件，从选定的键集中删除 SelectionKey，然后返回主循环的顶部。</p>
<p>在现实的应用程序中，您需要通过将通道从 Selector 中删除来处理关闭的通道。而且您可能要使用多个线程。创建一个线程池来负责 I/O 事件处理中的耗时部分会更有意义。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NIO/" rel="tag"># NIO</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/30/git/git常用命令/" rel="next" title="git 常用命令">
                <i class="fa fa-chevron-left"></i> git 常用命令
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/06/web/webpack入门教程/" rel="prev" title="webpack入门教程">
                webpack入门教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Coder_Wang</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">170</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#流与块的比较"><span class="nav-number">1.</span> <span class="nav-text">流与块的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通道"><span class="nav-number">2.</span> <span class="nav-text">通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区"><span class="nav-number">3.</span> <span class="nav-text">缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区的状态变量"><span class="nav-number">3.1.</span> <span class="nav-text">缓冲区的状态变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Capacity"><span class="nav-number">3.1.1.</span> <span class="nav-text">Capacity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#position"><span class="nav-number">3.1.2.</span> <span class="nav-text">position</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#limit"><span class="nav-number">3.1.3.</span> <span class="nav-text">limit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flip方法"><span class="nav-number">3.1.4.</span> <span class="nav-text">flip方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clear方法"><span class="nav-number">3.1.5.</span> <span class="nav-text">clear方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-方法"><span class="nav-number">3.1.6.</span> <span class="nav-text">get() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put-方法"><span class="nav-number">3.1.7.</span> <span class="nav-text">put()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲区分配和包装"><span class="nav-number">3.1.8.</span> <span class="nav-text">缓冲区分配和包装</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-网络编程的一般步骤"><span class="nav-number">4.</span> <span class="nav-text">NIO 网络编程的一般步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器端打开一个-ServerSocketChannel"><span class="nav-number">4.1.</span> <span class="nav-text">服务器端打开一个 ServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Selector"><span class="nav-number">4.2.</span> <span class="nav-text">Selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SelectionKey"><span class="nav-number">4.3.</span> <span class="nav-text">SelectionKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部循环"><span class="nav-number">4.4.</span> <span class="nav-text">内部循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监听新连接"><span class="nav-number">4.5.</span> <span class="nav-text">监听新连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接受新的连接"><span class="nav-number">4.6.</span> <span class="nav-text">接受新的连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除处理过的-SelectionKey"><span class="nav-number">4.7.</span> <span class="nav-text">删除处理过的 SelectionKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理传入的-I-O-数据"><span class="nav-number">4.8.</span> <span class="nav-text">处理传入的 I/O 数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回到主循环"><span class="nav-number">4.9.</span> <span class="nav-text">回到主循环</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coder_Wang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
