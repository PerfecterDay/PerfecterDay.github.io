<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="学习笔记">
<meta name="keywords" content="java sql vue web python">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder_Wang&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="Coder_Wang&#39;s blog">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coder_Wang&#39;s blog">
<meta name="twitter:description" content="学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/9/">





  <title>Coder_Wang's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coder_Wang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/17/springboot/hystrix总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/17/springboot/hystrix总结/" itemprop="url">Hystrix 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-17T19:15:12+08:00">
                2020-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/hystrix/" itemprop="url" rel="index">
                    <span itemprop="name">hystrix</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>现在有个需求，有一个类 RemoteContrller 需要调用若干类的一些方法，这些类和方法的名字都是不一样的，而且未来可能需要支持更多类的方法调用。如何设计这个 RemoteContrller 类，使得能够支持后边调用类的扩展？具体来说， RemoteContrller 可能会涉及到下边这些类的方法调用：<br><img src="/pics/vendor_class.png" alt><br>设计一个 Command 接口，RemoteController 针对 Command 编程，只要调用它的 execute 方法就好了；不用去关心具体的调用逻辑。对应的，对上图中每个类的方法调用都要封装成一个 Command 对象，里边包含着上述类的引用及具体方法调用的实现逻辑，我们可以在此处实现方法调用的扩展和自定义。<br><img src="/pics/command_pattern.png" alt></p>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>Hystrix 就是使用了上述的命令模式。微服务的场景下，对下游服务的调用实际上就可以看成命令模式中对方法的调用，我们可以使用命令模式，对下游服务调用的方法进行封装和额外处理，比如调用失败次数统计，服务降级，服务熔断…</p>
<h4 id="Hystrix-相关概念"><a href="#Hystrix-相关概念" class="headerlink" title="Hystrix 相关概念"></a>Hystrix 相关概念</h4><ol>
<li>服务降级（fallback)：当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。下面四种情况会触发服务降级:<ul>
<li>非HystrixBadRequestException异常：当抛出HystrixBadRequestException时，调用程序可以捕获异常，没有触发getFallback()，而其他异常则会触发getFallback()，调用程序将获得getFallback()的返回</li>
<li>run()/construct()运行超时：如使用无限while循环或sleep模拟超时，会触发了getFallback()</li>
<li>熔断器启动：假如我们配置10s内请求数大于3个时就启动熔断器，请求错误率大于80%时就熔断，然后for循环发起请求，当请求符合熔断条件时将触发getFallback()。更多熔断策略见下文</li>
<li>线程池/信号量已满：假如配置线程池数目为3，然后先用一个for循环执行queue()，触发的run()sleep 2s，然后再用第2个for循环执行execute()，发现所有execute()都触发了fallback，这是因为第1个for的线程还在sleep，占用着线程池所有线程，导致第2个for的所有命令都无法获取到线程</li>
</ul>
</li>
<li>服务熔断：当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</li>
<li>隔离策略： hystrix提供了两种隔离策略：线程池隔离和信号量隔离。hystrix默认采用线程池隔离。<ol>
<li>线程池隔离：不同服务通过使用不同线程池，彼此间将不受影响，达到隔离效果。以demo为例，我们通过andThreadPoolKey配置使用命名为ThreadPoolTest的线程池，实现与其他命名的线程池天然隔离，如果不配置andThreadPoolKey则使用withGroupKey配置来命名线程池</li>
<li>信号量隔离：线程隔离会带来线程开销，有些场景（比如无网络请求场景）可能会因为用开销换隔离得不偿失，为此hystrix提供了信号量隔离，当服务的并发数大于信号量阈值时将进入fallback。以demo为例，通过withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)配置为信号量隔离，通过withExecutionIsolationSemaphoreMaxConcurrentRequests配置执行并发数不能大于3，由于信号量隔离下无论调用哪种命令执行方法，hystrix都不会创建新线程执行run()/construct()，所以调用程序需要自己创建多个线程来模拟并发调用execute()，最后看到一旦并发线程&gt;3，后续请求都进入fallback</li>
</ol>
</li>
<li>熔断机制：熔断机制相当于电路的跳闸功能，举个例子，我们可以配置熔断策略为当请求错误比例在10s内&gt;50%时，该服务将进入熔断状态，后续请求都会进入fallback。hystrix还支持多长时间从熔断状态自动恢复等功能。</li>
<li>结果cache<br>hystrix支持将一个请求结果缓存起来，下一个具有相同key的请求将直接从缓存中取出结果，减少请求开销。要使用hystrix cache功能，第一个要求是重写getCacheKey() ，用来构造cache key；第二个要求是构建context，如果请求B要用到请求A的结果缓存，A和B必须同处一个context。通过HystrixRequestContext.initializeContext()和context.shutdown()可以构建一个context，这两条语句间的所有请求都处于同一个context。</li>
<li>合并请求collapsing<br>hystrix支持N个请求自动合并为一个请求，这个功能在有网络交互的场景下尤其有用，比如每个请求都要网络访问远程资源，如果把请求合并为一个，将使多次网络交互变成一次，极大节省开销。重要一点，两个请求能自动合并的前提是两者足够“近”，即两者启动执行的间隔时长要足够小，默认为10ms，即超过10ms将不自动合并。</li>
</ol>
<h4 id="Hystrix-使用和运行流程"><a href="#Hystrix-使用和运行流程" class="headerlink" title="Hystrix 使用和运行流程"></a>Hystrix 使用和运行流程</h4><ol>
<li><p>集成 HystrixCommand 或者 HystrixObservableCommand<br>要想使用hystrix，只需要继承 HystrixCommand 或 HystrixObservableCommand 。两者主要区别是：</p>
<ul>
<li>前者的命令逻辑写在run()；后者的命令逻辑写在construct()</li>
<li>前者的run()是由新创建的线程执行；后者的construct()是由调用程序线程执行</li>
<li>前者一个实例只能向调用程序发送（emit）单条数据，比如上面例子中run()只能返回一个String结果；后者一个实例可以顺序发送多条数据，比如demo中顺序调用多个onNext()，便实现了向调用程序发送多条数据，甚至还能发送一个范围的数据集</li>
</ul>
</li>
<li><p>执行4个命令执行方法】<br>execute()、queue()、observe()、toObservable()这4个方法用来触发执行run()/construct()，一个实例只能执行一次这4个方法，特别说明的是 HystrixObservableCommand 没有 execute() 和 queue() 方法。<br>4个方法的主要区别是：</p>
<ul>
<li>execute()：以同步堵塞方式执行run()。以demo为例，调用execute()后，hystrix先创建一个新线程运行run()，接着调用程序要在execute()调用处一直堵塞着，直到run()运行完成</li>
<li>queue()：以异步非堵塞方式执行run()。以demo为例，一调用queue()就直接返回一个Future对象，同时hystrix创建一个新线程运行run()，调用程序通过Future.get()拿到run()的返回结果，而Future.get()是堵塞执行的</li>
<li>observe()：事件注册前执行run()/construct()。以demo为例，第一步是事件注册前，先调用observe()自动触发执行run()/construct()（如果继承的是HystrixCommand，hystrix将创建新线程非堵塞执行run()；如果继承的是HystrixObservableCommand，将以调用程序线程堵塞执行construct()），第二步是从observe()返回后调用程序调用subscribe()完成事件注册，如果run()/construct()执行成功则触发onNext()和onCompleted()，如果执行异常则触发onError()</li>
<li>toObservable()：事件注册后执行run()/construct()。以demo为例，第一步是事件注册前，一调用toObservable()就直接返回一个Observable<string>对象，第二步调用subscribe()完成事件注册后自动触发执行run()/construct()（如果继承的是HystrixCommand，hystrix将创建新线程非堵塞执行run()，调用程序不必等待run()；如果继承的是HystrixObservableCommand，将以调用程序线程堵塞执行construct()，调用程序等待construct()执行完才能继续往下走），如果run()/construct()执行成功则触发onNext()和onCompleted()，如果执行异常则触发onError()</string></li>
</ul>
</li>
<li><p>运行流程<br><img src="/pics/hystrix-command-flow-chart.png" alt></p>
</li>
</ol>
<h4 id="Hystrix-配置"><a href="#Hystrix-配置" class="headerlink" title="Hystrix 配置"></a>Hystrix 配置</h4><ol>
<li><p>HystrixCommandProperties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* --------------统计相关------------------*/ </span><br><span class="line">// 统计滚动的时间窗口,默认:5000毫秒（取自circuitBreakerSleepWindowInMilliseconds）   </span><br><span class="line">private final HystrixProperty metricsRollingStatisticalWindowInMilliseconds;   </span><br><span class="line">// 统计窗口的Buckets的数量,默认:10个,每秒一个Buckets统计   </span><br><span class="line">private final HystrixProperty metricsRollingStatisticalWindowBuckets; // number of buckets in the statisticalWindow   </span><br><span class="line">// 是否开启监控统计功能,默认:true   </span><br><span class="line">private final HystrixProperty metricsRollingPercentileEnabled;   </span><br><span class="line">/* --------------熔断器相关------------------*/ </span><br><span class="line">// 熔断器在整个统计时间内是否开启的阀值，默认20。也就是在metricsRollingStatisticalWindowInMilliseconds（默认10s）内至少请求20次，熔断器才发挥起作用   </span><br><span class="line">private final HystrixProperty circuitBreakerRequestVolumeThreshold;   </span><br><span class="line">// 熔断时间窗口，默认:5秒.熔断器中断请求5秒后会进入半打开状态,放下一个请求进来重试，如果该请求成功就关闭熔断器，否则继续等待一个熔断时间窗口</span><br><span class="line">private final HystrixProperty circuitBreakerSleepWindowInMilliseconds;   </span><br><span class="line">//是否启用熔断器,默认true. 启动   </span><br><span class="line">private final HystrixProperty circuitBreakerEnabled;   </span><br><span class="line">//默认:50%。当出错率超过50%后熔断器启动</span><br><span class="line">private final HystrixProperty circuitBreakerErrorThresholdPercentage;  </span><br><span class="line">//是否强制开启熔断器阻断所有请求,默认:false,不开启。置为true时，所有请求都将被拒绝，直接到fallback </span><br><span class="line">private final HystrixProperty circuitBreakerForceOpen;   </span><br><span class="line">//是否允许熔断器忽略错误,默认false, 不开启   </span><br><span class="line">private final HystrixProperty circuitBreakerForceClosed; </span><br><span class="line">/* --------------信号量相关------------------*/ </span><br><span class="line">//使用信号量隔离时，命令调用最大的并发数,默认:10   </span><br><span class="line">private final HystrixProperty executionIsolationSemaphoreMaxConcurrentRequests;   </span><br><span class="line">//使用信号量隔离时，命令fallback(降级)调用最大的并发数,默认:10   </span><br><span class="line">private final HystrixProperty fallbackIsolationSemaphoreMaxConcurrentRequests; </span><br><span class="line">/* --------------其他------------------*/ </span><br><span class="line">//使用命令调用隔离方式,默认:采用线程隔离,ExecutionIsolationStrategy.THREAD   </span><br><span class="line">private final HystrixProperty executionIsolationStrategy;   </span><br><span class="line">//使用线程隔离时，调用超时时间，默认:1秒   </span><br><span class="line">private final HystrixProperty executionIsolationThreadTimeoutInMilliseconds;   </span><br><span class="line">//线程池的key,用于决定命令在哪个线程池执行   </span><br><span class="line">private final HystrixProperty executionIsolationThreadPoolKeyOverride;   </span><br><span class="line">//是否开启fallback降级策略 默认:true   </span><br><span class="line">private final HystrixProperty fallbackEnabled;   </span><br><span class="line">// 使用线程隔离时，是否对命令执行超时的线程调用中断（Thread.interrupt()）操作.默认:true   </span><br><span class="line">private final HystrixProperty executionIsolationThreadInterruptOnTimeout; </span><br><span class="line">// 是否开启请求日志,默认:true   </span><br><span class="line">private final HystrixProperty requestLogEnabled;   </span><br><span class="line">//是否开启请求缓存,默认:true   </span><br><span class="line">private final HystrixProperty requestCacheEnabled; // Whether request caching is enabled.</span><br></pre></td></tr></table></figure>
</li>
<li><p>HystrixThreadPoolProperties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 配置线程池大小,默认值10个. 建议值:请求高峰时99.5%的平均响应时间 + 向上预留一些即可 */ </span><br><span class="line">private final HystrixProperty corePoolSize; </span><br><span class="line">/* 配置线程值等待队列长度,默认值:-1 建议值:-1表示不等待直接拒绝,测试表明线程池使用直接决绝策略+ 合适大小的非回缩线程池效率最高.所以不建议修改此值。 当使用非回缩线程池时，queueSizeRejectionThreshold,keepAliveTimeMinutes 参数无效 */</span><br><span class="line">private final HystrixProperty maxQueueSize;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HystrixCollapserProperties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//请求合并是允许的最大请求数,默认: Integer.MAX_VALUE   </span><br><span class="line">private final HystrixProperty maxRequestsInBatch;   </span><br><span class="line">//批处理过程中每个命令延迟的时间,默认:10毫秒   </span><br><span class="line">private final HystrixProperty timerDelayInMilliseconds;   </span><br><span class="line">//批处理过程中是否开启请求缓存,默认:开启   </span><br><span class="line">private final HystrixProperty requestCacheEnabled;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/js/01-Javascript标签/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/js/01-Javascript标签/" itemprop="url">HTML中的 Javascript</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-02T21:14:27+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Js最常用的就是 Javascript 标签，然而许多 web开发者并不全都知道下面这些知识。</p>
<h2 id="Javascript-标签的6个属性"><a href="#Javascript-标签的6个属性" class="headerlink" title="Javascript 标签的6个属性"></a>Javascript 标签的6个属性</h2><ol>
<li>async: 可选，只对外部文件有效，表示应该立即下载脚本，但不应该妨碍页面的其他操作，比如下载其他资源或等待加载其它脚本。</li>
<li>defer: 可选，只对外部脚本文件有效。表示脚本可以延迟到文档完全被解析和显示之后再执行。</li>
<li>src: 可选，表示包含要执行的外部脚本文件。</li>
<li>charset: 可选，指示字符集。</li>
<li>language: 已废弃。</li>
<li>type: 一般为 text/javascript。</li>
</ol>
<h2 id="两种解析-Javascript-的标签的方式"><a href="#两种解析-Javascript-的标签的方式" class="headerlink" title="两种解析 Javascript 的标签的方式"></a>两种解析 Javascript 的标签的方式</h2><ol>
<li><p>内嵌 Javascript : 代码会从上到下依此解释，在解释器对 <code>&lt;script&gt;</code> 元素内部的所有代码求值完毕之前，页面中的其余内容都不会被浏览器加载或显示。以下代码，页面上不会显示test.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        while(true)&#123;&#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    test</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部 Javascript :如果通过 <code>&lt;script&gt;</code> 元素来包含外部脚本文件，那么 src 属性是必须的。与解析内嵌的 Javascript 代码一样，在解析外部 Javascript 文件（包括下载该文件）时，页面也会暂时停止。也就是说把上面代码中的 while 死循环放到外部文件，并通过 <code>&lt;script&gt;</code> 元素引入时，html 也不会显示。而且，如果下载 Javascript 文件出现问题，也会阻断页面显示。</p>
</li>
<li>如果是引入外部 Javascript ，即带有 src 属性的 <code>&lt;script&gt;</code> 标签，则在起始标签中间不应该在包含额外的 JS 代码，否则，嵌入的代码不会执行而是会被直接忽略。</li>
<li>只要不存在 defer 和 async 属性，浏览器都会按照 <code>&lt;script&gt;</code> 元素在页面中的出现的顺序对它们依次进行解析。就是说第一个解析执行之后才会解析第二个，以此类推。</li>
</ol>
<h2 id="script-标签的位置"><a href="#script-标签的位置" class="headerlink" title="script 标签的位置"></a>script 标签的位置</h2><p>传统的网页一般将 script 元素放在 head 元素中，这意味着必须等到全部的 Javascript 代码都被下载、解析和执行完之后，才能开始呈现页面的内容（浏览器遇到 <code>&lt;body&gt;</code> 标签时才开始呈现内容）。这对于那些需要很多 Javascript 代码的页面来说，会导致浏览器在呈现页面时出现明显的延迟，延迟期间，页面将是一片空白。用户体验时很差的。</p>
<p>所以，现代Web应用程序一般把 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中页面内容的后面。</p>
<h2 id="延迟脚本"><a href="#延迟脚本" class="headerlink" title="延迟脚本"></a>延迟脚本</h2><p>含有 defer 属性的脚本就是延迟脚本。 defer 属性只能用在外部脚本文件。延迟脚本会被立即下载，但脚本会被延迟到整个页面都解析完毕之后再运行。</p>
<p>HTML5 规范要求脚本按照它们的出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而两个脚本会先于 DOMContentLoaded 事件执行。</p>
<p>但是在现实中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件出发前执行，因此最好只包含一个延迟脚本。</p>
<h2 id="异步脚本"><a href="#异步脚本" class="headerlink" title="异步脚本"></a>异步脚本</h2><p>含有 async 属性的脚本时异步脚本，异步脚本会立即下载，但异步脚本并不保证按照指定它们的先后顺序执行。指定 async 属性的目的时不让页面等待脚本下载和执行，从而异步加载页面其他内容。为此，异步脚本不要在加载期间修改DOM。</p>
<p>异步脚步一定会在页面 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p>
<h2 id="嵌入脚本-VS-外部文件"><a href="#嵌入脚本-VS-外部文件" class="headerlink" title="嵌入脚本 VS 外部文件"></a>嵌入脚本 VS 外部文件</h2><p>外部文件一般有以下有点：</p>
<ol>
<li>可维护性：把 Javascript 代码放到外部文件并集中放到一个文件夹，比遍及在各个 HTML 页面维护起来轻松很多。</li>
<li>可缓存：浏览器能够根据具体设置缓存链接的所有外部 Javascript 文件。如果多个页面引用同一个 Javascript 文件，那么这个文件只要下载一次。</li>
<li>适应未来：外部脚本文件在 XHTML 和 HTML 中的语法是相同的。</li>
</ol>
<h2 id="noscript"><a href="#noscript" class="headerlink" title="noscript"></a>noscript</h2><p>noscript 元素可以包含出现在文档 body 元素中的任何 HTML 元素—— script元素除外。但是只有在下面情况下才会显示出来：</p>
<ul>
<li>浏览器不支持 Javascript 脚本</li>
<li>浏览器支持 Javascript 脚本，但被禁用。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/22/web/css入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/web/css入门/" itemprop="url">CSS 综述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-22T18:03:24+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSS-语句"><a href="#CSS-语句" class="headerlink" title="CSS 语句"></a>CSS 语句</h2><h3 id="规则集"><a href="#规则集" class="headerlink" title="规则集"></a>规则集</h3><p>通过在每个声明块前加上选择器（selector）来将一组声明块应用到选择器选择的元素上，选择器是一种模式，它能在页面上匹配一些元素。这将使相关的声明块仅被应用到被选择的元素上。选择器加上声明块被称为<strong>规则集（ruleset）</strong>，通常简称<strong>规则（rule）</strong>。<br><img src="/pics/css-rule.jpg" alt="规则"></p>
<p>一个元素可以被多个选择器所匹配，因此，一个给定的属性可能被多个规则设置多次。 CSS 定义了哪个规则比其它规则更具优先级，则更具优先级的规则必定被应用：这被称为<strong>层叠算法（cascade algorithm）</strong>，关于层叠算法的更多内容和运作原理见层叠和继承。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="@-规则"></a>@-规则</h3><p><strong>@-规则(At-rules)</strong>在CSS中被用来传递元数据、条件信息或其它描述性信息。它由（@）符号开始，紧跟着一个表明它是哪种规则的描述符，之后是这种规则的语法块，并最终由一个半角分号（;）结束。每种由描述符定义的@-规则，都有其特有的内部语法和语义。一些例子如下：</p>
<ul>
<li>@charset 和 @import （元数据）</li>
<li>@media 或 @document （条件信息，又被称为嵌套语句，见下方。)</li>
<li>@font-face （描述性信息）<br>具体语法示例：<br><code>@import &#39;custom.css&#39;; //该@-规则向当前 CSS 导入其它 CSS 文件</code></li>
</ul>
<h3 id="嵌套语句"><a href="#嵌套语句" class="headerlink" title="嵌套语句"></a>嵌套语句</h3><p><strong>嵌套语句</strong> 是@-规则中的一种，它的语法是 CSS 规则的嵌套块，只有在特定条件匹配时才会应用到文档上。特定条件如下：</p>
<ul>
<li>@media 只有在运行浏览器的设备匹配其表达条件时才会应用该@-规则的内容；</li>
<li>@supports 只有浏览器确实支持被测功能时才会应用该@-规则的内容；</li>
<li>@document 只有当前页面匹配一些条件时才会应用该@-规则的内容。</li>
</ul>
<p>任何不是规则集或@-规则或嵌套语句的 CSS 语句都是无效的，并会因此被忽略。</p>
<h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><p>选择器可以被分为以下类别：</p>
<ul>
<li>简单选择器（Simple selectors）：通过元素类型、class 或 id 匹配一个或多个元素。</li>
<li>属性选择器（Attribute selectors）：通过 属性 / 属性值 匹配一个或多个元素。</li>
<li>伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点。</li>
<li>伪元素（Pseudo-elements）:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 </li>
<li>组合器（Combinators）：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在headings后面的段落。</li>
<li>多重选择器（Multiple selectors）：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个CSS规则下面， 以将一组声明应用于由这些选择器选择的所有元素。</li>
</ul>
<h3 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h3><p>“简单”选择器，之所以这么称呼它是因为它们基于元素的类型（或其 class或 id）直接匹配文档的一个或多个元素。</p>
<h4 id="类型选择器（又名元素选择器）"><a href="#类型选择器（又名元素选择器）" class="headerlink" title="类型选择器（又名元素选择器）"></a>类型选择器（又名元素选择器）</h4><p>此选择器只是一个选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。</p>
<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><p>类选择器由一个点“.”以及类后面的类名组成。类名是在HTML class文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名(以空格分开多个类名的形式书写)。</p>
<h4 id="ID-选择器节"><a href="#ID-选择器节" class="headerlink" title="ID 选择器节"></a>ID 选择器节</h4><p>ID选择器是由一个哈希/磅符号 (#)，后面跟着给定元素的ID名称组成的。 任何元素都可以使用id属性设置唯一的ID名称。 由你自己决定选择一个ID名称是什么。 这是选择单个元素的最有效的方式。</p>
<p>注意：一个ID名称必须在文档中是唯一的。关于重复ID的行为是不可预测的，比如一些浏览器只是计入第一个实例，其余的将被忽略</p>
<h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><p>通用选择（*）是最终的王牌。它允许选择在一个页面中的所有元素。由于给每个元素应用同样的规则几乎没有什么实际价值，更常见的做法是与其他选择器结合使用。</p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>属性选择器是一种特殊类型的选择器，它根据元素的 属性 和属性值来匹配元素。它们的通用语法由方括号 ([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： </p>
<ul>
<li>存在和值属性选择器</li>
<li>子串值属性选择器。</li>
</ul>
<h4 id="存在和值（Presence-and-value）属性选择器"><a href="#存在和值（Presence-and-value）属性选择器" class="headerlink" title="存在和值（Presence and value）属性选择器"></a>存在和值（Presence and value）属性选择器</h4><p>这些属性选择器尝试匹配精确的属性值：</p>
<ul>
<li>[attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。</li>
<li>[attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。</li>
<li>[attr~=val]：该选择器仅选择具有 attr 属性的元素，而且要求 val 值是 attr 值包含的被空格分隔的取值列表里中的一个。</li>
</ul>
<h4 id="子串值（Substring-value）属性选择器"><a href="#子串值（Substring-value）属性选择器" class="headerlink" title="子串值（Substring value）属性选择器"></a>子串值（Substring value）属性选择器</h4><p>这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似 regular expression 的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）：</p>
<ul>
<li>[attr|=val] : 选择attr属性的值是 val 或值以 val- 开头的元素（注意，这里的 “-” 不是一个错误，这是用来处理语言编码的）。</li>
<li>[attr^=val] : 选择attr属性的值以 val 开头（包括 val）的元素。</li>
<li>[attr$=val] : 选择attr属性的值以 val 结尾（包括 val）的元素。</li>
<li>[attr*=val] : 选择attr属性的值中包含子字符串 val 的元素（一个子字符串就是一个字符串的一部分而已，例如，”cat“ 是 字符串 ”caterpillar“ 的子字符串）。</li>
</ul>
<h3 id="伪选择器"><a href="#伪选择器" class="headerlink" title="伪选择器"></a>伪选择器</h3><p>伪选择器 。该选择器不是选择元素，而是元素的某些部分，或仅在某些特定上下文中存在的元素。它们有两种主要类型 ：</p>
<ul>
<li>伪类</li>
<li>伪元素。</li>
</ul>
<h4 id="伪类（Pseudo-class）"><a href="#伪类（Pseudo-class）" class="headerlink" title="伪类（Pseudo-class）"></a>伪类（Pseudo-class）</h4><p>一个 CSS  伪类（pseudo-class） 是一个以冒号(:)作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。下面是一些伪类示例：</p>
<ul>
<li>:active</li>
<li>:any</li>
<li>:checked</li>
<li>:default</li>
<li>:dir()</li>
</ul>
<h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 (::) ， 同样是添加到选择器后面去选择某个元素的某个部分。</p>
<ul>
<li>::after</li>
<li>::before</li>
<li>::first-letter</li>
<li>::first-line</li>
<li>::selection</li>
<li>::backdrop</li>
</ul>
<h3 id="组合器和选择器组"><a href="#组合器和选择器组" class="headerlink" title="组合器和选择器组"></a>组合器和选择器组</h3><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:right">组合器</th>
<th style="text-align:right">选择</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择器组</td>
<td style="text-align:right">A,B</td>
<td style="text-align:right">匹配满足A（和/或）B的任意元素（参见下方 同一规则集上的多个选择器）.</td>
</tr>
<tr>
<td>后代选择器</td>
<td style="text-align:right">A B</td>
<td style="text-align:right">匹配B元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）</td>
</tr>
<tr>
<td>子选择器</td>
<td style="text-align:right">A &gt; B</td>
<td style="text-align:right">匹配B元素，满足条件：B是A的直接子节点</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td style="text-align:right">A + B</td>
<td style="text-align:right">匹配B元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）</td>
</tr>
<tr>
<td>通用兄弟选择器</td>
<td style="text-align:right">A ~ B</td>
<td style="text-align:right">匹配B元素，满足条件：B是A之后的任意一个兄弟节点（AB有相同的父节点，B在A之后，但不一定是紧挨着A）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="CSS数值与单位"><a href="#CSS数值与单位" class="headerlink" title="CSS数值与单位"></a>CSS数值与单位</h2><h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>当有多个选择器匹配到同一个元素上时，哪个选择器的 CSS 规则最终会应用到元素上？<br>什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的——前面的的一种会否决后一种）：</p>
<ol>
<li>重要性（Importance）</li>
<li>专用性（Specificity）</li>
<li>源代码次序（Source order）</li>
</ol>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>在CSS中，有一个特别的语法可以让一条规则总是优先于其他规则：<code>!important</code> 。把它加在属性值的后面可以使这条声明有无比强大的力量。<br>相互冲突的声明将按以下顺序适用，后一种将覆盖先前的声明：</p>
<ol>
<li>在用户代理样式表的声明 (例如：浏览器在没有其他声明的默认样式).</li>
<li>用户样式表中的普通声明（由用户设置的自定义样式）。</li>
<li>作者样式表中的普通声明（这是我们设置的样式，Web开发人员）。</li>
<li>作者样式表中的重要声明</li>
<li>用户样式表中的重要声明</li>
</ol>
<h3 id="专用性"><a href="#专用性" class="headerlink" title="专用性"></a>专用性</h3><p>一个选择器具有的专用性的量是用四种不同的值（或组件）来衡量的，它们可以被认为是千位，百位，十位和个位——在四个列中的四个简单数字：</p>
<ol>
<li>千位：如果声明是在style 属性中该列加1分（这样的声明没有选择器，所以它们的专用性总是1000。）否则为0。</li>
<li>百位：在整个选择器中每包含一个ID选择器就在该列中加1分。</li>
<li>十位：在整个选择器中每包含一个类选择器、属性选择器、或者伪类就在该列中加1分。</li>
<li>个位：在整个选择器中每包含一个元素选择器或伪元素就在该列中加1分。<br>通用选择器 (*), 复合选择器 (+, &gt;, ~, ‘ ‘) 和否定伪类 (:not) 在专用性中无影响。如果多个选择器具有相同的重要性和专用性，则选择哪一个选择器取决于 Source order.</li>
</ol>
<p>下表显示了几个示例。试着通过这些，并确保你理解他们为什么具有我们给予他们的专用性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选择器</th>
<th>千位</th>
<th>百位</th>
<th>十位</th>
<th>个位</th>
<th>合计值</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>#indentifier</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0100</td>
</tr>
<tr>
<td>h1 + p::first-letter</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>0003</td>
</tr>
<tr>
<td>li &gt; a[href*=”zh-CN”] &gt; .inline-warning</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>0022</td>
</tr>
<tr>
<td>没有选择器, 规则在一个元素的 &lt;style&gt; 属性里</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1000</td>
</tr>
</tbody>
</table>
</div>
<p>在考虑所有这些层叠理论和什么样式优先于其他样式被应用时，你应该记住的一件事是，所有这些都发生在属性级别上——属性覆盖其他属性，但你不会让整个规则凌驾于其他规则之上。<br>当多个CSS规则匹配相同的元素时，它们都被应用到该元素中。只有在这之后，任何相互冲突的属性才会被评估，以确定哪种风格会战胜其他类型。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>CSS为处理继承提供了四种特殊的通用属性值：</p>
<ul>
<li>inherit： 该值将应用到选定元素的属性值设置为与其父元素一样。</li>
<li>initial ：该值将应用到选定元素的属性值设置为与浏览器默认样式表中该元素设置的值一样。如果浏览器默认样式表中没有设置值，并且该属性是自然继承的，那么该属性值就被设置为 inherit。</li>
<li>unset ：该值将属性重置为其自然值，即如果属性是自然继承的，那么它就表现得像 inherit，否则就是表现得像 initial。</li>
<li>revert ：如果当前的节点没有应用任何样式，则将该属性恢复到它所拥有的值。换句话说，属性值被设置成自定义样式所定义的属性（如果被设置）， 否则属性值被设置成用户代理的默认样式。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/22/web/css中的BFC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/web/css中的BFC/" itemprop="url">CSS 之 BFC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-22T23:16:24+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>下列方式会创建块格式化上下文：</p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、+ table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默+ 认属性）或 inline-table）</li>
<li>overflow 值不为 visible 的块元素</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content或 strict 的元素</li>
<li>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li>
<li>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。<br>块格式化上下文包含创建它的元素内部的所有内容.</li>
</ul>
<p>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/os/CPU模式及内存寻址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/os/CPU模式及内存寻址/" itemprop="url">CPU模式及内存寻址</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-30T19:50:07+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/os/" itemprop="url" rel="index">
                    <span itemprop="name">os</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CPU原理及寄存器"><a href="#CPU原理及寄存器" class="headerlink" title="CPU原理及寄存器"></a>CPU原理及寄存器</h3><p><img src="/pics/cpu.png" width="60%" height="50%"></p>
<p><img src="/pics/common-regiisters.png" width="100%" height="50%"></p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p> <img src="/pics/IA32instructor-format.png" alt="IA32指令格式"></p>
<p>寻址，址指的是CPU指令中操作数的地址，寻址就是寻找操作数（包括源操作数和目的操作数）的地址，CPU的寻址方式，就是指CPU指令中支持的给出操作数地址的方式。<br>寻址方式，从大方向来看可以分为: </p>
<ol>
<li>寄存器寻址;</li>
<li>立即数寻址;</li>
<li>内存寻址。<ol>
<li>直接寻址</li>
<li>基址寻址</li>
<li>变址寻址</li>
<li>基址变址寻址</li>
</ol>
</li>
</ol>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>它是指操作数在寄存器中，直接从寄存器中拿数据就行了，因此只要在指令中直接给出寄存器名即可。<br><code>mov ax, 0x10</code><br><code>add ax, 0x10</code><br>上述指令中的源操作数就是寄存器寻址</p>
<h4 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h4><p>立即数就是指令中直接给出的常数，指令中的数据就是操作数，不用去寄存器或者内存中寻找操作数。<br><code>mov ax, 0x10</code> 这条指令中的目的操作数就是寄存器寻址</p>
<h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><p>操作数在内存中的寻址方式称为内存寻址。</p>
<h5 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h5><p>直接寻址，就是将直接在操作数中给出的数字作为内存地址，通过中括号的形式告诉CPU，取此地址中的值作为操作数。如:<br>   mov ax, [0x1234]<br>   mov ax, [fs:0x5678]</p>
<h5 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h5><p>基址寻址，就是在操作数中用 bx 寄存器或bp寄存器作为地址的起始，地址的变化以它为基础。bx寄存器的默认段寄存器是DS，而bp寄存器的默认段寄存器是SS，即bp和sp都是栈 的有效地址。</p>
<h5 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h5><p>变址寻址其实和基址寻址类似，只是寄存器由bx、bp换成了si和di。si是指源索引寄存器(source index)，di是指目的索引寄存器(destination index)。两个寄存器的默认段寄存器都是ds。<br>   mov [di]，ax :将寄存器ax的值存入ds:di指向的内存<br>   mov [si+0x1234], ax ;变址中也可以加个偏移量</p>
<h4 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h4><p>这是基址寻址和变址寻址的结合，即基址寄存器 bx 或 bp 加一个变址寄存器 si 或 di。如:<br>   mov [bx+di], ax 将 ax 中的值送入以 ds 为段基址，bx+di 为偏移地址的内存<br>   add [bx+si], ax 将 ax 与[ds: bx+si]处的值相加后存入内存[ds:bx+si]</p>
<h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><p>x86架构的cpu在启动时都是进入的实模式，实模式的特点是：</p>
<ol>
<li>段式内存访问机制（段基址+段内偏移），操作数一般16位。</li>
<li>16位的寄存器，20位地址线，最大只能访问1M内存。</li>
<li>内存访问方式是段地址*16+偏移地址构成内存的物理地址，且可以通过在程序中修改段基址来访问任意的真实物理内存，并修改。这样用户程序与系统程序一样，拥有至高无上的权利甚至可以修改操作系统的内存。</li>
<li>因为只有16位寄存器，所以一个段最多只能是64KB大小，超过这个大小就要切换段基址来访问更大范围的内存区域。</li>
<li>一次只能运行一个程序。</li>
</ol>
<p>写一个实模式的程序，你要了解你的程序将会被加载到内存的什么位置，然后将合适的段加载到内存中合适的位置（没有被他人占用），并且初始化各个数据段寄存器的值，以保证其正确地指向各个段基址。恶意程序可以访问任意的物理地址，包括更改操作系统占用内存。</p>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>保护模式的一些特性：</p>
<ol>
<li>指令寻址方式扩展，操作数扩展到32位。</li>
<li><p>除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器等都扩展到32位，地址总线和数据总线为32位。<br><img src="/pics/register-extend.png" width="50%" height="50%"></p>
</li>
<li><p>通过段描述符来描述一段内存，包括段基址、段大小、特权级、权限、属性等等。许多描述符组成<strong>全局段描述符表</strong>，存储在内存中。 每个段描述符8个字节。</p>
</li>
<li>GDTR：48位寄存器保存<strong>GDT全局描述符表在内存中的段基址及大小，前32位为GDT在内存中的起始地址，后16位为GDT的大小。所以段描述符表最多存储2^16/2^3=2^13个段</strong>。</li>
<li>每个程序都可以在全局描述符表中定义自己的段描述符。</li>
<li>保护模式下的段寄存器叫做<strong>段选择子</strong>，0~1位用来存储RPL(请求特权级),第2位代表是在GDT还是在LDT中，3~15位为索引，表示在GDT或者LDT表中的索引。</li>
</ol>
<p>进入保护模式的步骤：</p>
<ol>
<li>打开A20地址线(将端口 0x92 的第1位置1)</li>
<li>填写GDT表并将其加载到 GDTR</li>
<li>将CR0寄存器的PE位置1。</li>
</ol>
<h4 id="保护模式下的内存访问过程："><a href="#保护模式下的内存访问过程：" class="headerlink" title="保护模式下的内存访问过程："></a>保护模式下的内存访问过程：</h4><h5 id="分段内存访问（段部件功能）"><a href="#分段内存访问（段部件功能）" class="headerlink" title="分段内存访问（段部件功能）"></a>分段内存访问（段部件功能）</h5><p><img src="/pics/segment.png" alt="保护模式下的内存访问"></p>
<p>因为</p>
<ol>
<li>段描述符（段描述符表）是在内存中，访问内存比较慢</li>
<li>段描述符格式怪异（历史原因），CPU需要额外操作对其进行整合才能根据其中的内容访问内存。<br>所以，有个<strong>段描述符缓冲寄存器</strong>，根据局部性原理，访问一个断后一段时间内将会继续访问该段，段描述符缓冲寄存器用来缓存段描述符避免重复计算。</li>
</ol>
<h5 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h5><ol>
<li>CPU分为4个特权级 ring0/1/2/3，现代操作系统一般只用了0和3，不同特权级下的权限不同，比如一些特权指令只能在0下运行。</li>
<li>每个特权级下都有一个独立的栈，所以最多有4个特权级栈，切换特权级时，也要切换栈。所以说<strong>系统调用是需要开销的</strong>(除了栈切换，还有参数传递和上下文保存的开销)</li>
</ol>
<h5 id="开启分页"><a href="#开启分页" class="headerlink" title="开启分页"></a>开启分页</h5><p>开启分页后的内存访问：<br><!--![一级页表访存过程](/pics/first-page-table.png) --><br>   <img src="/pics/first-page-table.png" width="60%" height="60%"><br>   <img src="/pics/secondary-page-table.png" width="60%" height="60%"><br>图中的段部件就是上文中未开启分页时的访存过程。</p>
<p>既然有了一级页表，为什么还 要搞个二级页表呢?理由如下。</p>
<ol>
<li>一级页表中最多可容纳 1M(2的20次方)个页表项，每个页表项是 4 字节，能map4KB地址空间，如果页表项全满的话， 便是 4MB 大小，而且也标要求是连续的内存空间，很难找到。使用二级页表的话，页目录表4KB，二级页表4KB，只需要4KB即可分配（但是完全4GB的话，也需要4MB一、二级页表来存储，但是可以离散存储）。一个页目录项能 map 4M地址空间。</li>
<li>一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB， 用户进程要占用低 3GB。</li>
<li>每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了。<br>归根结底，我们要解决的是:不要一次性地将全部页表项建好，需要时动态创建页表项。</li>
<li>分页存储管理系统是离散分配，页表是连续存储，所以单个页表大小不得超过系统最大连续可分配单元，这个单元就是单个页面的大小。如果一个页表的大小超过了一个页面（假如是两个页面），那么分页存储管理系统只能分配两个离散的页面存储这个页表，可是PTR（页表寄存器）只有页表始址和页表长度，它默认页表是连续的。为了可以检索两个页面大小的页表，需要另外一个页表来索引这两个离散的页表页面，这就是二级页表。当然如果二级页表也超过了单个页面的大小，那么就需要三级页表，以此类推。</li>
</ol>
<p>启用分页机制:</p>
<ol>
<li>准备好页目录表及页表。 </li>
<li>将页表地址写入控制寄存器 cr3（页目录基址寄存器PDTR）。 </li>
<li>寄存器 cr0 的 PG 位置 1。</li>
</ol>
<p>分页后每个进程都会有一个页表与之对应：</p>
<p><img src="/pics/process_page_table.png" alt="启用分页后的进程"></p>
<h5 id="内存规划"><a href="#内存规划" class="headerlink" title="内存规划"></a>内存规划</h5><p>一个用户进程在保护模式下，所有占用的资源（地址空间）就是在分配给它的页表来定义的。基于上述分析：</p>
<ol>
<li>如果简单来说，所有用户进程都可以分为两个段：代码段和数据段。操作系统加载程序时，可以定义这两个段的DPL为3，且段选择子的RPL也定义为3，这就是为啥用户进程运行在3的原因。且这两个段能被所有的进程共享，因为最终地址是由页表决定的，只要不同进程定义不同的页表，就不会造成地址冲突。</li>
<li>用户进程一般都会使用操作系统提供的功能（系统调用），操作系统的功能是被所有进程共享的，所以在所有进程的页表中，关于系统内核部分的都是一样的。这也就是通常所说的用户4G空间被分成高1G内核空间和3G用户空间的原因。我们通常将内核控制在1G大小，然后同样为内核创建页表，然后将内核页目录表的768~1022（对应高1G空间，1023指向页目录表本身）映射到内核所在的1G地址空间内。在为进程创建页表时，会直接拷贝内核页目录表的项768~1022个页目录表项，这样进程的高1G地址空间就指向内核了。所有进程768~1022页目录项都是相同的。</li>
</ol>
<h5 id="特权级深入浅出"><a href="#特权级深入浅出" class="headerlink" title="特权级深入浅出"></a>特权级深入浅出</h5><p>CPL:(Current Privilege Level):处理器的当前特权级。<br>DPL:(Descriptor Privilege Level):描述符特权级，即段描述符中指定的该段的特权级。</p>
<ol>
<li>欲访问一个非代码段（数据段，栈段等）时，数值上只有CPL ≤ 该段的DPL时，才允许访问该数据段。</li>
<li>欲访问一个代码段时，数值上只有CPL = 该段的DPL时，才允许访问该数据段。就是说跳转到的代码的特权级必须和当前特权级相同才允许执行。因为，首先低特权级的代码不能随便跳转到高特权级的代码去执行，其次 ，高特权级代码也不允许跳转到低特权级代码。<br>由上可知，代码跳转貌似只能平级跳转，那处理器如何实现特权级变化呢？</li>
</ol>
<ul>
<li>唯一一种处理器会从高特权降到低特权运行的情况:处理器从中断处理程序中返回到用户态的时候。</li>
<li>处理器只有通过“门结构”才能由低特权级转移到高特权级。<br>考虑下面的问题：<br>正常情况下用户所提交的缓冲区的选择子指向用户自己的数据段。说到这估计您也想到了，问题来了，倘若用户程序怀着一颗有非法企图的心，将参数—缓冲区所在数据段的选择子，用内核数据段的选择子代替(用多个选择子测试几次数据便可推测内核数据段)，这样就把内核破坏了。<!-- ![非法访问](/pics/cheat-rpl.png) -->
 <img src="/pics/cheat-rpl.png" width="80%" height="80%"><br>这就需要RPL来解决了：<br>RPL（Request Privilege Level):请求者特权级，保存在选择子的低两位。当用户程序请求操作系统服务，如果需要提交选择子作为参数，为安全起见，操作系统会把选择子中的 RPL 改为用户程序的 CPL，为此，处理器还提供了修改 rpl 的相关指令。<br>用户程序的 CPL 是不会骗人的，不可能伪造，它起始是由操作系统在加载用户程序时赋予的，记录在段 寄存器 CS 中的低 2 位，就是 RPL 的位置，而 CS 寄存器只能通过 call、jmp、ret、int、sysenter 等指令修改， 即使改的话，用户程序也只能在 3 级特权下折腾，只要用户进程不请求操作系统服务，它的 CPL 是不会变的， 当它申请了系统服务，如果提交了选择子作为参数，选择子中的 RPL 也会被操作系统修改为用户进程的 CPL。 所以，即使用户程序提交了个伪造的选择子也没用，其 RPL 会被操作系统用其 CPL 替换，还其“真身”。<br>有了RPL，在进行特权检查时要求：<br>数值上 CPL≥DPL 并且 RPL≤DPL</li>
</ul>
<p>总结下不通过调用门、直接访问一般数据和代码时的特权检查规则，对于受访者为代码段时: </p>
<ul>
<li><p>如果目标为非一致性代码段，要求:</p>
<p> 数值上 CPL=RPL=目标代码段 DPL</p>
</li>
<li><p>如果目标为一致性代码段，要求:</p>
<p> 数值上(CPL≥目标代码段 DPL &amp;&amp; RPL≥目标代码段 DPL)</p>
</li>
<li><p>受访者若为代码，只有在特权级转移时才会被用到，所以有关代码的特权检查都发生在能够改变代码 段寄存器 CS 和指令指针寄存器 EIP 的指令中，即这些指令要么改变 EIP，要么改变 CS 和 EIP。例如 call、 jmp、int、ret、sysexit 等能改变程序执行流的指令。<br>对于受访者为数据段时:</p>
<p> 数值上(CPL ≤目标数据段 DPL &amp;&amp; RPL ≤ 目标数据段 DPL) </p>
</li>
<li><p>栈段的特权级检查比较特殊，因为在各个特权级下，处理器都要有相应的栈(后面会说到)，也就是说栈的特权等级要和 CPL 相同。所以往段寄存器 SS 中赋予数据段选择子时，处理器要求 CPL 等于栈段 选择子对应的数据段的 DPL，</p>
<p> 即数值上 CPL = RPL = 用作栈的目标数据段 DPL。</p>
</li>
</ul>
<h5 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h5><p>   <img src="/pics/door.png" width="60%" height="60%"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/17/TCP-IP/arp协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/17/TCP-IP/arp协议/" itemprop="url">ARP 协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-17T22:17:26+08:00">
                2019-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络协议/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/pics/arp.png" alt="ARP请求/应答报文格式"><br>以太网目的地址为全1表示的是特殊的广播地址，电缆上的所有以太网络接口都要接收广播的数据帧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/19/java/UML类图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/19/java/UML类图/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-19T19:19:59+08:00">
                2021-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/19/work/面试问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/19/work/面试问题/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-19T11:37:25+08:00">
                2020-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&lt;!:: :::<br>title: 面试问题汇总<br>date: 2018:05:29 14:02:00<br>tags: interview<br>category: interview<br>:::</p>
<h1 id="面试问题汇总"><a href="#面试问题汇总" class="headerlink" title="面试问题汇总"></a>面试问题汇总</h1><p>::::::::::::::::::::::::::::::</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ol>
<li>shell查看文件多少行？</li>
<li>软链接和硬链接？</li>
</ol>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ol>
<li>分布式系统如何实现幂等性？</li>
<li>如何实现分布式事务？</li>
</ol>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ol>
<li>AQS CAS</li>
<li>HashMap非线程安全的原因及ConcurrentHashMap线程安全原理。</li>
<li>正则表达式？</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>大数据下的分页查询快吗？如何加快？</li>
<li>join和left join区别？having？</li>
</ol>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ol>
<li>js的apply方法？</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol>
<li>给定一个整数数组和一个m,n求元素和最大的长度在m和n之间的连续子数组？</li>
<li>LRU、LFU算法的实现？</li>
<li>O(1)的栈，返回栈内的最大数？</li>
<li>判断回文串？</li>
</ol>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ol>
<li>spring @Transactional 注解和编程式事务</li>
<li>数据库事务实现原理（MVCC）</li>
</ol>
<p>&lt;!:: 1. 自我介绍</p>
<ol>
<li>为什么离职</li>
</ol>
<ul>
<li>入职的时候，项目刚刚完成，没有接到新的项目，提出的几个项目都被砍掉了。目前只是在维护老项目。组内没有核心业务。个人想寻求更多的项目经验，提升技术。</li>
<li>女友在江苏路上班，且两人有在这边买房的计划，所以想换个较劲的地方上班</li>
</ul>
<ol>
<li>有什么职业规划</li>
<li>对我们公司有什么了解？对证券行业有什么了解？</li>
<li>认为管理要有哪些素质？</li>
<li>项目介绍 ::&gt; ::&gt;</li>
</ol>
<p>腾讯面试：<br>TCP状态图、滑动窗口、超时重传、四次挥手的 time_wait状态<br>进程通信方式<br>死锁原因（条件）<br>五种IO模型，<br>进程、线程、协程区别<br>分布式锁<br>缓存穿透、缓存击穿<br>HTTP、HTTPS、跨域</p>
<pre><code>30:B4:9E:A9:34:4B
</code></pre><p>ip.addr==180.101.49.12 &amp;&amp; tcp.port==443</p>
<p>ffffffffffff<br>0c6abc5f846f<br>0806<br>0001<br>0800<br>06<br>04<br>0001<br>0c6abc5f846f<br>c0a80101<br>000000000000<br>c0a80102<br>000000000000000000000000000000000000</p>
<p>30b49ea9344b<br>30b49ea9344b<br>0806<br>0001<br>0800<br>06<br>04<br>000230b49ea9344bc0a8010630b49ea9344bc0a80101</p>
<p>ffffffffffff<br>0c6abc5f846f<br>0806<br>0001<br>0800<br>06<br>04<br>0001<br>0c6abc5f846f<br>c0a80101<br>000000000000<br>c0a80102<br>000000000000000000000000000000000000</p>
<p>30:B4:9E:A9:34:4B</p>
<p>0c:6a:bc:5f:84:6f</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/19/work/项目亮点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/19/work/项目亮点/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-19T11:37:25+08:00">
                2020-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>cache vendor的response<ul>
<li>requestHash计算</li>
<li>request、response的异步保存</li>
<li>淘汰策略</li>
</ul>
</li>
</ol>
<p>REGS 工作流程</p>
<pre><code>1. API中定义一个接口，映射到某个URI
2. 在Service中实现这个接口
3. 在workflowcontext.xml中定义一个Bean，配置好
&quot;product&quot;:&quot;AUTHFLOW&quot;,
 &quot;intent&quot;:&quot;AUTHFLOW&quot;,
 &quot;country_code&quot;:&quot;US&quot;,
Workflowcontextfactory 根据这些配置寻找对应的workflowcontext
设置workflowcontext的各个属性值。
</code></pre><ol>
<li>使用workflowExecutor执行workflow</li>
<li>workflowExecutor先调用context的validātor验证一下请求<ol>
<li>调用context的preprocessor执行预处理</li>
<li>判断response是否为空，不为空直接跳到12</li>
<li>为空调用context的requestTransformer的transform方法转换请求内容</li>
<li>调用context的vendorService执行service方法并得到response，一般要定义一个vendorService并重写callExternalService方法对接vendor</li>
<li>设置context的vendorResponse对象为response</li>
<li>调用context的responseTransformer的transform方法转换响应</li>
<li>调用context的postProcessor执行后处理</li>
<li>响应response</li>
</ol>
</li>
</ol>
<p>zootUseCaseId/zootSignupOnProductId<br>zootUseCaseId是我们这边自己定义用来区分不同flow的，会发给zoot，zoot也用这个来区分不同flow，我们用product/intent/country区分，zoot用这个区分不同流量。zootSignupOnProductId是zoot分配给我们的一个ID，对应一个policy。这两个是zoot的，其他vendor没有。</p>
<p>REGS 缓存<br>Preprocessor根据useCaseDeDup是否为真来决定是否缓存的：<br> if (!context.getUseCaseDeDup()) {<br>            saveRequest(context);<br>            return;<br>        }<br>两种开启缓存的方法：</p>
<pre><code>1. 在workflowcontext.xml中配置flowcontext bean时设置useCaseDeDup为true

 //read cache if client need
boolean readCache = HttpHeaderHelper.getReadCache(headers);
workflowContext.setUseCaseDeDup(readCache);

2. 在http请求头中配置Prefer：read-cache,.?cache-item-max-age=\d+的正则表达式匹配
</code></pre><p>缓存 cache时，先计算request的hash值，然后去数据库查找是否有相同hash的response如果有直接返回response，如果没有，callvendor取回response，transform response生成后，应该尽快返回response给上游，并且异步起线程保存response缓存下来，减小延迟SLA。另外，除了缓存外，如果要发MQ、Kafka等应用都要异步启动线程处理。</p>
<p>Audit监控机制<br>如果要从老的workflow切换到新的workflow，主要是上游可能要切换厂商或者其他原因。我们会在调试上线后，监控一段时间，看看切换到新flow的流量是否正常。<br>在这段时间，业务上起作用的还是老的flow，REGS会为老的flow配置一个 auditResponsePostProcessor 的 postprocessor。这个 postprocessor 异步启动一个线程，根据配置，决定是否将同样的请求发送到新的workflow上，如果发到新的workflow上，会比较两个workflow的返回结果，看看是否正常。因为是异步线程，所以不会影响老业务的的及时响应。<br>配置example:<br>{<br>    “audit_config” : {<br>        “audits” : [<br>            {<br>                “primary_workflow”: “WFC_DE_ARL”,<br>                “audit_workflow”: “WFC_DE_ARL_NEW”,<br>                “audit_percentage” : 10<br>            },<br>            {<br>                “primary_workflow”: “WFC_IT_ARL”,<br>                “audit_workflow”: “WFC_IT_ARL_NEW”,<br>                “audit_percentage” : 10<br>            },<br>            {<br>                “primary_workflow”: “WFC_US_NASSN”,<br>                “audit_workflow”: “WFC_US_NASSN_NEW”,<br>                “audit_percentage” : 100<br>            }<br>        ]<br>    }<br>}<br>表示发送10%的流量到新flow上，但是response并不会返回给上游，只是用来检查新flow工作是否符合预期。</p>
<p>Ramup机制<br>audit阶段如果返现一切正常，就会从老的flow切换到新的flow。但是为了安全起见，并不是一步完全切过去，而是以百分比的方式慢慢切到新的flow上。ThrottleService会根据配置决定使用新的还是旧的flow。<br>与 audit不同的是，ramup的时候只会发请求到一个flow，且response会返回给上游，而audit使用旧flow的response，新flow的response只是用来校验。所以此时上游收到的response是既有上游的又有下游的。这样的话，加入切换到新flow出问题了，直接可以修改配置，使切换到新flow上流量的百分比设为0，即可使用旧flow承载全部流量。</p>
<p>Simulator<br>boolean simulationEnabled = config.getBoolean(ServiceConstants.ENABLE_SIMULATOR,<br>                false) &amp;&amp; HttpHeaderHelper.simulatorNotEnabled(context.getHttpHeaders()) ;<br>可以在config或者http请求头中配置是否使用simulator。</p>
<pre><code>1. config文件中的enable_simulation或者在remote config中配置。
2. 在http请求头中添加 SIMULATOR:true
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/03/分布式/redis/Redis-Sentinel高可用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/03/分布式/redis/Redis-Sentinel高可用/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-03T22:51:40+08:00">
                2021-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Coder_Wang</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">170</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coder_Wang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
