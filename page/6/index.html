<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="学习笔记">
<meta name="keywords" content="java sql vue web python">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder_Wang&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Coder_Wang&#39;s blog">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coder_Wang&#39;s blog">
<meta name="twitter:description" content="学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/">





  <title>Coder_Wang's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coder_Wang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/java/jvm/java基础-类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/java/jvm/java基础-类加载机制/" itemprop="url">java基础-类加载机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T21:17:24+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a> </p>
<h2 id="Java语言系统自带有三个类装载器"><a href="#Java语言系统自带有三个类装载器" class="headerlink" title="Java语言系统自带有三个类装载器"></a>Java语言系统自带有三个类装载器</h2><ul>
<li><code>Bootstrap ClassLoader</code> :根装载器，主要加载核心类库，<code>%JRE_HOME%\jre\lib</code>(1.8) 下的 <code>rt.jar</code> 、<code>resources.jar</code> 、<code>charsets.jar</code> 和其它类。另外需要注意的是可以通过启动 JVM 时指定<code>-Xbootclasspath</code> 和路径来改变 <code>Bootstrap ClassLoader</code> 的加载目录。比如 <code>java -Xbootclasspath/a:path</code>， <code>path</code> 被追加到 <code>Bootstrap ClassLoader</code> 默认的加载路径中。</li>
<li><code>Extention ClassLoader</code>: 扩展类装载器，加载目录 <code>%JRE_HOME%\jre\lib\ext</code>(1.8) 目录下的 jar 包和 class 文件。还可以加载 <code>-D java.ext.dirs</code> 选项指定目录下的 jar 和类。</li>
<li><code>App ClassLoader</code>: 应用类装载器，加载当前应用的 <code>classpath</code> 的所有类。</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><code>Bootstrap ClassLoader</code> 是由 C++ 编写的本地代码，由 JDK 的 native 方法调用。<br><code>Extention ClassLoader</code> 和 <code>App ClassLoader</code> 都是 <code>sun.misc.Launcher</code> 的静态内部类。</p>
<h4 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h4><p><code>sun.misc.Launcher</code> 下的 <code>bootClassPath</code> 是 <code>Bootstrap ClassLoader</code>的加载路径。</p>
<pre><code>private static String bootClassPath = System.getProperty(&quot;sun.boot.class.path&quot;);
</code></pre><p>JDK 1.8 下输出的以下路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/classes</span><br></pre></td></tr></table></figure></p>
<h4 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">static class ExtClassLoader extends URLClassLoader &#123;</span><br><span class="line">        private static volatile Launcher.ExtClassLoader instance;</span><br><span class="line"></span><br><span class="line">        public static Launcher.ExtClassLoader getExtClassLoader() throws IOException &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                Class var0 = Launcher.ExtClassLoader.class;</span><br><span class="line">                synchronized(Launcher.ExtClassLoader.class) &#123;</span><br><span class="line">                    if (instance == null) &#123;</span><br><span class="line">                        instance = createExtClassLoader();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private static Launcher.ExtClassLoader createExtClassLoader() throws IOException &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return (Launcher.ExtClassLoader)AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">                    public Launcher.ExtClassLoader run() throws IOException &#123;</span><br><span class="line">                        File[] var1 = Launcher.ExtClassLoader.getExtDirs();</span><br><span class="line">                        int var2 = var1.length;</span><br><span class="line">    </span><br><span class="line">                        for(int var3 = 0; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                            MetaIndex.registerDirectory(var1[var3]);</span><br><span class="line">                        &#125;</span><br><span class="line">    </span><br><span class="line">                        return new Launcher.ExtClassLoader(var1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; catch (PrivilegedActionException var1) &#123;</span><br><span class="line">                throw (IOException)var1.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private static File[] getExtDirs() &#123;</span><br><span class="line">            String var0 = System.getProperty(&quot;java.ext.dirs&quot;);</span><br><span class="line">            File[] var1;</span><br><span class="line">            if (var0 != null) &#123;</span><br><span class="line">                StringTokenizer var2 = new StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">                int var3 = var2.countTokens();</span><br><span class="line">                var1 = new File[var3];</span><br><span class="line">    </span><br><span class="line">                for(int var4 = 0; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                    var1[var4] = new File(var2.nextToken());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                var1 = new File[0];</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            return var1;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private static URL[] getExtURLs(File[] var0) throws IOException &#123;</span><br><span class="line">            Vector var1 = new Vector();</span><br><span class="line">    </span><br><span class="line">            for(int var2 = 0; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">                String[] var3 = var0[var2].list();</span><br><span class="line">                if (var3 != null) &#123;</span><br><span class="line">                    for(int var4 = 0; var4 &lt; var3.length; ++var4) &#123;</span><br><span class="line">                        if (!var3[var4].equals(&quot;meta-index&quot;)) &#123;</span><br><span class="line">                            File var5 = new File(var0[var2], var3[var4]);</span><br><span class="line">                            var1.add(Launcher.getFileURL(var5));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            URL[] var6 = new URL[var1.size()];</span><br><span class="line">            var1.copyInto(var6);</span><br><span class="line">            return var6;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public String findLibrary(String var1) &#123;</span><br><span class="line">            var1 = System.mapLibraryName(var1);</span><br><span class="line">            URL[] var2 = super.getURLs();</span><br><span class="line">            File var3 = null;</span><br><span class="line">    </span><br><span class="line">            for(int var4 = 0; var4 &lt; var2.length; ++var4) &#123;</span><br><span class="line">                URI var5;</span><br><span class="line">                try &#123;</span><br><span class="line">                    var5 = var2[var4].toURI();</span><br><span class="line">                &#125; catch (URISyntaxException var9) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                File var6 = Paths.get(var5).toFile().getParentFile();</span><br><span class="line">                if (var6 != null &amp;&amp; !var6.equals(var3)) &#123;</span><br><span class="line">                    String var7 = VM.getSavedProperty(&quot;os.arch&quot;);</span><br><span class="line">                    File var8;</span><br><span class="line">                    if (var7 != null) &#123;</span><br><span class="line">                        var8 = new File(new File(var6, var7), var1);</span><br><span class="line">                        if (var8.exists()) &#123;</span><br><span class="line">                            return var8.getAbsolutePath();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    var8 = new File(var6, var1);</span><br><span class="line">                    if (var8.exists()) &#123;</span><br><span class="line">                        return var8.getAbsolutePath();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                var3 = var6;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>ExtClassLoader</code> 加载的是 <code>System.getProperty(&quot;java.ext.dirs&quot;)</code> 路径下的类。</p>
<p>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext</span><br><span class="line">/Library/Java/Extensions</span><br><span class="line">/Network/Library/Java/Extensions</span><br><span class="line">/System/Library/Java/Extensions</span><br><span class="line">/usr/lib/java</span><br></pre></td></tr></table></figure></p>
<h4 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h4><p>​<figure class="highlight plain"><figcaption><span>class AppClassLoader extends URLClassLoader &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(this);</span><br><span class="line"></span><br><span class="line">public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException &#123;</span><br><span class="line">    final String var1 = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">    final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1);</span><br><span class="line">    return (ClassLoader)AccessController.doPrivileged(new PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">        public Launcher.AppClassLoader run() &#123;</span><br><span class="line">            URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2);</span><br><span class="line">            return new Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">    super(var1, var2, Launcher.factory);</span><br><span class="line">    this.ucp.initLookupCache(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Class&lt;?&gt; loadClass(String var1, boolean var2) throws ClassNotFoundException &#123;</span><br><span class="line">    int var3 = var1.lastIndexOf(46);</span><br><span class="line">    if (var3 != -1) &#123;</span><br><span class="line">        SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">        if (var4 != null) &#123;</span><br><span class="line">            var4.checkPackageAccess(var1.substring(0, var3));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">        Class var5 = this.findLoadedClass(var1);</span><br><span class="line">        if (var5 != null) &#123;</span><br><span class="line">            if (var2) &#123;</span><br><span class="line">                this.resolveClass(var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return var5;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new ClassNotFoundException(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return super.loadClass(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码中可以看出来： 应用类加载器加载的是 <code>System.getProperty(&quot;java.class.path&quot;)</code> 路径下的类和jar。其实就是 classpath 路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/deploy.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/cldrdata.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/dnsns.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/jaccess.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/jfxrt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/localedata.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/nashorn.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunec.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/zipfs.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/javaws.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jfxswt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/management-agent.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/plugin.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/ant-javafx.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/dt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/javafx-mx.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/jconsole.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/packager.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/sa-jdi.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/tools.jar</span><br><span class="line">/Users/zhongzwang/worksapce/My/JavaBase/sort/out/production/MasetrcardScript</span><br><span class="line">/Applications/IntelliJ IDEA CE.app/Contents/lib/idea_rt.jar</span><br></pre></td></tr></table></figure>
<h2 id="类加载顺序"><a href="#类加载顺序" class="headerlink" title="类加载顺序"></a>类加载顺序</h2><p>每个类加载器都有一个父加载器:<br><code>AppClassLoader</code> 的父加载器是 <code>ExtClassLoader</code> , <code>ExtClassLoader</code> 的父加载器是 <code>Bootstrap ClassLoader</code>。 自定义的父加载器一般是 <code>AppClassLoader</code>.</p>
<p>加载类的步骤一般是：</p>
<ol>
<li>一个 <code>AppClassLoader</code> 查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。</li>
<li>如果 <code>ExtClassLoader</code> 也没有加载过，则由 <code>Bootstrap ClassLoader</code> 出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是 <code>sun.mic.boot.class</code> 下面的路径。找到就返回，没有找到，让子加载器自己去找。</li>
<li><code>Bootstrap ClassLoader</code> 如果没有查找成功，则 <code>ExtClassLoader</code> 自己在 <code>java.ext.dirs</code> 路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。</li>
<li><code>ExtClassLoader</code> 查找不成功， <code>AppClassLoader</code> 就自己查找，在 <code>java.class.path</code> 路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。</li>
</ol>
<h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><h4 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass()"></a>loadClass()</h4><p>上面是方法原型，一般实现这个方法的步骤是</p>
<ol>
<li>执行findLoadedClass(String)去检测这个class是不是已经加载过了。</li>
<li>执行父加载器的loadClass方法。如果父加载器为null，则jvm内置的加载器去替代，也就是Bootstrap ClassLoader。这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。</li>
<li>如果向上委托父加载器没有加载成功，则通过findClass(String)查找。</li>
<li>如果class在上面的步骤中找到了，参数resolve又是true的话，那么loadClass()又会调用resolveClass(Class)这个方法来生成最终的Class对象。 我们可以从源代码看出这个步骤。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // 首先，检测是否已经加载</span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                    	//父加载器不为空则调用父加载器的loadClass</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    	//父加载器为空则调用Bootstrap Classloader</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // ClassNotFoundException thrown if class not found</span><br><span class="line">                    // from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;</span><br><span class="line">                    // If still not found, then invoke findClass in order</span><br><span class="line">                    // to find the class.</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    //父加载器没有找到，则调用findclass</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    // this is the defining class loader; record the stats</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">            	//调用resolveClass()</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>另外，要注意的是如果要编写一个classLoader的子类，也就是自定义一个classloader，建议覆盖findClass()方法，而不要直接改写loadClass()方法。<br>另外<br><figure class="highlight plain"><figcaption><span>(parent !</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	//父加载器不为空则调用父加载器的loadClass</span><br><span class="line">    c = parent.loadClass(name, false);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	//父加载器为空则调用Bootstrap Classloader</span><br><span class="line">    c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><p>不知道大家有没有发现，不管 <code>Bootstrap ClassLoader</code> 还是 <code>ExtClassLoader</code> 等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？</p>
<p>如果要这样做的话，需要我们自定义一个classloader。</p>
<h4 id="自定义步骤"><a href="#自定义步骤" class="headerlink" title="自定义步骤"></a>自定义步骤</h4><ol>
<li>编写一个类继承自ClassLoader抽象类。</li>
<li>复写它的findClass()方法。</li>
<li>在findClass()方法中调用defineClass()。</li>
</ol>
<h5 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass()"></a>defineClass()</h5><p>这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常。</p>
<p><strong> 注意点：</strong><br><strong> 一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 </strong></p>
<p>上面说的是，如果自定义一个ClassLoader，默认的parent父加载器是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/06/java/java基础-注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/java/java基础-注解/" itemprop="url">java基础-注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-06T11:02:00+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java注解"><a href="#java注解" class="headerlink" title="java注解"></a>java注解</h1><hr>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><ol>
<li>@Documented —— 指明拥有这个注解的元素可以被javadoc此类的工具文档化。</li>
<li>@Target —— 指明该类型的注解可以注解的程序元素的范围。该元注解的取值可以为TYPE,METHOD,CONSTRUCTOR,FIELD等。如果Target元注解没有出现，那么定义的注解可以应用于程序的任何元素。</li>
<li>@Inherited —— 指明该注解类型被自动继承。如果用户在当前类中查询这个元注解类型并且当前类的声明中不包含这个元注解类型，那么也将自动查询当前类的父类是否存在Inherited元注解，这个动作将被重复执行知道这个标注类型被找到，或者是查询到顶层的父类。</li>
<li>@Retention——指明了该Annotation被保留的时间长短。RetentionPolicy取值为SOURCE,CLASS,RUNTIME。</li>
</ol>
<h2 id="自定义注解语法"><a href="#自定义注解语法" class="headerlink" title="自定义注解语法"></a>自定义注解语法</h2><p>创建自定义注解和创建一个接口相似，但是注解的interface关键字需要以@符号开头。我们可以为注解声明方法。</p>
<pre><code>@Documented
@Target(ElementType.METHOD)
@Inherited
@Retention(RetentionPolicy.RUNTIME)
    public @interface MethodInfo{
    String author() default &#39;Pankaj&#39;;
    String date();
    int revision() default 1;
    String comments();
}
</code></pre><ul>
<li>注解方法不能带有参数；</li>
<li>注解方法返回值类型限定为： 基本类型 、String 、Enums 、Class 、Annotation 或者是这些类型的数组；</li>
<li>注解方法可以有默认值；</li>
<li>注解本身能够包含元注解，元注解被用来注解其它注解。</li>
</ul>
<h2 id="Java注解解析"><a href="#Java注解解析" class="headerlink" title="Java注解解析"></a>Java注解解析</h2><p>使用反射技术来解析java类的注解。那么注解的RetentionPolicy应该设置为RUNTIME，否则java类的注解信息在执行过程中将不可用，那么我们也不能从中得到任何和注解有关的数据。</p>
<pre><code>public class AnnotationParsing {

public static void main(String[] args) {
    try {
    for (Method method : AnnotationParsing.class
        .getClassLoader()
        .loadClass((&#39;com.journaldev.annotations.AnnotationExample&#39;))
        .getMethods()) {
        // checks if MethodInfo annotation is present for the method
        if (method.isAnnotationPresent(com.journaldev.annotations.MethodInfo.class)) {
            try {
        // iterates all the annotations available in the method
                for (Annotation anno : method.getDeclaredAnnotations()) {
                    System.out.println(&#39;Annotation in Method &#39;&#39;+ method + &#39;&#39; : &#39; + anno);
                    }
                MethodInfo methodAnno = method.getAnnotation(MethodInfo.class);
                if (methodAnno.revision() == 1) {
                    System.out.println(&#39;Method with revision no 1 = &#39;+ method);
                    }

            } catch (Throwable ex) {
                    ex.printStackTrace();
                    }
        }
    }
    } catch (SecurityException | ClassNotFoundException e) {
            e.printStackTrace();
         }
    }

}
</code></pre><h2 id="编译时处理注解"><a href="#编译时处理注解" class="headerlink" title="编译时处理注解"></a>编译时处理注解</h2><p>APT(Annotation Processing Tool)是一种处理注解的工具，它对源代码文件进行检测，并找出源文件所包含的注解信息，然后针对注解信息进行额外的处理。</p>
<p>Java 提供的 javac.exe 编译工具有一个 <code>-processor</code> 选项，该选项可以指定一个注解处理器，如果编译时，指定了注解处理器，那么这个注解处理器将会起作用。</p>
<p>每个注解处理器都需要实现 <code>javax.annotation.processing</code> 包下的 <code>Processor</code> 接口。不过实现该接口必须实现它里边的所有方法，因此通常会采用继承 <code>AbstractProcessor</code> 的方式来实现注解处理器。一个注解处理器可以处理一个或多个注解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/06/java/多线程/java基础-并发之线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/java/多线程/java基础-并发之线程池/" itemprop="url">java基础-并发之线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-06T11:02:00+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><p>合理利用线程池能够带来三个好处：</p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<p>但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
<h2 id="线程池类图结构"><a href="#线程池类图结构" class="headerlink" title="线程池类图结构"></a>线程池类图结构</h2><p><img src="/pics/threadpool1.jpg" alt="继承类图"></p>
<p>AbstractExecutorService是ExecutorService的继承类。</p>
<h2 id="内置线程池"><a href="#内置线程池" class="headerlink" title="内置线程池"></a>内置线程池</h2><p>JDK1.5 提供了一个 Executors 工厂来生产线程池，该工厂里包含如下几个静态工厂方法来创建线程池：</p>
<ol>
<li><code>newCachedThreadPool()</code>: 创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存到线程池中</li>
<li><code>newFixedThreadPool(int nThreads)</code>: 创建一个可重用的、具有固定线程数的线程池</li>
<li><code>newSingleThreadExecutor()</code>: 创建一个只有单线程的线程池</li>
<li><code>newScheduledThreadPool(int corePoolSize )</code>: 创建一个具有固定线程数的线程池，它可以在指定延迟后执行线程任务。corePoolSize指池中保存的线程数，即使线程是空闲的也保存下来</li>
<li><code>newSingleThreadScheduledExecutor()</code>: 创建一个只有单线程的线程池，它可以在指定延迟后执行线程任务。</li>
</ol>
<h2 id="自创建线程池"><a href="#自创建线程池" class="headerlink" title="自创建线程池"></a>自创建线程池</h2><p>我们可以通过ThreadPoolExecutor来创建一个线程池。</p>
<pre><code>public class ThreadPoolExecutor extends AbstractExecutorService {
    .....
    public ThreadPoolExecutor(int corePoolSize,
                                  int maximumPoolSize,
                                  long keepAliveTime,
                                  TimeUnit unit,
                                  BlockingQueue&lt;Runnable&gt; workQueue,
                                  ThreadFactory threadFactory,
                                  RejectedExecutionHandler handler) {
            if (corePoolSize &lt; 0 ||
                maximumPoolSize &lt;= 0 ||
                maximumPoolSize &lt; corePoolSize ||
                keepAliveTime &lt; 0)
                throw new IllegalArgumentException();
            if (workQueue == null || threadFactory == null || handler == null)
                throw new NullPointerException();
            this.corePoolSize = corePoolSize;
            this.maximumPoolSize = maximumPoolSize;
            this.workQueue = workQueue;
            this.keepAliveTime = unit.toNanos(keepAliveTime);
            this.threadFactory = threadFactory;
            this.handler = handler;
        }
}

public ThreadPoolExecutor(int corePoolSize,
                                  int maximumPoolSize,
                                  long keepAliveTime,
                                  TimeUnit unit,
                                  BlockingQueue&lt;Runnable&gt; workQueue,
                                  ThreadFactory threadFactory,
                                  RejectedExecutionHandler handler)
</code></pre><p>上面这个是它的核心构造函数，创建一个线程池需要输入几个参数：</p>
<ol>
<li><strong>int corePoolSize</strong>（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</li>
<li><strong>int maximumPoolSize</strong>（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li>
<li><strong>long keepAliveTime</strong>（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
<li><strong>TimeUnit unit</strong>（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
<li><strong>BlockingQueue<runnable> workQueue</runnable></strong>（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：<ol>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级得无限阻塞队列。</li>
</ol>
</li>
<li><strong>ThreadFactory threadFactory</strong>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。</li>
<li><strong>RejectedExecutionHandler handler</strong>（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略:<ol>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。<br>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>
</ol>
</li>
</ol>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>我们可以使用<code>execute</code>提交的任务，但是<code>execute</code>方法没有返回值，所以无法判断任务知否被线程池执行成功。通过以下代码可知<code>execute</code>方法输入的任务是一个Runnable类的实例。</p>
<pre><code>void execute(Runnable command);
</code></pre><p>我们也可以使用submit 方法来提交任务，它会返回一个<code>future</code>,那么我们可以通过这个<code>future</code>来判断任务是否执行成功，通过<code>future</code>的<code>get</code>方法来获取返回值，<code>get</code>方法会阻塞住直到任务完成，而使用<code>get(long timeout, TimeUnit unit)</code>方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p>
<pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);//任务执行完后，返回 result 结果
</code></pre><p><img src="/pics/how-to-use-executor.jpg" width="60%" hright="60%"></p>
<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>我们可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池，但是它们的实现原理不同：</p>
<ol>
<li>shutdown的原理是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
<li>shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</li>
</ol>
<p>只要调用了这两个关闭方法的其中一个，<code>isShutdown</code>方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用<code>shutdownNow</code>。</p>
<h2 id="线程池的分析"><a href="#线程池的分析" class="headerlink" title="线程池的分析"></a>线程池的分析</h2><p>当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ol>
<li>首先线程池判断基本线程池是否已满？没满（线程数小于核心线程数），即使有空闲线程，也会创建一个工作线程来执行任务。满了（已经达到核心线程数）则进入下个流程。</li>
<li>看看是否有空闲线程可用，有空闲线程则使用空闲线程执行任务；若无空闲线程，则进入下个流程。</li>
<li>线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li>
<li>最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。<br>如下图所示：</li>
</ol>
<p><img src="/pics/Java线程池主要工作流程.jpg" alt="工作流程"><br>注意：上述第二步 —&gt; 看看是否有空闲线程可用，有空闲线程则使用空闲线程执行任务；若无空闲线程，则进入下个流程。没有在图中体现出来。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code>public void execute(Runnable command) {
    if (command == null)
            throw new NullPointerException();

        int c = ctl.get();
        //如果线程数小于核心线程数，则创建线程并执行当前任务
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //拒绝任务
        else if (!addWorker(command, false))
            reject(command);
}
</code></pre><h2 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h2><p>合理的配置线程池<br>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>
<ol>
<li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li>
<li>任务的优先级：高，中和低。</li>
<li>任务的执行时间：长，中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ol>
<p>任务性质不同的任务可以用不同规模的线程池分开处理。</p>
<ul>
<li>CPU密集型任务配置尽可能少的线程数量，如配置<em>N<sub>cpu</sub>+1</em>个线程的线程池。因为如果CPU密集型的任务在执行时，会占用CPU较多时间，增加很多线程也无法提高CPU利用率。</li>
<li>IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，可能要等待IO操作，为了避免CPU闲置，则配置尽可能多的线程以提高CPU的利用率，如<em>2N<sub>cpu</sub></em>。</li>
<li>混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。</li>
</ul>
<p>我们可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>
<p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ul>
<p>通过扩展线程池进行监控。通过继承线程池并重写线程池的 <code>beforeExecute</code> ， <code>afterExecute</code> 和 <code>terminated</code> 方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</p>
<pre><code>protected void beforeExecute(Thread t, Runnable r) { }
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/11/java/多线程/java基础-并发之线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/11/java/多线程/java基础-并发之线程/" itemprop="url">java基础-并发之线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-11T21:14:30+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><img src="/pics/thread-state.jpg" alt="Java线程状态"></p>
<p><img src="/pics/thread-state-transform.png" width="80%" heght="80%"><br>注意：上图中的 WAITING/TIME_WAITING 状态不能直接转换到 RUNNABLE 状态，而是先转换到 BLOCKED 状态，获取到锁后才能转换到 RUNNABLE 状态。如果这时候正好没有其它线程在争取锁，那么被唤醒的线程可以直接获取锁进入 RUNNABLE 状态。</p>
<h3 id="BLOCKED-和-WAITING-区别"><a href="#BLOCKED-和-WAITING-区别" class="headerlink" title="BLOCKED 和 WAITING 区别"></a>BLOCKED 和 WAITING 区别</h3><ol>
<li>线程进入 WAITING 状态是一种主动行为，一般是等待另一个线程的信号，通常用来完成线程的同步；而 BLOCKED 状态是被动的，线程希望继续执行，但是锁被别的线程获取，必须等待别的线程释放锁。</li>
<li>站在调度器的角度上，假如一个线程释放了锁（但是并没有调用 noyify/notifyAll），调度器调度使需要考虑 BLOCKED 队列中的线程让它们争用锁，但是不需要考虑 WAITING 队列中的线程。<br><img src="/pics/wait-blocked.png" width="50%" heght="50%"></li>
</ol>
<h2 id="等待通知机制"><a href="#等待通知机制" class="headerlink" title="等待通知机制"></a>等待通知机制</h2><p><img src="/pics/wait-notify.jpg" width="80%" heght="80%"></p>
<ol>
<li>调用 wait() 、notify() 或 notifyAll() 前需要先获取对象的锁</li>
<li>调用 wait() 会立即释放对象锁（sleep()方法不会释放锁），线程由 RUNNING 变为 WAITING，并将当前线程放置到对象的等待队列</li>
<li>notify() 或 notifyAll() 调用后，等待线程依旧不会立即从 wait() 返回，需要调用 notify() 或 notifyAll()的线程释放锁之后，等待线程才有机会从 wait() 返回。</li>
<li>notify() 方法将等待队列中的一个等待线程从等待队列中移到同步队列中（阻塞于锁的队列），notifyAll() 则是将等待队列中的所有线程移到同步队列中，被移动的线程状态由 WAITING 变为 BLOCKED。</li>
<li>从 wait() 方法返回的前提是获得对象的锁。</li>
</ol>
<h3 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h3><p>等待方遵循如下原则：</p>
<ol>
<li>获取对象锁</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>
<li>条件满足则执行相应的逻辑。<br>对应的伪代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(Object)&#123;</span><br><span class="line">    while(条件不满足)&#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    执行对应逻辑;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通知方遵循如下原则：</p>
<ol>
<li>获取对象锁</li>
<li>改变条件。</li>
<li>通知所有等待在该对象上的线程。<br>对应的伪代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(Object)&#123;</span><br><span class="line">    改变条件;</span><br><span class="line">    Object.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="线程的三种创建方式"><a href="#线程的三种创建方式" class="headerlink" title="线程的三种创建方式"></a>线程的三种创建方式</h3><ol>
<li>继承自 <code>Thread</code> 类，重写 <code>run()</code>方法，并调用 <code>start()</code> 方法启动线程</li>
<li>实现 <code>Runnable</code> 接口，并在实例化 <code>Thread</code> 对象时，将接口实现对象作为构造参数传递进去</li>
<li>创建 <code>Callable</code> 接口的实现类，实现 <code>call()</code> 方法，使用 <code>FutureTask</code> 对象来包装  <code>Callable</code> 对象，构造 <code>Thread</code> 时，将 <code>FutureTask</code>对象作为参数传递进去</li>
</ol>
<p>三种方式的对比：</p>
<ol>
<li>继承 <code>Thread</code> 类后无法继承其它类，实现 <code>Runnable</code> 或 <code>Callable</code> 还可以继承其它类</li>
<li><code>Callable</code> 接口与 <code>Runnable</code>接口相比，可以有返回值且可以抛出异常。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/java/多线程/java基础-并发之底层原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/java/多线程/java基础-并发之底层原理/" itemprop="url">java基础-并发之底层原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-15T20:17:27+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="处理器如何实现原子操作"><a href="#处理器如何实现原子操作" class="headerlink" title="处理器如何实现原子操作"></a>处理器如何实现原子操作</h2><p>处理器提供 Lock 前缀的指令，Lock 前缀指令在多核处理器下会引发两件事情：</p>
<ol>
<li>将当前数据所在的处理器缓存行写回内存。</li>
<li>缓存行写回内存操作在 MESI(修改、独占、共享、无效) 协议下，会使其他处理器里缓存了该数据的缓存行失效，导致重新从内存加载。</li>
</ol>
<h3 id="使用总线锁"><a href="#使用总线锁" class="headerlink" title="使用总线锁"></a>使用总线锁</h3><p>处理器提供的一个 <code>LOCK#</code> 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p>
<p>（有个疑问，多线程时，有可能同一个处理器上并发呀，那么处理器级别的独享内存并不能隔离线程？）。<br>跑在同一个CPU上的线程，共享变量缓存，修改对所有线程可见。</p>
<h3 id="使用缓存锁"><a href="#使用缓存锁" class="headerlink" title="使用缓存锁"></a>使用缓存锁</h3><p>总线锁会阻塞其他处理器所有的总线请求，假设其他处理器请求访问的不是同一个地址，也会被阻塞，开销会比较大。缓存锁定是指内存如果被缓存到缓存行中的话，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不会在总线上声言 <code>LOCK#</code> 信号，缓存一致性机制会使其他处理器缓存的该缓存行失效。</p>
<p>但是有两种情况不会使用缓存锁定：</p>
<ol>
<li>当操作的数据不能缓存到 cache 中，或操作数跨多个缓存行时，处理器会调用总线锁定。</li>
<li>处理器不支持缓存锁定时。</li>
</ol>
<h2 id="synchronized-锁实现原理"><a href="#synchronized-锁实现原理" class="headerlink" title="synchronized 锁实现原理"></a>synchronized 锁实现原理</h2><ol>
<li>对于同步方法，锁的是当前对象</li>
<li>对于静态同步方法，锁的是当前类的 Class 对象</li>
<li>对于同步方法块，锁的是 synchronized 括号里的对象</li>
</ol>
<p>任何对象都有一个 monitor 与之关联，当一个 monitor 被持有后，它将处于锁定状态。 monitorenter指令用来尝试获取锁， monitorexit 指令释放锁。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p><img src="/pics/java对象头长度.png" alt="Java对象头长度"><br>Java对象头的 Mark Word 里存放着对象的 HashCode 、分代年龄和锁标记位。32位 JVM 的 Mark Word 的变化如下：<br><img src="/../../pics/mark-word变化状态.png" alt="Java对象头长度"></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>Java SE 1.6 中，锁一共有四种状态，从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。锁可以升级但不能降级。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h2 id="Java实现原子操作的方式"><a href="#Java实现原子操作的方式" class="headerlink" title="Java实现原子操作的方式"></a>Java实现原子操作的方式</h2><p>Java 中可以使用 CAS 和锁来实现原子操作。</p>
<h3 id="循环CAS实现原子操作"><a href="#循环CAS实现原子操作" class="headerlink" title="循环CAS实现原子操作"></a>循环CAS实现原子操作</h3><p>CMPXCHG:比较交换原子操作指令，第一操作数先和AL/AX/EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL/AX/EAX。多处理器安全，在80486及以上CPU中支持。</p>
<p>比较后交换原子操作原语：</p>
<pre><code>long __stdcall CompareExchange(long volatile*Destination,long Exchange,long Comperand) 
{ 
    __asm 
    { 
        mov     ecx, Destination; 
        mov     edx, Exchange; 
        mov     eax, Comperand; 
        lock cmpxchg [ecx], edx; 
    } 
}
</code></pre><p>注意上述 [ecx] 代表的是共享内存。比较并交换其实是一个 RMW (Read-Modify-Write)操作，若不能保证原子性，就不能保证执行的安全性。<br>JVM 中如果循环调用上述原语函数，直到 [ecx] 内存处的值被更新为 edx 寄存器中的值，就能提供原子更新的方法。</p>
<h4 id="CAS的三大问题"><a href="#CAS的三大问题" class="headerlink" title="CAS的三大问题"></a>CAS的三大问题</h4><ol>
<li>ABA 问题</li>
<li>循环时间开销大：如果 CAS 长时间不成功，会导致 CPU 一直在执行 CAS 操作。</li>
<li>只能保证一个共享变量的原子操作。</li>
</ol>
<h3 id="使用锁机制实现原子操作"><a href="#使用锁机制实现原子操作" class="headerlink" title="使用锁机制实现原子操作"></a>使用锁机制实现原子操作</h3><p>锁机制保证了只有获得了锁的线程才能进入临界区操作锁定的内存区域。JVM 内部实现了多种锁：偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了 CAS，即当一个线程想进入同步块的时候使用循环CAS获取锁，当它退出时，使用循环CAS释放锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/java/多线程/java基础-并发之AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/java/多线程/java基础-并发之AQS/" itemprop="url">java基础-并发之AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T20:18:30+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>AbstractQueuedSynchronizer</code> 队列同步器是用来构建各种锁或者其他同步组件的基础。它使用一个 int 型变量来表示同步状态，通过内置的FIFO队列来完成线程的排队工作，Doug Lea 期望它成为实现大部分同步需求的基础。</p>
<h2 id="对比PV操作"><a href="#对比PV操作" class="headerlink" title="对比PV操作"></a>对比PV操作</h2><p>信号量是 Dijkstra 提出的用于解决进程同步的有效工具。信号量是一个数据结构以及对其的操作。除初始化外，仅能通过两个标准的原子操作wait(S)和 signal(S)来访问。<strong>两个语句对信号量状态的改变是安全的</strong>。</p>
<p>信号量值的含义是表示系统值某类资源的数目。</p>
<ol>
<li>P(S)/wait(S): 每次 P(S) 操作，意味着进程请求一个单位的该类资源，使系统可供分配的该类资源数减少一个。 <ol>
<li>将信号量S的值减1，即S.value:=S.value-1；</li>
<li>当S.value&lt;0时，表示该类资源分配完毕，进程调用block原语，进行自我阻塞，放弃处理机，并插入到信号量链表中。 </li>
</ol>
</li>
<li>V(S)/signal(S): 每次 V(S) 操作，表示执行进程释放一个单位资源，使系统中可供分配的该类资源数增加一个.<ol>
<li>将信号量S的值加1，即S.value:=S.value+1； </li>
<li>如果S.value&lt;=0，表示在该信号量链表中，仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将链表中的第一个等待进程唤醒。</li>
</ol>
</li>
</ol>
<p>初始设置的 S.value值，代表系统含有某类资源的数目，也限制了并发获取该资源的进程的数量。<br>如果 S.value &gt; 0, 表示该资源还有，可以被使用。<br>如果 S.value = 0, 表示该资源正好被进程用完，也没有进程阻塞你等待在该资源上。<br>如果 S.value &lt; 0, 表示该资源用完了，且有进程在阻塞等待该资源。</p>
<p>可以把 <code>AbstractQueuedSynchronizer</code> 类比成信号量数据结构的一种实现。但是比信号量更灵活。</p>
<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖内部的同步队列(双向FIFO队列)来完成同步状态的管理。</p>
<p>独占式同步状态获取流程如下：<br><img src="/pics/AQS-Exclusive.png" height="60%" width="60%"><br>首先调用自定义同步器的 <code>tryAcquire(int arg)</code> 方法，该方法应该保证线程安全地获取同步状态，如果获取失败，则构造同步节点（独占式 <code>NODE.EXCLUSIVE</code> ,同一时刻只能有一个线程成功获取同步状态），并通过 <code>addWaiter(Node node)</code> 方法将该节点加入到同步队列的尾部，最后调用 <code>acquireQueued(final Node node, int arg)</code> 方法，使得该节点（线程）以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    //死循环方式将节点加入队尾</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点进入同步队列之后，就进入了一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        //死循环方式获取同步状态，失败则阻塞</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>锁的释放：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为只有一个线程获取到了锁，所以，释放锁不需要同步。释放锁后，将会唤醒队列中的下一个节点。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/java/jvm/java基础-常用jvm命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/27/java/jvm/java基础-常用jvm命令/" itemprop="url">java基础-常用jvm命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T21:23:38+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p>
<p><strong>常用参数：</strong></p>
<ul>
<li>-l : 输出主类全名或jar路径</li>
<li>-q : 只输出LVMID</li>
<li>-m : 输出JVM启动时传递给main()的参数</li>
<li>-v : 输出JVM启动时显示指定的JVM参数</li>
</ul>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p><strong>命令格式：</strong><br><code>jstat [option] LVMID [interval] [count]</code></p>
<ul>
<li>[option]:操作参数</li>
<li>LVMID:本地虚拟机进程ID</li>
<li>[interval]：连续输出的时间间隔</li>
<li>[count] : 连续输出的次数</li>
</ul>
<p><strong>常用参数：</strong></p>
<ul>
<li>-class: class loader的行为统计</li>
<li>-compiler: HotSpt JIT编译器行为统计</li>
<li>-gc: 垃圾回收的行为统计</li>
<li>-gccapacity: 各个垃圾回收代容量(young,old,perm)和他们相应的空间统计</li>
<li>-gccause: 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因</li>
<li>-gcmetacapacity: 元空间垃圾收集行为统计</li>
<li>-gcnew: 新生代垃圾收集行为统计</li>
<li>-gcnewcapacity: 新生代与其相应的内存空间的统计</li>
<li>-gcold: 年老代行为统计</li>
<li>-gcoldcapacity:  年老代与其相应的内存空间的统计</li>
<li>-gcutil: 垃圾回收统计概述</li>
<li>-printcompilation: HotSpot编译方法统计</li>
</ul>
<p><em>-gc </em></p>
<ul>
<li>S0C : survivor0区的总容量</li>
<li>S1C : survivor1区的总容量</li>
<li>S0U : survivor0区已使用的容量</li>
<li>S1U : survivor1区已使用的容量</li>
<li>EC : Eden区的总容量</li>
<li>EU : Eden区已使用的容量</li>
<li>OC : Old区的总容量</li>
<li>OU : Old区已使用的容量</li>
<li>MC ： 当前 MetaSpace 的容量 (KB)</li>
<li>MU : MetaSpace 的使用 (KB)</li>
<li>YGC : 新生代垃圾回收次数</li>
<li>YGCT : 新生代垃圾回收时间</li>
<li>FGC : 老年代垃圾回收次数</li>
<li>FGCT : 老年代垃圾回收时间</li>
<li>CGC :  Concurrent s Collection</li>
<li>CGCT : Concurrent Total Garbage Collection</li>
<li>CCSC : 压缩类空间大小</li>
<li>CCSU : 压缩类空间使用大小</li>
<li>GCT : 垃圾回收总消耗时间</li>
</ul>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>jmap(JVM Memory Map)命令用于生成 heap dump 文件，如果不使用这个命令，还阔以使用 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p>
<p><strong>命令格式：</strong><br><code>jmap [option] LVMID</code><br><code>jmap -dump:format=b,file=heapdump.phrof pid</code></p>
<p><strong>常用参数：</strong></p>
<ul>
<li>-dump : 生成堆转储快照</li>
<li>-finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</li>
<li>-heap : 显示Java堆详细信息</li>
<li>-histo : 显示堆中对象的统计信息</li>
<li>-permstat : to print permanent generation statistics</li>
<li>-F : 当-dump没有响应时，强制生成dump快照</li>
</ul>
<h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</p>
<p><strong>命令格式：</strong><br><code>jhat [dumpfile]</code></p>
<p><strong>常用参数：</strong></p>
<ul>
<li>-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</li>
<li>-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt;</li>
<li>-port port-number 设置 jhat HTTP server 的端口号. 默认值 7000.&gt;</li>
<li>-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</li>
<li>-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt;</li>
<li>-debug int 设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</li>
<li>-version 启动后只显示版本信息就退出&gt;</li>
<li>-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</li>
</ul>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p>
<p><strong>命令格式：</strong><br><code>jmap [option] LVMID</code></p>
<p><strong>常用参数：</strong></p>
<ul>
<li>-F : 当正常输出请求不被响应时，强制输出线程堆栈</li>
<li>-l : 除堆栈外，显示关于锁的附加信息</li>
<li>-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</li>
</ul>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p>
<p><strong>命令格式：</strong><br><code>jinfo [option] [args] LVMID</code></p>
<p><strong>常用参数：</strong></p>
<ul>
<li>-flag : 输出指定args参数的值</li>
<li>-flags : 不需要args参数，输出所有JVM参数的值</li>
<li>-sysprops : 输出系统属性，等同于System.getProperties()</li>
</ul>
<p>jhsdb jmap —heap —pid 8560</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/java/java基础-安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/12/java/java基础-安全/" itemprop="url">java基础-安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-12T21:32:24+08:00">
                2020-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础安全架构/" itemprop="url" rel="index">
                    <span itemprop="name">java基础安全架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java的安全基础架构主要有以下特点：</p>
<ul>
<li>实现是互相独立的，java中的安全服务是由 provider 提供的，这些 provider 通过标准接口插入到 java 平台，应用程序可以直接请求这些 provider 提供的安全服务。</li>
<li>provider 可跨应用程序进行互操作。具体而言，应用程序未绑定到特定的 provider ，并且 provider 也未绑定到特定的应用程序。</li>
<li>可扩展的， java 中提供了一些基础的安全服务实现，应用程序可以对这些服务进行扩展。且 java 平台也支持安装自定义的 provider</li>
</ul>
<p>java SPI(Servicec provider Interface)机制：<br>是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。我们经常遇到的就是java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。</p>
<p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务实现的工具类是：java.util.ServiceLoader。  </p>
<pre><code>ServiceLoader&lt;SPITest&gt;  spiTests = ServiceLoader.load(com.company.SPITest.class);
        for (SPITest spiTest : spiTests) {
            System.out.println(spiTest.test());
        }
</code></pre><h4 id="Security-Providers"><a href="#Security-Providers" class="headerlink" title="Security Providers"></a>Security Providers</h4><p><code>java.security.Provider</code>实现了 java 平台下 security provider 的概念。每个 provider 包含一个名字和它实现的安全服务的列表。当有多个 provider 实现了同一个服务时，将会选择最高优先级的 provider 提供的服务。</p>
<p>可以使用引擎类的 <code>getInstance</code> 方法从一个底层的 provider 获取安全服务。或者也可以指定 provider name 从指定的 provider 获取安全服务。<br><img src="/pics/provider-select.jpg" alt="provider选取"></p>
<p>provider 的安装：</p>
<ol>
<li>将提供算法实现的 JAR 包放置到 classpath 中即可。</li>
<li>将提供算法实现的 JAR 包放置到扩展路径 <code>&lt;java-home&gt;/lib/ext</code>，或者 JRE 的扩展目录：<code>&lt;jre-home&gt;/lib/ext</code></li>
</ol>
<p>provider 的注册的两种方式：</p>
<ol>
<li>注册需要在安全配置文件中添加相关信息。java 平台安全相关的配置文件在 <code>JRE目录/lib/security/java.security</code>, 可以通过它进行安全相关的配置，也可以调用<code>java.security</code>类相关的方法进行设置。还有一个证书相关的文件 <code>JRE目录/lib/security/cacerts</code>. MAC 下可以使用<code>/usr/libexec/java_home</code>命令查看 java_home。<br>要注册 provider ，在 java.security 文件中，添加 <code>security.provider.n=masterClassName</code>形式的信息。</li>
<li>调用 Security 类的 <code>addProvider</code> 或者 <code>insertProviderAt</code> 方法动态注册，但是需要合适的权限。</li>
</ol>
<p>实现一个 provider 的步骤：</p>
<ol>
<li>编写一个类实现一个 SPI 接口，类必须有一个无参构造函数，部分接口如下：<ul>
<li>SignatureSpi</li>
<li>MessageDigestSpi</li>
<li>KeyPairGeneratorSpi</li>
<li>SecureRandomSpi</li>
<li>AlgorithmParameterGeneratorSpi</li>
<li>AlgorithmParametersSpi</li>
<li>KeyFactorySpi</li>
<li>CertificateFactorySpi</li>
<li>KeyStoreSpi</li>
<li>CipherSpi</li>
<li>KeyAgreementSpi</li>
<li>KeyGeneratorSpi</li>
<li>MacSpi</li>
<li>SecretKeyFactorySpi</li>
<li>ExemptionMechanismSpi</li>
</ul>
</li>
<li>给 provider 取一个名字</li>
<li>编写一个 final 类继承自 java.security.Provide ，在该类的构造函数中要调用 super()方法，传入合适的参数。且还要设置合适的属性，将 provider 提供的所有算法服务名字和对应的实现类添加到属性中。<br> <code>put(&quot;Signature.SHA256withDSA&quot;, &quot;sun.security.provider.DSA&quot;)</code>//该provider中sun.security.provider.DSA类提供 Signature.SHA256withDSA 服务</li>
<li>编译文件并打包到JAR包： <code>jar cvf &lt;JAR file name&gt; &lt;list of classes, separated by spaces&gt;</code></li>
<li>签名 JAR 包。</li>
<li>将 JAR 包安装、注册（见上），可能还需要其他相关的安全设置。</li>
</ol>
<h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><ul>
<li>Java 提供了很多加密算法：</li>
<li>Message digest algorithms 消息摘要算法</li>
<li>Digital signature algorithms 数字签名算法</li>
<li>Symmetric bulk encryption 对称批量加密</li>
<li>Symmetric stream encryption 对称流加密</li>
<li>Asymmetric encryption 非对称加密</li>
<li>Password-based encryption (PBE) 基于密码的加密</li>
<li>Elliptic Curve Cryptography (ECC) 椭圆曲线加密</li>
<li>Key agreement algorithms 密钥协商算法</li>
<li>Key generators 密钥生成</li>
<li>Message Authentication Codes (MACs) 消息认证码</li>
<li>(Pseudo-)random number generators 伪随机数生成算法<br>引擎类：一个引擎类提供一个特定安全服务的接口，但是独立于加密算法的实现和 provider 。Java中有如下引擎类：</li>
<li>SecureRandom: used to generate random or pseudo-random numbers.</li>
<li>MessageDigest: used to calculate the message digest (hash) of specified data.</li>
<li>Signature: initialized with keys, these are used to sign data and verify digital signatures.</li>
<li>Cipher: initialized with keys, these are used for encrypting/decrypting data. There are various types of algorithms: symmetric bulk encryption (e.g. AES), asymmetric encryption (e.g. RSA), and password-based encryption (e.g. PBE).</li>
<li>KeyFactory: used to convert existing opaque cryptographic keys of type Key into key specifications (transparent representations of the underlying key material), and vice versa.</li>
<li>SecretKeyFactory: used to convert existing opaque cryptographic keys of type SecretKey into key specifications (transparent representations of the underlying key material), and vice versa. SecretKeyFactorys are specialized KeyFactorys that create secret (symmetric) keys only.</li>
<li>KeyPairGenerator: used to generate a new pair of public and private keys suitable for use with a specified algorithm.</li>
<li>KeyGenerator: used to generate new secret keys for use with a specified algorithm.</li>
<li>KeyAgreement: used by two or more parties to agree upon and establish a specific key to use for a particular cryptographic operation.</li>
<li>AlgorithmParameters: used to store the parameters for a particular algorithm, including parameter encoding and decoding.</li>
<li>AlgorithmParameterGenerator : used to generate a set of AlgorithmParameters suitable for a specified algorithm.</li>
<li>KeyStore: used to create and manage a keystore. A keystore is a database of keys. Private keys in a keystore have a certificate chain associated with them, which authenticates the corresponding public key. A keystore also contains certificates from trusted entities.</li>
<li>CertificateFactory: used to create public key certificates and Certificate Revocation Lists (CRLs).</li>
<li>CertPathBuilder: used to build certificate chains (also known as certification paths).</li>
<li>CertPathValidator: used to validate certificate chains.</li>
<li>CertStore: used to retrieve Certificates and CRLs from a repository.</li>
</ul>
<h4 id="Public-Key-Infrastructure（PKI公钥基础设施）"><a href="#Public-Key-Infrastructure（PKI公钥基础设施）" class="headerlink" title="Public Key Infrastructure（PKI公钥基础设施）"></a>Public Key Infrastructure（PKI公钥基础设施）</h4><p>PKI包含了密钥、证书、公钥加密算法、trusted Certification Authorities (CAs)（信任的认证机构）以及签名的证书。</p>
<p>Java 支持对密钥和证书的持久化存储。 <code>java.security.KeyStore</code> 类用来管理密钥/信任证书的存储；<code>java.security.cert.CertStore</code>类通常用来存储未信任的证书。</p>
<p>Java 平台包含了标准的PCK11和PCK12，也包含了基于文件的 JKS（Java Key Store），还有 DKS（Domain Key Store，由一系列 keystore组成的逻辑 keystore）. Java中内置了一些权威CA的证书和JKS keystore。存储在<code>JRE目录/lib/security/cacerts</code>中，使用 keytool 可以查看.provider SunPKCS11 提供了 PKCS11 的 keystore。</p>
<p>keytool 和 jarsigner 是两个内置的可以用来管理密钥、证书、keystore的工具。  </p>
<ol>
<li>keytool 用来生成和管理 key store:<ol>
<li>Create public/private key pairs 生成公私钥</li>
<li>Display, import, and export X.509 v1, v2, and v3 certificates stored as files</li>
<li>Create self-signed certificates 生成自签名证书</li>
<li>Issue certificate (PKCS#10) requests to be sent to CAs</li>
<li>Create certificates based on certificate requests</li>
<li>Import certificate replies (obtained from the CAs sent certificate requests)</li>
<li>Designate public key certificates as trusted 信任公钥证书</li>
<li>Accept a password and store it securely as a secret key</li>
</ol>
</li>
<li>jarsigner 用来签名 jar 包文件。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/java/java基础-基础类库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/11/java/java基础-基础类库/" itemprop="url">java基础-基础类库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-11T21:14:34+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h1><h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><p><code>System</code> 类代表当前 Java 程序的运行平台，程序不能创建 <code>System</code> 类的对象，但是 <code>System</code> 类提供了一些类变量和类方法供使用。</p>
<p><code>System</code> 类提供了标准输入输出和错误输出的类变量（<code>System.in</code>/<code>System.out</code>/<code>System.err</code>)，并提供了一些静态方法用于访问静环境变量、系统属性，还提供了加载文件和动态链接库的方法。</p>
<ul>
<li><code>Map&lt;String,String&gt; getEnv()</code>:获取所有环境变量。</li>
<li><code>String getEnv(String name)</code>:获取指定的环境变量。</li>
<li><code>Properties getProperties()</code>:获取所有系统属性。</li>
<li><code>Property getProperty(String name)</code>:获取指定名字的系统属性。</li>
<li><code>long currentTimeMillis()</code>:返回当前时间与1970/1/1 00:00:00 的时间差，毫秒为单位。</li>
<li><code>long nanoTime()</code>:同上，纳秒为单位。</li>
<li><code>int identityHashCode(Object x)</code>:根据对象地址计算出对象的 hashCode 值。重写 <code>hashCode()</code> 不影响这个方法。</li>
</ul>
<h2 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h2><p><code>Runtime</code> 类代表 Java 程序运行时环境，每个 Java 程序都有一个与之关联的 <code>Runtime</code> 实例，应用程序通过该对象与其运行时环境相连。应用程序不能创建自己的 <code>Runtime</code> 实例，但可以通过类方法 <code>getRuntime()</code> 获取与之关联的 <code>Runtime</code> 对象。</p>
<p>Runtime 类代表 Java 运行时环境，可以访问 JVM 的相关信息，如处理器数量、内存信息等。</p>
<ul>
<li><code>int availabeProcessors()</code> :处理器数量。</li>
<li><code>long freeMemory()</code> :空闲内数。</li>
<li><code>long totalMomery()</code> :总内存数。</li>
<li><code>long maxMomery()</code> :可用最大内存。</li>
<li><code>Process exec(String command)</code> :运行指定命令单独启动一个进程，返回启动进程的引用</li>
</ul>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ul>
<li><code>boolean equals(Object obj)</code>:判断指定对象与调用对象的引用是否相等，直接用 == 号比较两个对象。</li>
<li><code>void finalize(Object obj)</code>:清理对象时的方法。</li>
<li><code>Class&lt;?&gt; getClass()</code>:返回该对象的运行时类，真实类型。</li>
<li><code>int hashCode()</code>:返回该对象的 hashcode 值，默认情况下根据对象的地址来计算（与 <code>System.identityHashCode()</code>一致），但很多类重写了该方法。</li>
<li><code>int toString()</code>:返回该对象的运行时类名+@+十六进制的 hashcode 值。</li>
<li><code>Object clone()</code>:复制当前对象（浅复制），返回当前对象的一个副本。<br><img src="/pics/copy.png" alt="浅复制"></li>
</ul>
<h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><p><code>Objects</code> 类提供了一些方法来操作对象（Object类），且这些方法大多是“空指针”安全的。就是说，如果你不能确定一个对象是否是 <code>null</code> ，如果贸然调用它的实例方法，就会引发 <code>NullPointerexception</code> ，但是如果使用 <code>Objects</code> 类提供的方法就不会。</p>
<ul>
<li><code>String toString(Object o)</code>:如果 o 为 <code>null</code>，则返回 “null”。</li>
<li><code>int hashCode(Object o)</code>:如果 o 为 <code>null</code>，则返回 0。</li>
<li><code>T requireNoNull(T o)</code>:如果 o 为 <code>null</code>，抛出异常，否则返回参数本身。</li>
</ul>
<h2 id="日期时间相关-Date-Calendar"><a href="#日期时间相关-Date-Calendar" class="headerlink" title="日期时间相关 Date/Calendar"></a>日期时间相关 Date/Calendar</h2><p><code>Calendar</code> 是抽象类，不能实例化，需要通过它的类方法 <code>getInstance()</code> 获取实例。可以传入 TimeZone 、 Locale 类来获取指定的 Calendar ，如果不指定，则使用默认的 TimeZone 、 Locale 来创建 Calendar 。</p>
<p>两者的相互转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = calendar.getTime();</span><br><span class="line"></span><br><span class="line">calendar.setTime(date);</span><br></pre></td></tr></table></figure></p>
<p>Java 8 新增了 <code>java.time</code> 包，包含了许多与时间相关的类。</p>
<h2 id="国际化（I18N）与本地化（L10N）"><a href="#国际化（I18N）与本地化（L10N）" class="headerlink" title="国际化（I18N）与本地化（L10N）"></a>国际化（I18N）与本地化（L10N）</h2><p>Java 程序的国际化主要通过如下三个类完成：</p>
<ul>
<li><code>java.util.ResourceBundle</code>:用于加载国家、语言资源包。</li>
<li><code>java.util.Locale</code>:用于封装特定国家/区域、语言环境。</li>
<li><code>java.text.MessageFormat</code>:用于格式化带占位符的字符串。<br>为了实现国际化，必须先提供资源文件。资源文件的内容是很多的 key-value 对， key会在程序中被引用，对应的 value 是显示的字符串。<br>资源文件的命名是有规范的：</li>
<li>baseName_language_country.propertites</li>
<li>baseName_language.propertites</li>
<li>baseName.propertites<br>baseName是资源文件的基本名，可以随意指定；language 和 country 必须是 Java 支持的语言和国家，不能随意变化。</li>
</ul>
<ol>
<li>新建 test.properties 文件，内容为 <code>hello=你好，{0}</code>;</li>
<li>新建 test_en_US.properties文件，内容为 <code>hello=Welcome You,{0}</code>;</li>
<li>使用JDK工具 native2ascii : native2ascii test.properties test_zh_CN.properties， 将非西欧文字转换成 Unicode 编码文件</li>
<li>使用下边代码测试：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Locale locale = Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">ResourceBundle bundle = ResourceBundle.getBundle(&quot;test&quot;,locale);</span><br><span class="line">String str = bundle.getString(&quot;hello);</span><br><span class="line">MessageFormat.format(str,&quot;wzz&quot;);</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="属性文件加载"><a href="#属性文件加载" class="headerlink" title="属性文件加载"></a>属性文件加载</h2><p><code>Properties</code> 类可以方便的加载配置文件，加载文件后，相当于一个 key/value 都是 String 的 Map。</p>
<ul>
<li><code>String getProperty(String key)</code>:获取指定 key 的值。</li>
<li><code>String getProperty(String key, String defaultValue)</code>:获取指定 key 的值， key 不存在时，返回默认值 defaultValue 。</li>
<li><code>String setProperty(String key, String value)</code>:设置属性值。</li>
<li><code>void load(InputStream in)</code>:从属性文件中追加 key-value 属性对到 Properties 对象中。</li>
<li><code>void store(OutputStream out, String comments)</code>:将 Properties 对象中的 key-value 对输出到指定的属性文件中，并添加 comments 。不是追加，会覆盖整个文件内容。</li>
</ul>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul>
<li><code>double floor(double a)</code>: 向下取整</li>
<li><code>double ceil(double a)</code>: 向上取整</li>
<li><code>static double pow(double a, double b)</code>: 计算 a 的 b 次方</li>
<li><code>int round(float a)</code>: 四舍五入值</li>
<li><code>double random()</code>: （0，1）区间的随机值</li>
<li><code>double abs(double a)</code>: 取绝对值</li>
<li><code>int max(int a, int b)</code>: 取两者之间的最大值</li>
<li><code>int min(int a, int b)</code>: 取两者之间的最小值</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/02/java/jvm/java基础-垃圾收集算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/02/java/jvm/java基础-垃圾收集算法/" itemprop="url">java基础-垃圾收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-02T09:28:17+08:00">
                2019-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>垃圾收集需要考虑的三件事情：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<h3 id="两种垃圾收集算法"><a href="#两种垃圾收集算法" class="headerlink" title="两种垃圾收集算法"></a>两种垃圾收集算法</h3><ol>
<li><p>引用计数算法<br>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的，即可以被回收的。<br>单纯的引用计数就很难解决对象之间相互循环引用的问题</p>
</li>
<li><p>可达性分析算法<br>基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<br>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
</li>
</ol>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfM emoryError）等，还有系统类加载器</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<p>在Java中，即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过（任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临<br>下一次回收，它的finalize()方法不会被再次执行），那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>两个分代假说：</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：<strong>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</strong></p>
<p>在Java虚拟机设计时，通常将Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，<strong>每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</strong></p>
<p>假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p>
<ol>
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有标记对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。它的主要不足有两个：</p>
<ol>
<li>效率问题，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li>
<li>空间碎片问题，标记清除之后会产生大量不连续的内存碎片，空间碎片可能会导致后续分配大对象时，无法找到足够的连续内存而触法另一次垃圾收集动作。<br><img src="/pics/标记-清除算法.png" alt="标记清除算法示意图"></li>
</ol>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>复制算法将可用内存划分为大小相等的两块，每次只能<em>轮流</em>使用其中<em>一块</em>。当其中一块内存用完了，就将还存活的对象一次性的复制到另一块内存中，并对当前内存块一次性清除（全部清除掉），后续内存分配在另一块内存中进行。这样，每次垃圾收集都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片问题，只要移动堆顶指针按顺序分配即可（指针碰撞），实现简单，分配高效；它的不足之处在于：可用内存缩减为原来的一半，浪费率太高了；而且，如果 GC 后，存活对象较多，那么将要复制一大批对象，并更新所有的引用地址，这也会降低效率。因此复制算法适用于存活率较低的场景。<br><img src="/pics/复制算法.png" alt="复制算法示意图"></p>
<p>IBM 公司的专门研究表明，新生代中的对象 98% 是朝生夕死的，就是说进行垃圾回收的时候，大约只有 2% 会存活下来。那么我们可以想想有没有什么办法不用浪费一半的内存空间呢？将内存去划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。分配比例是 8:1:1 ，这样，只有 10% 的空间被浪费。至于为什么需要两块 Survivor ？ 想象一下，假设只有一块 Survivor ，那么当轮到在 Survivor 块中分配空间时，因为空间很小，所以很快就会因为内存不够而触发 GC，频繁触发 GC 会影响性能。</p>
<p>另外，我们不能保证每次 GC 后，只有 10% 的对象存活，当 Survivor 空间不够时，需要依赖其它内存（老年代）进行分配担保。GC 后如果存活对象大于 10%，会将 GC 代数（每次GC后，存活对象GC代数增加）较久的对象复制到老年代。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象存活率较高时需要进行较多的复制操作，效率会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存所有对象 100% 存活的极端情况，所以老年代一般不会直接使用这种算法。</p>
<p>根据老年代的特点：存活率较高，有人提出了一种“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有活的对象都像一端移动，然后直接清理掉端边界以外的内存。<br><img src="/pics/标记-整理算法.png" alt="标记-整理算法"></p>
<h3 id="Hotspot的垃圾收集算法细节实现"><a href="#Hotspot的垃圾收集算法细节实现" class="headerlink" title="Hotspot的垃圾收集算法细节实现"></a>Hotspot的垃圾收集算法细节实现</h3><h4 id="1-GC-roots-根节点-枚举"><a href="#1-GC-roots-根节点-枚举" class="headerlink" title="1. GC roots(根节点)枚举"></a>1. GC roots(根节点)枚举</h4><p>固定可作为GC Roots的节点主要在<strong>全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中</strong>，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。<br>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程。</p>
<p>由于目前主流Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>
<p><strong>枚举根节点必须 stop the world，而且java应用方法区越来越大，使得遍历其中获取根引用效率低下。于是，Hotspot使用OopMap的数据结构，在类加载时就把类中的引用类型记录下来（全局性的引用），也会在特定位置记录下栈和寄存器中的引用，因此，垃圾收集开始时，直接把OopMap作为GC roots开始可达性分析即可。</strong></p>
<h4 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2. 安全点"></a>2. 安全点</h4><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。<br>实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）。</p>
<p>另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。</p>
<p>这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地<br>方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。<br>而主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p>
<h4 id="3-安全区域"><a href="#3-安全区域" class="headerlink" title="3. 安全区域"></a>3. 安全区域</h4><p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<h4 id="4-记忆集与卡表"><a href="#4-记忆集与卡表" class="headerlink" title="4. 记忆集与卡表"></a>4. 记忆集与卡表</h4><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合（跨代引用等）的抽象数据结构。</p>
<h4 id="5-并发的可达性分析"><a href="#5-并发的可达性分析" class="headerlink" title="5. 并发的可达性分析"></a>5. 并发的可达性分析</h4><p>保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。并发可达性分析解决的就是在不停止用户线程的情况下完成可达性分析。</p>
<p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>
<p>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
<h2 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h2><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/java/java基础-反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/java/java基础-反射/" itemprop="url">java基础-反射</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-10T20:08:35+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><hr>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取类的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>要想解剖一个类,必须先要获取到该类的字节码文件对象，进而使用的Class类中的方法解剖类。所以先要获取到一个字节码文件对应的Class类型的对象。</p>
<h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>反射把一个java类字节码加载到内存并构造成一个Class类型的对象，并将类中的属性、方法等各种成分映射成相应的Java对象。</p>
<p>一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把各个组成部分映射成一个个对象。（其实：一个类中这些成员方法、构造方法等在Java中都有一个专门的类来描述）。如图是类的正常加载过程：反射的原理在于class对象。<br>熟悉一下加载：Class对象的由来是将class字节码文件读入内存，并为之创建一个Class对象。<br><img src="/pics/ClassObject.png" alt="字节码文件加载实例化Class对象"></p>
<h2 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h2><p>Class类是对java字节码文件的抽象，每个字节码文件加载到jvm后，jvm都会为其生成一个Class类的实例来描述该字节码文件，且每个类或接口的字节码文件只会生成一个Class类的实例。Class类的定义如下：</p>
<pre><code>public final class Class&lt;T&gt; implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement{...}
</code></pre><p>Class没有公共构造方法。Class对象是在加载类时由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的。也就是说不需要我们自己去处理创建，JVM已经帮我们创建好了。</p>
<h2 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h2><ul>
<li>调用某个对象的getClass()方法会返回该对象所属类的Class对象实例，getClass是Object类的方法。</li>
<li>任何数据类型（即类，包括基本数据类型）都有一个“静态”的class属性。</li>
<li>Class类的静态方法：forName(String className)。</li>
</ul>
<h2 id="Class类的方法"><a href="#Class类的方法" class="headerlink" title="Class类的方法"></a>Class类的方法</h2><h3 id="获取构造方法的方法"><a href="#获取构造方法的方法" class="headerlink" title="获取构造方法的方法"></a>获取构造方法的方法</h3><h4 id="getgetConstructors-、getConstructor-Class-lt-gt-…-parameterTypes-获取公有访问级别的构造方法"><a href="#getgetConstructors-、getConstructor-Class-lt-gt-…-parameterTypes-获取公有访问级别的构造方法" class="headerlink" title="getgetConstructors()、getConstructor(Class&lt;?&gt;… parameterTypes)获取公有访问级别的构造方法"></a>getgetConstructors()、getConstructor(Class&lt;?&gt;… parameterTypes)获取公有访问级别的构造方法</h4><ul>
<li>getgetConstructors()可以获取到该类的所有公有构造方法构造方法组成的数组：Constructor[]。</li>
<li>getConstructor(Class&lt;?&gt;… parameterTypes)可以获取到参数类型为parameterTypes指定的公有构造方法的Constructor实例对象。</li>
</ul>
<h4 id="getDeclaredConstructors-、getDeclaredConstructor-Class-lt-gt-…-parameterTypes-获取所有访问级别的构造方法"><a href="#getDeclaredConstructors-、getDeclaredConstructor-Class-lt-gt-…-parameterTypes-获取所有访问级别的构造方法" class="headerlink" title="getDeclaredConstructors()、getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)获取所有访问级别的构造方法"></a>getDeclaredConstructors()、getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)获取所有访问级别的构造方法</h4><ul>
<li>getDeclaredConstructors()可以获取到所有的构造方法(包括：私有、受保护、默认、公有)组成的数组：Constructor[]。</li>
<li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)可以获取到参数类型为parameterTypes指定的所有构造方法(包括：私有、受保护、默认、公有)的Constructor实例对象。</li>
</ul>
<h4 id="newInstance-Object…-initargs-调用构造方法"><a href="#newInstance-Object…-initargs-调用构造方法" class="headerlink" title="newInstance(Object… initargs)调用构造方法"></a>newInstance(Object… initargs)调用构造方法</h4><p>Constructor对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p>
<h3 id="获取成员变量并使用"><a href="#获取成员变量并使用" class="headerlink" title="获取成员变量并使用"></a>获取成员变量并使用</h3><h4 id="getFields-、getField-String-name-获取公有访问级别的属性"><a href="#getFields-、getField-String-name-获取公有访问级别的属性" class="headerlink" title="getFields()、getField(String name)获取公有访问级别的属性"></a>getFields()、getField(String name)获取公有访问级别的属性</h4><ul>
<li>getFields()方法获取类的所有公有访问级别的属性，返回一个属性数组:Field[]。</li>
<li>getField(String name)方法获取名字为name的公有属性，返回属性对象：Field。</li>
</ul>
<h4 id="getDeclaredFields-、getDeclaredField-String-name-获取所有访问级别的属性"><a href="#getDeclaredFields-、getDeclaredField-String-name-获取所有访问级别的属性" class="headerlink" title="getDeclaredFields()、getDeclaredField(String name)获取所有访问级别的属性"></a>getDeclaredFields()、getDeclaredField(String name)获取所有访问级别的属性</h4><ul>
<li>getDeclaredFields()方法获取所有的属性(包括：私有、受保护、默认、公有)，返回一个属性数组:Field[]。</li>
<li>getDeclaredField(String name)方法获取名字为name的所有的属性(包括：私有、受保护、默认、公有)，返回属性对象：Field。</li>
</ul>
<h4 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h4><p>Field类的set(Object object,Object value)方法，可以为object对象的对应属性设置为value值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/java/java基础-包和访问权限/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/java/java基础-包和访问权限/" itemprop="url">java基础-包和访问权限</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-15T21:20:23+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="package、import和import-static"><a href="#package、import和import-static" class="headerlink" title="package、import和import static"></a>package、import和import static</h3><p>为了避免众多开发者使用相同的类名而导致类的冲突，Java引入了包机制，允许在类前面加上前缀，提供多层命名空间，用于解决类的命名冲突、类文件管理等问题。</p>
<p>Java允许把一组功能相关的类放在一个包下，从而组成逻辑上的类库单元。如果希望把类放到指定的包下，应该在java 源程序文件的第一行写下：<br><code>package packagename</code><br>引入包之后，源文件中定义的类都属于这个包。完整类名是包名+类名。如果其它类中要使用这个类，也需要使用包名+类名，除非在同一个包内。没有 package 语句的的源文件中的类位于默认包中。 package 语句必须作为第一条非注释性语句出现在源文件中，且一个源文件只能有一条 package 语句。</p>
<p>使用下列命令编译带包命令的源文件：<br><code>javac -d . Hello.java</code><br>这样会在当前目录下生成 <code>packagename\Hello.class</code> 的结构。假如不使用 -d 选项，则会在当前目录下生成 Hello.class 文件。此时，若用 <code>java Hello</code> 运行程序会报错。</p>
<p>因为 JVM 在装载 packagename.Hello.class时，会依次在 CLASSPATH 路径下查找 packagename 指定的路径层次下查找 Hello.class。同一包内的两个类可以放在不同文件夹下，如 lee.Person 和 lee.PersonTest 两个类，它们完全可以一个放在 C 盘，一个放在 D 盘，只要所在目录位于 CLASSPATH 下即可（IDEA中 test 和 src不在同一个目录，却在同一个包中）。</p>
<p>引入包之后，如果想使用不在同一个包中的其他类，必须使用包名+类名的形式：<br><code>lee.Person p = new lee.Person();</code><br>为了简化编程，Java引入了 import 语句， import 语句可以导入指定包下的某个类或所有类。 import 语句需要出现在 package 语句之后、类定义之前。 import 中的 * 只能代表类，不能代表包。就是说如果引用指定包下的 *，不能导入该包中子包下的类。 </p>
<p><code>import static</code> 可以导入指定类中的静态成员或方法。使用 import 导入类后，可以省略包名，使用 <code>import static</code> 导入后，连类名都可以省略了。</p>
<h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p><img src="/pics/access-control.jpg" alt="访问权限控制"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/java/java基础-动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/java/java基础-动态代理/" itemprop="url">java基础-动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-10T21:49:35+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><pre><code>public class Proxy implements java.io.Serializable{

    public static Object newProxyInstance(ClassLoader loader,
                                      Class&lt;?&gt;[] interfaces,
                                      InvocationHandler h){
                                        ......
                                      }
}
</code></pre><p>Proxy类是java反射工具包，主要功能是生成动态代理,通常使用Proxy.newProxyInstance(…)方法创建Proxy对象。</p>
<p>第一个参数是类加载器对象，</p>
<p>第二个参数是一个Class[]数组，表示代理对象可以代理多个接口中的多个方法，代理对象实际上在内部实现了接口数组中的所有方法，可以看成是接口数组中所有接口的子类型，所以代理对象可以被转换成接口数组中的每个接口类型，并调用接口中的方法。</p>
<p>第三个参数是InvocationHandler对象，当代理对象被当成某个被代理接口的实现对象，并调用被代理接口中的方法时，将会调用InvocationHandler中的invoke方法。并把自身对象的引用作为第一个参数传递给它，把被调用的方法对象作为第二个参数，参数对象作为第三个参数。</p>
<p>Proxy的底层工作原理是：<br>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会依次递增）的代理类，这个类文件放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。</p>
<h1 id="InvocationHandler接口"><a href="#InvocationHandler接口" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h1><pre><code>public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
</code></pre><p>InvocationHandler只有一个invoke方法，有三个参数，proxy是通过Proxy对象生成的动态代理对象，method是代理接口的方法对象，args代表参数。<br>用动态代理的时候一般会实现InvocationHandler接口，在invoke方法中实现通用的代理功能。所有使用了这个InvocationHandler对象的代理对象（上面生成的Proxy对象），在调用代理接口的方法时，都会执行invoke中的代理逻辑。</p>
<p>所以即使没有代理接口的真正实现类，也可以通过代理对象和InvocationHandler实现代理逻辑，此时，没有实现被代理对象的逻辑功能。所以，即使我们只声明一个接口，也可以通过动态代理，为其实现很高端的功能。 Mybatis 就是如此，只要声明数据库访问接口，通过动态代理功能就能实现数据库操作。基本思想是通过接口名和方法名，在 xml 文件中找到对应id的sql语句，并执行。</p>
<p>如果有真正的被代理对象，就是代理接口的实现类对象，则一般会在 InvocationHandler 中，保存一个代理接口实现类对象的引用，并在 invoke 方法中，通过调用 Method 类的 invoke 方法，第一个参数设为被代理对象，表示调用被代理对象（真实对象）的实现方法。</p>
<h1 id="动态代理原理"><a href="#动态代理原理" class="headerlink" title="动态代理原理"></a>动态代理原理</h1><p>JDK的 sun.misc.ProxyGenerator 可以生成动态的代理对象，这个代理类在内部，拥有所代理的接口的所有方法对象(通过反射获得),并且这个代理类会实现所有代理接口的所有方法，并在各个实现方法内部，调用 InvocationHandler 的 invoke 方法，只不过不同实现方法中传递的方法对象和参数不同。通过代理对象调用接口方法，就是调用其内部实现的各个方法。</p>
<p>流程如下：</p>
<pre><code>代理类对象.接口方法()----&gt;代理类对象内部实现的接口方法()-----&gt;InvocationHandler.invoke()方法。

interface A{
  void say();
}

interface B{
  void run();
}

Object o = Proxy.newProxyInstance(A.class.getClassLoader(),new Class[]{A.class,B.class},new Handler());

(A) o.say();
(B) o.run();
</code></pre><p>实际上动态代理生成的类类似于下面这个类：</p>
<pre><code>class Proxy0 implements A,B{
    InvocationHandler h;
    Method say; //通过反射会初始化为A的say方法对象
    Method run; //通过反射会初始化为B的run方法对象

   public void say(){
      h.invoke(this,m1,null);
   }

   public void run(){
      h.invoke(this,m1,null);
   }
}
</code></pre><p>可以通过ProxyGenerator生成二进制文件，然后反编译出来验证结果，大体思想原理是这样的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/18/java/java基础-内部类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/java/java基础-内部类/" itemprop="url">java基础-内部类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T09:27:12+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内部类的好处"><a href="#内部类的好处" class="headerlink" title="内部类的好处"></a>内部类的好处</h3><ul>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类中，不允许同一个包中的其他类访问内部类。</li>
<li>内部类可以直接访问外部类的私有数据。</li>
<li>匿名内部类适用于创建那些只需要一次使用的类。</li>
</ul>
<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><p>内部类主要可以分为以下几类：</p>
<ol>
<li>成员内部类：非静态内部类、静态内部类 </li>
<li>非成员内部类：局部内部类、匿名内部类</li>
</ol>
<h4 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h4><p>没有使用 static 修饰的、作为外部类成员的内部类称为非静态内部类。非静态内部类的内存示意图：<br><img src="/pics/inner-class.jpg" alt="内部类的内存情况"></p>
<ol>
<li>非静态内部类里可以直接访问外部类的 private 成员，因为在非静态内部类对象中保存了它所寄生的外部类对象的引用。（非静态内部类对象必须寄生在外部类对象中）</li>
<li>当非静态内部类对象存在时，则一定存在外部类对象；反之不然。</li>
<li>因为第二条，所以非静态内部类可以访问外部类的私有成员；但是外部类不能直接访问内部类的成员，有可能内部类对象还不存在。</li>
<li>非静态内部类与外部类成员变量相同时，内部类变量会覆盖外部类变量。此时，若想访问外部类变量，要使用：OuterClass.this.fieldName 语法。</li>
<li>不能在外部类的静态方法中访问非静态内部类。</li>
<li>非静态内部类里不能有静态方法、静态成员变量、静态初始化块。</li>
</ol>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>使用 static 修饰的内部类称为静态内部类，这个内部类属于外部类本身而不是属于外部类的某个对象。</p>
<ol>
<li>静态内部类可以包含静态成员，也可以包含非静态成员。</li>
<li>静态内部类作为外部类的静态成员，不能访问外部类的非静态成员，只能访问外部类的静态成员。</li>
<li>静态内部类对象不是寄生在外部类对象中，而是寄生在外部类本身，支持有外部类的引用。因此，静态内部类对象存在时，外部类对象不一定存在，所以静态内部类不能访问外部类的非静态成员。</li>
<li>外部类不能直接访问静态内部类的非静态成员，但是可以动过内部类的类名来访问静态内部类的成员。</li>
</ol>
<h4 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h4><ol>
<li><p>在外部类内部使用</p>
<p> 在外部类内部使用内部类时，和使用普通类没什么区别，唯一的区别在于：<br> 不能在外部类的静态成员中(静态成员方法、静态初始化块)使用非静态内部类。</p>
</li>
<li><p>在外部类以外使用非静态内部类</p>
<p> 声明一个内部类变量：<code>OuterClass.InnerClass varName</code><br> 实例化一个非静态内部类对象，必须现有外部类对象实例： <code>OuterInstance.new InnerClassConstructor()</code></p>
</li>
<li><p>在外部类以外使用静态内部类<br> <code>new OuterClass.InnerConstructor()</code></p>
</li>
</ol>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>在方法内部定义的类，就是一个局部内部类。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/java/java基础-入门，数据类型和数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/java/java基础-入门，数据类型和数组/" itemprop="url">java基础-入门，数据类型和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-06T21:11:40+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ol>
<li>Java是一种纯粹的面向对象语言，所有的程序部分必须放在类中定义，类是Java程序的最小单位，Java不允许任何可执行语句、方法等独立存在（Lambda除外）。</li>
<li>java程序源文件的后缀名必须是 .java ,不能是其他文件后缀</li>
<li>通常情况下，java 程序源文件名是任意的，除非源文件中定义了一个 public 类，此时，源文件名必须与该 public 类的类名相同。</li>
<li>一个源文件中可以有多个类，但是因为上面第2条只能有一个 public 的类。</li>
<li>好的建议是一个文件只定义一个类，文件名与类名保持一致。</li>
<li>java程序是严格区分大小写的。</li>
<li>标识符可以由字母、下划线、美元符号和数字组成，数字不打头。</li>
<li>标识符不能是 java 关键字或保留字。</li>
<li>标识符不能包含空格。</li>
</ol>
<h2 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h2><p>两大类： <strong>基本类型</strong> 和 <strong>引用类型</strong>。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型包括 <strong>boolean 类型</strong> 和 <strong>数值类型</strong> 。</p>
<p><img src="/pics/java_numberic_data.png" alt="基本类型"><br>boolean 类型只有两个直接量值： true 、 false 。</p>
<p>数值类型包括整数类型和浮点数类型。</p>
<p><strong>整数类型</strong>包括： byte 、 short 、 int 、 long 、 char 。</p>
<p><strong>浮点数类型</strong>包括： float 和 double 。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p><strong>引用类型</strong>包括类、接口、数组和特殊的 null 。 null 是引用类型的一个直接量。</p>
<h4 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h4><p>并不是所有的类型都可以指定直接量，能指定直接量的只有三种类型：基本类型、字符串类型 和 null 引用。具体而言， Java 支持以下8中类型的直接量：</p>
<ol>
<li>int 类型的直接量：在程序中直接给出的整数类型数值，可分为二进制、十进制、八进制和十六进制4种，二进制以 0B 或 0b 开头，八进制以 0 开头，十六进制以 0x 或 0X 开头。</li>
<li>long 类型的直接量： 在整型值后边添加L(小l极度不推荐)后就变成了 long 类型的直接量。</li>
<li>double 类型的直接量：直接给出一个标准小数形式或者科学计数法形式的浮点数就是 double 类型额直接量。</li>
<li>float 类型的直接量：在一个浮点数后加f或F就变成了 float 类型。</li>
<li>boolean 类型直接量： true 、false。</li>
<li>char 类型直接量： char 类型的直接量有三种形式，分别是单引号括起来的字符、转义字符和 Unicode 值表示的字符。如 ‘a’ 、 ‘\n’ 和 ‘\u0061’。</li>
<li>String 类型直接量： 一个用双引号括起来的字符序列就是 String 类型直接量。</li>
<li>null ：可以赋值给任意引用类型。</li>
</ol>
<h3 id="基本类型的类型转换"><a href="#基本类型的类型转换" class="headerlink" title="基本类型的类型转换"></a>基本类型的类型转换</h3><p>Java 的7种数值类型可以相互转换，有两种转换方式：自动转换和强制类型转换。</p>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>Java 所有的数值类型变量可以相互转换，Java 系统支持把某种数据类型的值直接赋值给另一种类型的变量，这种方式称为自动类型转换。</p>
<ol>
<li>当把一个表数范围小类型的变量或数值赋值给另一个表数范围大的变量时，系统可以自动进行类型转换，否则就需要强制类型转换。<br><img src="/pics/auto-change.jpg" alt="自动类型转换"></li>
<li>当把任何基本类型的值和字符串进行连接运算时，基本类型的值将自动转换为字符串类型。</li>
</ol>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>如果希望把上图中箭头右边的类型转换为左边的类型，则必须进行强制类型转换，强制类型转换额语法是：<code>(TargetType) value</code> ，强制类型转换的运算符是（ () ）。强制类型转换会造成精度丢失，被称为“缩小转换”。</p>
<h4 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h4><p>当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将发生自动提升。Java定义了如下提升规则：</p>
<ol>
<li>所有的 byte 、 short 和 char 类型将自动被提升为 int 类型。</li>
<li>整个算术表达式的数据类型自动提升到与表达式中最高等级操作数（表数范围最大）同样的类型。</li>
</ol>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calss test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        short s=1; //等价于 short s=(short) 1</span><br><span class="line">        s=s+1; //编译出错，s+1会提升为 int 类型</span><br><span class="line">        s+=1; //等价于 s=(short) (s+1)</span><br><span class="line">        s++; //等价于 s=(short)(s+1)</span><br><span class="line">        system.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这段代码，编译肯定无法通过的，原因是什么？原因就是s=s+1会出错，这是很久之前很常见的一个面试题，这么多年过去了，解答的套路都固定了，让我们看看从java的创造者视角看这个问题是怎么样的？引用资料java语言规范（JLS）</p>
<p>1.JLS（中文版第三版）5.2 赋值转换</p>
<ol>
<li>当把表达式的值赋予一个变量时，就会发生赋值转换：必须把表达式的类型转换为变量的类型；</li>
<li>如果表达式(=号右边部分)是类型byte，short，char，int的常量表达式，则如果变量类型是byte，short，char，并且常量表达式的值在变量的类型中是可以表示的，那么就执行窄化转换（narrowing conversion），如果不能通过赋值环境中允许的转换把表达式的类型转换成变量的类型，那么编译时会报错。这个可以用来<strong>解释s=1，为何将int赋值给short不会报错</strong>。</li>
<li><code>s=s+1</code>为什么会报错？这里我没有看JLS，因为<code>s=s+1</code>，左边有变量参与，编译器在无法分析出该变量的值是什么，因为s为变量，其值不确定无法确定s+1是否超出short范围，为了防止进行类型转换时丢失精度，所以编译器直接当成无法确定来处理，报错了事。so，当有变量为byte，short，char时，编译器就是这么干的。需要知道的是在编译期间，编译器只做语法检查，而不会进行计算动作，也就是说编译器不会对<code>s+1</code>是否查出s的范围而进行一次计算判断。</li>
<li><code>s++</code>呢？如有必要将<code>s+1</code>的和进行窄化转换，即将<code>s+1</code>做强制转换<code>（short）（s+1）</code>然后赋给s。（JLS中文三版15.15.1）</li>
<li>最后s+=1，JLS中文三版15.26.2说对于组合运算符形如<code>E1 op=E2</code>的组合赋值表达式等价于<code>E1=（E1）（（E1）op（E2））</code>，例如<code>s+=1</code>等价于<code>s=(short)(s+1)</code>。</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java数组要求所有数组元素具有相同的类型。Java 数组是一种引用类型。一旦数组的初始化完成，数组在内存中所占的内存空间就被固定下来了，数组的长度将不会改变。Java数组的长度存储在length属性中。</p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><ul>
<li>静态初始化：初始化时由程序员显示指定每个元素的初始值，由系统决定长度。</li>
<li>动态初始化：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。</li>
</ul>
<p>静态初始化： <code>arr = {element1,element2,element3....}</code>; 此外，静态初始化还可以直接在定义时完成： <code>type[] arr={element1,element2,element3....}</code><br>动态初始化： <code>arr = new int[10]</code> 或者 <code>type[] arr= new type[length]</code> ; 系统根据 type 类型，自动初始化数组。</p>
<h3 id="foreach访问数组"><a href="#foreach访问数组" class="headerlink" title="foreach访问数组"></a>foreach访问数组</h3><p>Java 5之后提供的语法糖，使得访问数组更加方便，不需要使用数组下标索引即可访问数组。</p>
<pre><code>for(type var: array | collection){
    var //自动访问每个元素
}
</code></pre><p>如果想要改变数组中每个元素的值，使用var并不能保证，此处的var是一个局部变量。还是要用 <code>arr[index]=value</code> 的方式为数组元素赋值。</p>
<h3 id="Arrays数组工具类"><a href="#Arrays数组工具类" class="headerlink" title="Arrays数组工具类"></a>Arrays数组工具类</h3><ul>
<li><code>int binarySearch(type[] arr, type key)</code> : 使用二分查找在数组arr中查找值为key的元素的索引。如果不存在值为key的元素，返回负数。要求arr数组已经按升序排列。</li>
<li><code>int binarySearch(type[] arr, int from, int end, type key)</code> : 这个方法与前一个方法类似，但是它只搜索数组中 [from, end] 索引的元素。</li>
<li><code>tyep[] copyOf(type[] arr, int len)</code> : 这个方法会把 arr 数组复制成一个长度为 len 的新数组。如果 len 比 arr 的长度小，则只复制 arr 前 len 个元素，如果比 arr 长度大，则后边的元素初始化为0（整型）、0.0（浮点型）、false（布尔型）、null（引用型）。</li>
<li><code>tyep[] copyOfRange(type[] arr, int from, int to)</code> :这个方法与前一个方法类似，但这个方法只复制 arr 数组的 [from,to] 部分。</li>
<li><code>boolean equals(tyape[] a, type[] b)</code> : 如果 a, b长度相等且每个数组的元素一一相同（==），返回 true。</li>
<li><code>void fill(tyape[] a, type value)</code> : 将 a 的所有元素赋值为 value。</li>
<li><code>void fill(tyape[] a,int from,int end, type value)</code> : 将a中索引处于[from,end]的元素全部赋值为 value。</li>
<li><code>void sort(type[] a)</code> : 将数组 a 排序。</li>
<li><code>void sort(type[] a,int from,int end)</code> : 将数组 a 中[from,end]处的元素排序。</li>
<li><code>String toString(type[] a)</code> : 将数组转换成字符串，用逗号连接各个元素。</li>
</ul>
<p>Java 8 中新增的方法：</p>
<ul>
<li><code>void parallelPrefix(type[] a, typeBinaryOperator op)</code> : 利用 op 参数中的计算方法重新计算数组中每个元素的值，op 计算方法包含 left和right两个参数，right指向当前计算元素的索引，left指向right的前一个，第一个元素时，left值为1 。</li>
<li><code>void parallelPrefix(type[] a,int from, int to, typeBinaryOperator op)</code> : 与上个方法类似，但仅计算[from，to]索引处的值。</li>
<li><code>void setAll(type[] a, IntToTypeFunction generator)</code> : 使用指定生成器 generator 为所有元素赋值，generator控制元素值的生成算法。</li>
<li><code>void parallelSetAll(type[] a, IntToTypeFunction generator)</code> : 同上，但是增加了并行能力。</li>
<li><code>void parallelSort(type[] a)</code> : 与 sort 方法类似，只是增加了并行能力。</li>
<li><code>void parallelSort(type[] a, int from,int end)</code> : 与上面方法类似，只排序[from,end]处的元素排序。</li>
<li><code>Spliterator&lt;T&gt; spliterator(T[] array)</code> : 将数组转换成 Spliterator 对象。</li>
<li><code>Spliterator&lt;T&gt; spliterator(T[] array, int startInclusive, int endExclusive)</code> : 同上，值转换[startInclusive,endExclusive]的元素。</li>
<li><code>Stream&lt;T&gt; stream(T[] array)</code> : 将数组转换成 Stream 。</li>
<li><code>Stream&lt;T&gt; stream(T[] array，int startInclusive, int endExclusive)</code> : 同上。</li>
</ul>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句后面的表达式类型只支持 byte 、 short 、char 、 int 四中整数类型（不支持 long 类型），String (Java 7开始支持)和枚举类型。<br>switch 语句会先计算出表达式的值，然后拿着个表达式的值和 case 标签后的值比较，一旦遇到相等的值，程序就开始执行这个 case 标签后的代码，不再判断后边的 case 、 default 标签的条件是否匹配，除非遇到 break 。</p>
<h3 id="jar-命令详解"><a href="#jar-命令详解" class="headerlink" title="jar 命令详解"></a>jar 命令详解</h3><p>jar 是 JDK 自带的工具，依赖于 JDK 的 tools.jar 包。</p>
<ul>
<li>-c  创建新档案</li>
<li>-t  列出档案目录</li>
<li>-x  从档案中提取指定的 (或所有) 文件</li>
<li>-u  更新现有档案</li>
<li>-v  在标准输出中生成详细输出</li>
<li>-f  指定档案文件名</li>
<li>-m  包含指定清单文件中的清单信息</li>
<li>-n  创建新档案后执行 Pack200 规范化</li>
<li>-e  为捆绑到可执行 jar 文件的独立应用程序指定应用程序入口点</li>
<li>-0  仅存储; 不使用任何 ZIP 压缩</li>
<li>-P  保留文件名中的前导 ‘/‘ (绝对路径) 和 “..” (父目录) 组件</li>
<li>-M  不创建条目的清单文件</li>
<li>-i  为指定的 jar 文件生成索引信息</li>
<li>-C  更改为指定的目录并包含以下文件<br>示例：</li>
</ul>
<ol>
<li>jar -cf test.jar test: 将test路径下的全部内容打包成 test.jar</li>
<li>jar -cvf test.jar test: 同上，但是会显示打包过程</li>
<li>jar -cvfM test.jar test: 同上，不生成清单文件</li>
<li>jar -cvfm test.jar manifest.mf test: 同上，使用指定的清单文件</li>
<li>jar tvf test.jar: 查看指定 jar 的文件列表的详细信息</li>
<li>jar -xvf test.jar: 解压缩指定 jar 文件</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/java/IO/java基础-NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/java/IO/java基础-NIO/" itemprop="url">java基础-NIO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-03T08:43:24+08:00">
                2018-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主要转自：<a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html</a></p>
<h2 id="流与块的比较"><a href="#流与块的比较" class="headerlink" title="流与块的比较"></a>流与块的比较</h2><p>面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节流的数据，一个输出流消费一个字节流的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。<br>一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>Channel 是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。<br>所有数据都通过 Buffer 对象来处理。永远不会将字节直接写入通道中，相反，是将数据写入包含一个或者多个字节的缓冲区。同样，也不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。<br>通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道可以用于读、写或者同时用于读写。<br>常见的Channel有： FileChannel、SelectableChannel、ServerSocketChannel、SocketChannel、DatagramChannel、Pipe.SinkChannel、Pipe.SourceChannel。<br>所有 Channel 都不应该使用构造器来直接创建，而是通过传统的节点流 InputStream/OutputStream 的 <code>getChannel</code> 方法来返回对应的Channel。不同的节点流获取的Channel不一样， FileInputStream/FileOutputStream-&gt;FileChannel;PipedInputStream-&gt;Pipe.SinkChannel;PipedOutputStream-&gt;Pipe.SourceChannel。<br>Channel中最常用的方法：</p>
<ul>
<li>map: 将Channel对应的部分或全部数据映射到 ByteBuffer</li>
<li>read: 有很多重载方法，从Channel中读取数据到给定 buffer</li>
<li>write: 有很多重载方法，将 buffer 中的数据写入到 Channel</li>
</ul>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中。</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，都是将它放到缓冲区中。</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<h3 id="缓冲区的状态变量"><a href="#缓冲区的状态变量" class="headerlink" title="缓冲区的状态变量"></a>缓冲区的状态变量</h3><p>可以用三个值指定缓冲区在任意时刻的状态：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。</p>
<h4 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h4><p>缓冲区的 capacity 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。<br>limit 决不能大于 capacity。</p>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。<br>同样，在写入通道时，您是从缓冲区中获取数据。 position 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 position 将被设置为5，指向数组的第六个元素。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit 变量表明还有多少数据需要取出。(在从缓冲区写入通道时)limit等于缓冲区中数据的数量，或者还有多少空间可以放入数据(在从通道读入缓冲区时)，limit应该等于capacity。<br>position 总是小于或者等于 limit。</p>
<h4 id="flip方法"><a href="#flip方法" class="headerlink" title="flip方法"></a>flip方法</h4><p>现在我们要将数据写到输出通道中。在这之前，我们必须调用 flip() 方法。这个方法做两件非常重要的事：</p>
<ul>
<li>它将 limit 设置为当前 position。</li>
<li>它将 position 设置为 0。</li>
</ul>
<h4 id="clear方法"><a href="#clear方法" class="headerlink" title="clear方法"></a>clear方法</h4><p>从通道读入数据到缓冲区之前，这个方法重设缓冲区以便接收更多的字节。 Clear 做两件非常重要的事情：</p>
<ul>
<li>它将 limit 设置为与 capacity 相同。</li>
<li>它设置 position 为 0。</li>
</ul>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h4><p>ByteBuffer 类中有四个 get() 方法：</p>
<ul>
<li>byte get(): 获取单个字节</li>
<li>ByteBuffer get(byte[] dst): 将一组字节读到一个数组中</li>
<li>ByteBuffer get(byte[] dst, int offset, int length): 将一组字节读到一个数组中，从 offset 开始的 length 个字节</li>
<li>byte get( int index ): 从缓冲区中的特定位置获取字节</li>
</ul>
<p>此外，我们认为前三个 get() 方法是相对的，而最后一个方法是绝对的。 相对意味着 get() 操作服从 limit 和 position 值 ― 更明确地说，字节是从当前 position 读取的，而 position 在 get 之后会增加。另一方面，一个 绝对方法会忽略 limit 和 position 值，也不会影响它们。事实上，它完全绕过了缓冲区的统计方法。<br>上面列出的方法对应于 ByteBuffer 类。其他类有等价的 get() 方法，这些方法除了不是处理字节外，其它方面是是完全一样的，它们处理的是与该缓冲区类相适应的类型。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><p>ByteBuffer 类中有五个 put() 方法：</p>
<ul>
<li>ByteBuffer put( byte b );</li>
<li>ByteBuffer put( byte src[] );</li>
<li>ByteBuffer put( byte src[], int offset, int length );</li>
<li>ByteBuffer put( ByteBuffer src );</li>
<li>ByteBuffer put( int index, byte b );<br>第一个方法 写入（put） 单个字节。第二和第三个方法写入来自一个数组的一组字节。第四个方法将数据从一个给定的源 ByteBuffer 写入这个 ByteBuffer。第五个方法将字节写入缓冲区中特定的 位置 。那些返回 ByteBuffer 的方法只是返回调用它们的缓冲区的 this 值。</li>
</ul>
<p>与 get() 方法一样，我们将把 put() 方法划分为 相对 或者 绝对 的。前四个方法是相对的，而第五个方法是绝对的。</p>
<p>上面显示的方法对应于 ByteBuffer 类。其他类有等价的 put() 方法，这些方法除了不是处理字节之外，其它方面是完全一样的。它们处理的是与该缓冲区类相适应的类型。</p>
<h4 id="缓冲区分配和包装"><a href="#缓冲区分配和包装" class="headerlink" title="缓冲区分配和包装"></a>缓冲区分配和包装</h4><p>在能够读和写之前，必须有一个缓冲区。要创建缓冲区;</p>
<ol>
<li><p>分配它。我们使用静态方法 allocate() 来分配缓冲区：</p>
<p> ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
</li>
<li><p>还可以将一个现有的数组转换为缓冲区，如下所示：</p>
<p> byte array[] = new byte[1024];<br> ByteBuffer buffer = ByteBuffer.wrap( array );</p>
</li>
</ol>
<h2 id="NIO-网络编程的一般步骤"><a href="#NIO-网络编程的一般步骤" class="headerlink" title="NIO 网络编程的一般步骤"></a>NIO 网络编程的一般步骤</h2><h3 id="服务器端打开一个-ServerSocketChannel"><a href="#服务器端打开一个-ServerSocketChannel" class="headerlink" title="服务器端打开一个 ServerSocketChannel"></a>服务器端打开一个 ServerSocketChannel</h3><p>为了接收连接，我们需要一个 <code>ServerSocketChannel</code> 。事实上，我们要监听的每一个端口都需要有一个 <code>ServerSocketChannel</code> 。对于每一个端口，我们打开一个 <code>ServerSocketChannel</code> ，不能直接使用 <code>ServerScocket</code> 的 getChannel 方法来获得 ServerSocketChannel 对象，也不能直接绑定到端口，必须使用 socket() 方法获得关联的 ServerScocket 对象，然后再用该 ServerScocket 对象来绑定端口。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking( false );</span><br><span class="line">ServerSocket ss = ssc.socket();</span><br><span class="line">InetSocketAddress address = new InetSocketAddress( ports[i] );</span><br><span class="line">ss.bind( address );</span><br></pre></td></tr></table></figure></p>
<p>第一行创建一个新的 <code>ServerSocketChannel</code> ，最后三行将它绑定到给定的端口。第二行将 <code>ServerSocketChannel</code> 设置为<em>非阻塞</em>的 。我们必须对每一个要使用的套接字通道调用这个方法，否则异步 I/O 就不能工作。</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p><code>Selector</code> 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。<br>我们关心某个channel是否发生了读写或者Accept事件，就把这个channel和相应的事件通过channel的register方法注册到selector对象上，这样selector会在这些channel上发生了你感兴趣的事件时通知你。</p>
<p>所以，我们需要做的第一件事就是创建一个 Selector，通过 Selector 类的静态方法 opeb() 来获得系统默认的 Selector：</p>
<pre><code>Selector selector = Selector.open();
</code></pre><p>然后，我们将对不同的<em>通道对象</em>调用 <code>register()</code> 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。<code>register()</code> 的第一个参数总是这个 Selector。Selector可以同时监控注册到其上的多个 SelectableChannel 的IO状况，是非阻塞IO的核心。一个 Selector 有三个SelectionKey的集合：</p>
<ol>
<li>所有SelectionKey的集合：代表了注册在改Selector上的Channel，可以通过 keys() 获取该集合</li>
<li>所有选择的SelectionKey集合：代表了所有监测到的、需要进行IO处理的Channel，调用select()方法会检测哪些Channel需要IO处理，然后通过 selectedKeys()方法可以获取该集合</li>
<li>被取消的SelectionKey的集合：代表了所有被取消了注册关系的Channel，程序通常不需要直接访问该集合。<br>同时，Selector 还提供了系列和 select() 相关的方法：</li>
</ol>
<ul>
<li>int select(): 监控检测所有注册的Channel，将那些需要进行IO处理的Channel所对应的 SelectionKey 添加到所有选择的SelectionKey集合中，返回需要IO处理的Channel的数量。如果没有需要IO处理的Channel，该方法将阻塞线程</li>
<li>int select(long timeout): 可以设置超时时长的select</li>
<li>int selectNow(): 立即返回的select，不会阻塞线程</li>
<li>Selector wakeup(): 使一个未返回的 select() 方法立即返回。</li>
</ul>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>SelectionKey代表的是 SelectableChannel 和 Selector 之间的注册关系。通过它可以或得对应的 SelectableChannel 和 Selector:</p>
<ul>
<li>Selector selector(): 获取 Selector</li>
<li>SelectableChannel channel(): 获取 SelectableChannel</li>
</ul>
<p>所以，下一步是将新打开的 <code>ServerSocketChannel</code> 注册到 <code>Selector</code> 上。为此我们使用 <code>SelectableChannel.register()</code> 方法，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</span><br></pre></td></tr></table></figure></p>
<p><code>register()</code> 的第一个参数总是这个 <code>Selector</code> 。第二个参数是 <code>OP_ACCEPT</code> ，这里它指定我们想要监听 accept 事件，也就是在新的连接建立时所发生的事件。这是适用于 <code>ServerSocketChannel</code> 的唯一事件类型。<br>请注意对 <code>register()</code> 的调用的返回值。 <code>SelectionKey</code> 代表这个通道在此 <code>Selector</code> 上的这个注册。当某个 <code>Selector</code> 通知您某个传入事件时，它是通过提供对应于该事件的 <code>SelectionKey</code> 来进行的。<code>SelectionKey</code> 还可以用于取消通道的注册。</p>
<h3 id="内部循环"><a href="#内部循环" class="headerlink" title="内部循环"></a>内部循环</h3><p>现在已经注册了我们对一些 I/O 事件的兴趣，下面将进入主循环。使用 <code>Selector</code> 的几乎每个程序都像下面这样使用内部循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int num = selector.select();</span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator it = selectedKeys.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">     SelectionKey key = (SelectionKey)it.next();</span><br><span class="line">     // ... deal with I/O event ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，我们调用 <code>Selector</code> 的 <code>select()</code> 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， <code>select()</code> 方法将返回所发生的事件的数量。</p>
<p>接下来，我们调用 <code>Selector</code> 的 <code>selectedKeys()</code> 方法，它返回发生了事件的 <code>SelectionKey</code> 对象的一个集合 。</p>
<p>我们通过迭代 <code>SelectionKeys</code> 并依次处理每个 <code>SelectionKey</code> 来处理事件。对于每一个 <code>SelectionKey</code> ，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p>
<h3 id="监听新连接"><a href="#监听新连接" class="headerlink" title="监听新连接"></a>监听新连接</h3><p>程序执行到这里，我们仅注册了 <code>ServerSocketChannel</code> ，并且仅注册它们“接收”事件。为确认这一点，我们对 SelectionKey 调用 <code>readyOps()</code> 方法，并检查发生了什么类型的事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</span><br><span class="line">     == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line">     // Accept the new connection</span><br><span class="line">     // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以肯定地说， <code>readOps()</code> 方法告诉我们该事件是新的连接。</p>
<h3 id="接受新的连接"><a href="#接受新的连接" class="headerlink" title="接受新的连接"></a>接受新的连接</h3><p>因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 accept() 操作会阻塞：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</span><br><span class="line">SocketChannel sc = ssc.accept();</span><br></pre></td></tr></table></figure></p>
<p>下一步是将新连接的 SocketChannel 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 SocketChannel 注册到 Selector上，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.configureBlocking( false );</span><br><span class="line">SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );</span><br></pre></td></tr></table></figure></p>
<p>注意我们使用 register() 的 OP_READ 参数，将 SocketChannel 注册用于 <strong>读取</strong> 而不是 <strong>接受</strong> 新连接。</p>
<h3 id="删除处理过的-SelectionKey"><a href="#删除处理过的-SelectionKey" class="headerlink" title="删除处理过的 SelectionKey"></a>删除处理过的 SelectionKey</h3><p>在处理 SelectionKey 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的 <code>remove()</code> 方法来删除处理过的 SelectionKey：</p>
<pre><code>it.remove();
</code></pre><p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的 I/O 事件)了。</p>
<h3 id="处理传入的-I-O-数据"><a href="#处理传入的-I-O-数据" class="headerlink" title="处理传入的 I/O 数据"></a>处理传入的 I/O 数据</h3><p>当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 Selector.select()，并返回一个或者多个 I/O 事件。这一次， SelectionKey 将被标记为 OP_READ 事件，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ((key.readyOps() &amp; SelectionKey.OP_READ)</span><br><span class="line">     == SelectionKey.OP_READ) &#123;</span><br><span class="line">     // Read the data</span><br><span class="line">     SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">     // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与以前一样，我们取得发生 I/O 事件的通道并处理它。在本例中，由于这是一个 echo server，我们只希望从套接字中读取数据并马上将它发送回去。</p>
<h3 id="回到主循环"><a href="#回到主循环" class="headerlink" title="回到主循环"></a>回到主循环</h3><p>每次返回主循环，我们都要调用 select 的 Selector()方法，并取得一组 SelectionKey。每个键代表一个 I/O 事件。我们处理事件，从选定的键集中删除 SelectionKey，然后返回主循环的顶部。</p>
<p>在现实的应用程序中，您需要通过将通道从 Selector 中删除来处理关闭的通道。而且您可能要使用多个线程。创建一个线程池来负责 I/O 事件处理中的耗时部分会更有意义。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/java/jvm/java基础-运行时数据区域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/java/jvm/java基础-运行时数据区域/" itemprop="url">java基础-JVM数据区域及参数设置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-04T22:08:24+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/pics/jvm运行时数据区.png" alt="JVM运行时数据区" width="60%" height="60%"></p>
<p>JVM主要可以分为两大部分：</p>
<ol>
<li>各个线程独享的内存区域<ol>
<li>PC程序计数器</li>
<li>JVM栈</li>
<li>本地方法栈</li>
</ol>
</li>
<li>线程间共享的内存<ol>
<li>堆</li>
<li>方法区（运行时常量池是方法区的一部分）</li>
</ol>
</li>
</ol>
<h3 id="PC程序计数器"><a href="#PC程序计数器" class="headerlink" title="PC程序计数器"></a>PC程序计数器</h3><p>PC是一块较小的内存区域，用来指示当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些高效的方式去实现），字节码解释器工作时就是改变这个计数器的值来选取下一条需要执行的字节码指令，需要靠计数器来实现分支、跳转、循环、异常处理、线程恢复等基础功能。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</p>
<p>每个线程都有独立的程序计数器，各个线程之间的PC互不影响，是一块线程的私有内存。PC计数器是 JVM 规范中唯一没有规定任何 OOM 异常的内存区域。</p>
<h3 id="JVM-栈"><a href="#JVM-栈" class="headerlink" title="JVM 栈"></a>JVM 栈</h3><p>栈也是线程私有的数据区，它的生命周期与线程相同。JVM 栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个虚拟机栈用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法调用直至执行完成的过程，对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>此内存区域存在两种内存异常： StackOverFlow 异常和 OOM 异常。栈深度大于 JVM 允许的最大深度时，抛出 StackOverFlow 异常。 如果 JVM 支持动态扩展，如果扩展时无法申请到足够内存，将抛出 OOM 异常。</p>
<p><code>-Xss</code> :设置栈内存大小， <code>-Xss1M</code></p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与 JVM 栈一样，只是本地方法栈为 Native 方法服务。本地方法区也会抛出 StackOverFlow 异常和 OOM 异常。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>对于大多数应用来说， Java 堆是 JVM 管理的内存中最大的一块，是被所有线程共享的一块内存区域，在 JVM 启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java 堆物理上可以是不连续的，只要逻辑上连续即可。 </p>
<p>从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。</p>
<p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p>
<p>Java 堆可以是固定大小的，也可以是可扩展的。当前主流虚拟机都是按照可扩展来实现的，如果堆中没有可用内存来完成对象分配，且堆也无法扩展时，将会抛出 OOM 异常。</p>
<p><code>-Xms</code> :设置堆内存最小值，<code>-Xms512m</code><br><code>-Xmx</code> :设置堆内存最大值，<code>-Xmx1g</code><br><code>-XX:+HeapDumpOnOutOfMemoryError</code> :异常时 Dump 出当前内存堆转储快照。<br><code>jhat -port 7401 -J-Xmx4G dump.hprof</code>: 使用 jhat 分析 Dump 出来的转储快照。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、 JIT 编译后代码等数据。 JVM 规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的物理内存外和可以选择固定大小或可扩展外，还可以不实现垃圾收集。此区域的的内存回收目标主要是针对常量池的回收和类的卸载。</p>
<p>HotSpot 虚拟机中，之前将此区域实现为永久代，到了JDK8，已经移除了永久代的概念，采用元数据区来实现。</p>
<p>方法区无法分配内存时，也会抛出 OOM 异常。</p>
<p>JDK1.6 及之前的版本：<br><code>-XX:PermSize</code> :设置永久代最小值，<code>-XX: PermSize=128m</code><br><code>-XX:MaxPermSize</code> :设置永久代最大值，<code>-XX:MaxPermSize=512m</code></p>
<p>JDk1.8之后：<br><code>-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m</code></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。 Java 的 Class 文件中除了有类的版本、字段、方法、接口等信息外，还有一项就是常量池，用于存放编译期生成的各种字面常量和符号引用，这部分内容在类加载后进入方法区的运行时常量池存放。</p>
<p>JVM 规范堆 Class 文件的每一部分（也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，JVM规范没有做任何细节的要求，不同的提供商实现的 JVM 可按照自己的需要来实现这个内存区域。一般来说，除了保存 Class 文件中描述的<strong>符号引用</strong>之外，还会把翻译出来的<strong>直接引用</strong>也存储在运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性， Java 语言不要求常量一定只有编译期才能产生，也就是并并非预置入 Class 文件中的常量池内容才能进入运行时常量池，运行期间也能将新的常量放入池中，使用较多的就是 String 的 <code>intern()</code> 方法。</p>
<p>运行时常量池作为方法区的一部分，也收到方法区内存的限制，当无法申请到内存时会抛出 OOM 异常。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。但是这部分内存也频繁地被使用，而且也可能导致 OOM 。</p>
<p>JDK 1.4 中引入了 NIO 类，引入了一种基于通道与缓冲区的 I/O 方式，它可以使用 Native 函数库直接在<strong>堆外分配内存</strong>，然后通过存储在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作，避免了 Java 堆和 Native 堆中来回复制数据的开销。</p>
<p>显然，直接内存不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存大小及处理器寻址空间的限制。配置虚拟机参数时，不能忽略直接内存，此区域也可能会导致 OOM 异常。</p>
<p><code>-XX:MaxDirectmemorySize</code> :设置直接内存容量，如果不指定，默认64M。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/java/IO/java基础-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/java/IO/java基础-IO/" itemprop="url">java基础-IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-05T22:30:29+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p><code>File</code> 类看上去是指代文件，其实它既能代表一个特定文件，也能代表一个目录。</p>
<h3 id="目录列表"><a href="#目录列表" class="headerlink" title="目录列表"></a>目录列表</h3><ul>
<li><code>String[] list()</code>: 返回所有文件名的字符串数组</li>
<li><code>String[] list(FileNameFilter filter)</code>: 返回 <code>FileNameFilter</code> 过滤后的字符串数组</li>
<li><code>File[] listFiles()</code>: 返回所有的文件数组</li>
<li><code>File[] listFiles(FilenameFilter filter)</code>: 返回 <code>FilenameFilter</code> 过滤后的文件数组</li>
</ul>
<p>假如 <code>File</code> 指代的是一个目录，那么就可以使用 <code>list()</code> 方法获取目录下的文件列表，如果想获取所有文件列表，使用不带参数的 <code>list()</code> 的方法即可；如果想获得一个受限列表，那么就要使用“目录过滤器”了。 <code>FilenameFilter</code> 接口的 <code>boolean accept(File dir,String name)</code> 返回 <code>true</code> 的才会返回到数组中。 <code>listFiles</code> 同理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class FileList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;****</span><br><span class="line">        File f = new File(&quot;/usr/local/etc&quot;);</span><br><span class="line">        File[] allFiles = f.listFiles();</span><br><span class="line">        File[] filterFiles = f.listFiles((dir,name)-&gt;&#123;</span><br><span class="line">            return name.contains(&quot;a&quot;); </span><br><span class="line">        &#125;);</span><br><span class="line">        for (File allFile : allFiles) &#123;</span><br><span class="line">            System.out.print(allFile.getName()+&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (File filterFile : filterFiles) &#123;</span><br><span class="line">            System.out.print(filterFile.getName()+&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        String[] allNames = f.list();</span><br><span class="line">        String[] filterNames = f.list((dir,name)-&gt; &#123;</span><br><span class="line">                return name.contains(&quot;.&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        for (String file : allNames) &#123;</span><br><span class="line">            System.out.print(file+&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (String file : filterNames) &#123;</span><br><span class="line">            System.out.print(file+&quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目录-文件的检查及创建"><a href="#目录-文件的检查及创建" class="headerlink" title="目录/文件的检查及创建"></a>目录/文件的检查及创建</h3><p>可以获取文件/目录相关的信息：</p>
<ul>
<li><code>String getAbsolutePath()</code> :获取绝对路径</li>
<li><code>String getName()</code> :获取名字</li>
<li><code>File getParent()</code> :获取父目录</li>
<li><code>long length()</code> :获取目录/文件大小</li>
<li><code>long lastModified()</code> :获取最后修改时间</li>
<li><code>boolean canExecute()</code> :是否可执行</li>
<li><code>boolean canRead()</code> :是否可读</li>
<li><code>boolean canWrite()</code> :是否可写</li>
<li><code>boolean createNewFile()</code> :创建新文件当 <code>File</code> 代表一个文件时</li>
<li><code>boolean mkdir()</code> :创建新目录当 <code>File</code> 代表一个目录时</li>
</ul>
<h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><p>流按照不同的方式可以分为如下几类：<br>输入流：从外设/网络等流入程序内存的流，只能从其中读数据，不能写<br>输出流：从程序内存输出到外设/网络等的流，只能向其中写数据，不能读<br>节点流：可以直接从/向一个特定的IO设备（磁盘、网络等）读写数据的流，称为节点流，也称为低级流<br>处理流：对于一个已经存在的流进行连接或封装，通过封装后流来实现数据读写的功能，也称为高级流；关闭最上层的处理流，系统会自动关闭该处理流包装的节点流<br><img src="/pics/stream-2.png" width="50%/"><br>字节流/字符流：两种流操作的数据单元不同，字节流按字节处理数据，而字符流按16位字符处理数据<br><img src="/pics/stream-1.png" width="60%/"></p>
<h3 id="输入输出流体系"><a href="#输入输出流体系" class="headerlink" title="输入输出流体系"></a>输入输出流体系</h3><p><img src="/pics/stream-framework.png" alt="stream-framework"><br>粗体标出的类代表节点流，必须直接与指定的物理节点关联；斜体标出的类代表抽象基类，无法直接创建实例。<br>访问数组和字符串的流看似没什么用，因为数组和字符串本来就可以在内存中直接访问，为啥还要使用流来读写呢？当你的API接口只接受IO流参数，但是你又想用字符串或数组去调用这个API时，就可以使用这种流来调用。</p>
<h4 id="InputStream-和-Reader"><a href="#InputStream-和-Reader" class="headerlink" title="InputStream 和 Reader"></a>InputStream 和 Reader</h4><p>InputStream/Reader 里包含以下三个读方法：  </p>
<ul>
<li><code>int read()</code>: 从输入流中读取一个字节，返回读取到的字节数据</li>
<li><code>int read(byte[]/char[] b)</code>: 从输入流中读取数据到字节/字符数组b中，最多读取b.length个字节，返回实际读取的字节/字符数</li>
<li><code>int read(byte[] b, int off, int len)</code>: 从输入流中最多读取len个字节/字符存入字节/字符数组b中，从off位置开始存放，返回实际读取的字节/字符数<br>除此之外，它们还支持如下几个方法来移动记录指针：</li>
<li><code>boolean markSupported()</code>: 判断流是否支持记录标记</li>
<li><code>synchronized void mark(int readlimit)</code>: 在记录指针（读取位置的记录，读取时会从这个位置开始读）当前位置记录一个标记</li>
<li><code>synchronized void reset()</code>: 将记录指针重新定位到上一个记录标记的位置</li>
<li><code>long skip(long n)</code>: 将记录指针向前移动 n 个字节/字符</li>
</ul>
<h4 id="OutputStream-和-Writer"><a href="#OutputStream-和-Writer" class="headerlink" title="OutputStream 和 Writer"></a>OutputStream 和 Writer</h4><p>OutputStream/Writer 也提供如下三个写方法：</p>
<ul>
<li><code>void write(int b)</code>: 将字节/字符 b写入到流中</li>
<li><code>void write(byte[]/char[] buf)</code>: 将字节/字符数组buf中的数据写入输出流中</li>
<li><code>void write(byte[]/char[] buf, int off, int len)</code>: 将字节/字符数组buf中从off位置开始长度为len的数据写入输出流中<br>因为字符流直接以字符为操作单位，因此 Writer 也支持直接写字符串：</li>
<li><code>void write(String str)</code>: 将字符串 str 中的字符写入输出流中</li>
<li><code>void write(String str,int off, int len)</code>: 将字符串 str 中从 off 位置开始，长度为len的字符写入输出流中</li>
</ul>
<h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>Java的标准输入/输出分别通过 <code>System.in/System.out</code> 来代表，默认情况下分别代表键盘和显示器，当程序从 System.in 读数据时，实际上是从键盘读取输入；当程序通过 System.out 来输出数据时，数据会显示在屏幕上。<br>System类还提供了三个重定向标准输入/输出的方法：</p>
<ul>
<li><code>static void setIn(InputStream in)</code>:  重定向标准输入流</li>
<li><code>static void setOut(PrintStream out)</code>: 重定向标准输出流</li>
<li><code>static void setErr(PrintStream err)</code>: 重定向标准错误输出流</li>
</ul>
<h4 id="JVM读取其它进程的数据"><a href="#JVM读取其它进程的数据" class="headerlink" title="JVM读取其它进程的数据"></a>JVM读取其它进程的数据</h4><p>我们知道使用 <code>Runtime</code> 类的 <code>Process exec(String command)</code> 方法可以启动一个进程，并返沪一个 Process 对象， 该 Process 对象代表由 Java 启动的子进程，Process 提供了三个方法用于程序和其子进程进行通信：</p>
<ul>
<li><code>OutputStream getOutputStream()</code>: 获取子进程的输出流，实际对应子进程的输入流，对本进程来说是输出流，用于向子进程写数据</li>
<li><code>InputStream getInputStream()</code>: 获取子进程的输入流，实际上对应子进程的输出流，对本进程来说是输入流，用于读取子进程的输出数据</li>
<li><code>InputStream getErrorStream()</code>: 获取子进程的错误输入流，实际上对应子进程的错误输出流，对本进程来说是输入流，用于读取子进程的错误输出数据</li>
</ul>
<h4 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h4><p><code>RandomAccessFile</code> 功能非常强大，能够支持随机的读写数据，就是能够随机的从指定位置开始读/写数据，也可以跳过某些数据的读写。<code>RandomAccessFile</code>提供两种构造方法来生成对象：</p>
<ol>
<li>RandomAccessFile(File file, String mode)</li>
<li>RandomAccessFile(String name, String mode)<br>mode 参数指定 RandomAccessFile 的访问模式，该参数有如下四个值：</li>
</ol>
<ul>
<li>“r”: 以只读方式打开指定文件</li>
<li>“rw”: 以读写方式打开指定文件，如果文件不存在，则尝试创建文件</li>
<li>“rws”: 以读写方式打开指定文件，相对于 “rw”模式，还要求对文件内容或元数据的每个更新都同步写入到底层存储设备。</li>
<li>“rwd”: 以读写方式打开指定文件，相对于 “rw”模式，还要求对文件内容的每个更新都同步写入到底层存储设备。<br>打开一个 <code>RandomAccessFile</code> 对象后，可以使用下述两个方法来操纵文件记录指针：</li>
<li><code>long getFilePointer()</code>: 获取文件记录指针的位置</li>
<li><code>void seek(long pos)</code>: 将文件记录指针定位到指定的 pos 位置。<br>RandomAccessFile 还包含类似于了 InputStream/OutputStream 中的三种 read()/write() 方法，用法是完全一样的，另外还包含了系列方便的 readXXX 和 writeXXX 方法。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/17/springboot/jackson使用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/17/springboot/jackson使用总结/" itemprop="url">jackson 使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-17T20:43:48+08:00">
                2020-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="序列化相关的注解"><a href="#序列化相关的注解" class="headerlink" title="序列化相关的注解"></a>序列化相关的注解</h3><ol>
<li><p>@JsonAnyGetter<br> 如果 POJO 中有个 Map 类型的字段，这个注解可以使 Map 中的 key-value 直接在序列化后的 JSON 字段中，假如 POJO 如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ExtendableBean &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    private Map&lt;String, String&gt; properties;</span><br><span class="line"></span><br><span class="line">    @JsonAnyGetter</span><br><span class="line">    public Map&lt;String, String&gt; getProperties() &#123;</span><br><span class="line">        return properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 则序列化后的 JOSN ：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;test&quot;,</span><br><span class="line">    &quot;attr2&quot;:&quot;val2&quot;,</span><br><span class="line">    &quot;attr1&quot;:&quot;val1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果不使用该注解，则</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;My bean&quot;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;attr2&quot;: &quot;val2&quot;,</span><br><span class="line">        &quot;attr1&quot;: &quot;val1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@JsonGetter<br> 默认情况下，序列化时， jackson 使用 getter/setter 方法获取字段值，该注解用来标注一个方法，当序列化时，标注了该注解的方法会被 jackson 调用来获取 POJO 对象某个字段的值。假设上述改一下上边的 ExtendableBean:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ExtendableBean &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    private Map&lt;String, String&gt; properties;</span><br><span class="line"></span><br><span class="line">    @JsonAnyGetter</span><br><span class="line">    public Map&lt;String, String&gt; getProperties() &#123;</span><br><span class="line">        return properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @JsonGetter(&quot;name&quot;)</span><br><span class="line">    public String getMyName()&#123;</span><br><span class="line">        return name + &quot;my&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 则序列化的结果为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;testmy&quot;,</span><br><span class="line">    &quot;attr2&quot;:&quot;val2&quot;,</span><br><span class="line">    &quot;attr1&quot;:&quot;val1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@JsonPropertyOrder<br> 该注解用来指定序列化时字段的顺序。如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@JsonPropertyOrder(&#123;&quot;id&quot;,&quot;name&quot;&#125;)</span><br><span class="line">public class ExtendableBean &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    private String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 则序列化后的 JSON 就会是这样：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:&quot;123&quot;,</span><br><span class="line">    &quot;name&quot;:&quot;test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@JsonSerialize<br> 当序列化时（POJO-&gt;JSON）自定义一个序列化器来序列化指定的字段。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class EventWithSerializer &#123;</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    @JsonSerialize(using = CustomDateSerializer.class)</span><br><span class="line">    public Date eventDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CustomDateSerializer extends StdSerializer&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat formatter </span><br><span class="line">    = new SimpleDateFormat(&quot;dd-MM-yyyy hh:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    public CustomDateSerializer() &#123; </span><br><span class="line">        this(null); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public CustomDateSerializer(Class&lt;Date&gt; t) &#123;</span><br><span class="line">        super(t); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void serialize(</span><br><span class="line">    Date value, JsonGenerator gen, SerializerProvider arg2) </span><br><span class="line">    throws IOException, JsonProcessingException &#123;</span><br><span class="line">        gen.writeString(formatter.format(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@JsonDeserialize<br> 当反序列化时（JSON-&gt;POJO），自定义一个反序列化器来反序列化指定的字段值。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class EventWithSerializer &#123;</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    @JsonDeserialize(using = CustomDateDeserializer.class)</span><br><span class="line">    public Date eventDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class CustomDateDeserializer</span><br><span class="line">extends StdDeserializer&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static SimpleDateFormat formatter</span><br><span class="line">    = new SimpleDateFormat(&quot;dd-MM-yyyy hh:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    public CustomDateDeserializer() &#123; </span><br><span class="line">        this(null); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public CustomDateDeserializer(Class&lt;?&gt; vc) &#123; </span><br><span class="line">        super(vc); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Date deserialize(</span><br><span class="line">    JsonParser jsonparser, DeserializationContext context) </span><br><span class="line">    throws IOException &#123;</span><br><span class="line">        </span><br><span class="line">        String date = jsonparser.getText();</span><br><span class="line">        try &#123;</span><br><span class="line">            return formatter.parse(date);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@JsonIgnoreProperties<br> 该注解是一个类注解。当我们在序列化或反序列化时想要忽略某些字段时，可以使用该注解。与此类似的有一个 <code>@JsonIgnore</code> 注解，该注解用在字段上，与 <code>JsonIgnoreProperties</code> 作用相同。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@JsonIgnoreProperties(&#123; &quot;id&quot; &#125;)</span><br><span class="line">public class BeanWithIgnore &#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>当我们反序列化时，只想映射 JSON 中的部分字段而忽略掉 POJO 中没有定义的字段时，可以使用 @JsonIgnoreProperties(ignoreUnknown = true)</strong></p>
</li>
<li><p>@JsonProperty<br> 该注解用来申明字段在 JSON 中对应的名字。</p>
</li>
<li>@JsonFormat<br> 当字段的类型是 Date/Time 类型时，用来指定字符串的格式。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class EventWithFormat &#123;</span><br><span class="line">public String name;</span><br><span class="line"> </span><br><span class="line">@JsonFormat(</span><br><span class="line">  shape = JsonFormat.Shape.STRING,</span><br><span class="line">  pattern = &quot;dd-MM-yyyy hh:mm:ss&quot;)</span><br><span class="line">public Date eventDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="常见设置"><a href="#常见设置" class="headerlink" title="常见设置"></a>常见设置</h3><ol>
<li><p>序列化的时候忽略 NULL ：</p>
<ol>
<li><p>在类上标注 @JsonInclude(Include.NON_NULL)，忽略类中所有 NULL 字段：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JsonInclude(Include.NON_NULL)</span><br><span class="line">public class MyDto &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在要忽略的某个字段上标注  @JsonInclude(Include.NON_NULL)</li>
<li>设置 ObjectMapper：<br>mapper.setSerializationInclusion(Include.NON_NULL）</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/TCP-IP/https协议原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/TCP-IP/https协议原理/" itemprop="url">https及java支持</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-06T19:44:30+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络协议/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="https协议原理"><a href="#https协议原理" class="headerlink" title="https协议原理"></a>https协议原理</h3><p>思考一下通信过程应该要处理的问题：</p>
<ol>
<li>网络环境下，假设A与B通信，要保证通信内容安全，必须使用加密算法加密，出于效率考虑（非对称加密比较复杂，计算量大，每次传输都使用的话，效率低）一般使用对称加密算法，双方用同一秘钥加解密。</li>
<li>在web模型中，服务器与N个浏览器客户端通信，如果使用相同的秘钥，则相当于未加密，必须为不同的客户端使用不同的秘钥。所以每次通信的第一步是协商出一个安全的秘钥。</li>
<li>客户端如果直接将秘钥发送给服务器，告诉服务器使用这个秘钥进行加密。如果发送过程被截取，则秘钥会泄露。</li>
<li>所以，发送秘钥时，需要使用非对称加密算法，即用服务器端的公钥对秘钥加密，只有服务器端的私钥才可解密。即使被截获也无法解密对称秘钥。</li>
<li>那么客户端如何获取服务端的公钥呢？</li>
<li>客户端发起第一次请求的时候，服务器端可以下发公钥，因为下发过程是未加密的，所以如果只是简单的下发公钥，有可能被中间人调包，即使用中间人的公钥替换服务器端公钥，客户端无法确认公钥是否可信。保证可信的方法一般是签名，即如果服务器使用私钥对报文进行签名，则客户端可以使用服务器的公钥进行验签。但是，此时下发的内容正是公钥，所以显然客户端还没有公钥。所以只能考虑使用第三方签名。</li>
<li>服务器向第三方申请一个数字证书：将公钥和相关信息提交到第三方机构，第三方机构使用私钥对服务器提供的公钥及其它信息进行证书制作：首先，针对服务器的网址、公钥、摘要算法及其它信息计算摘要，然后利用自身的私钥对摘要签名。</li>
<li>客户端保存了第三方机构的公钥(浏览器和操作系统会保留信任机构的公钥)，并信任这些公钥，这些公钥本身一般也是以证书的形式存在。</li>
<li>服务器可以下发数字证书，客户端使用第三方公钥对其验签。获取摘要后，使用相同的摘要算法计算摘要内容，然后比较计算出来的摘要和验签出来的摘要是否一致。如果一致说明这个证书是有效的数字证书，并且证书中的信息（服务器下发的公钥、服务器网址信息、摘要算法等）未经篡改。</li>
<li>客户端可以比较证书中网址信息是否是当前网站，如果不是，说明证书虽然有效，但是该网站并不能其就是其所声明的真实网站。说到底，证书的一个作用是证明你访问的网址是真实的网址而不是钓鱼网站。证书里边的网址是经过认证的，你访问的网址是否与证书的网址一致说明其是否是假冒网站。</li>
<li>假设某个不怀好意的中间人在同一家机构申请了一个证书，当然，此证书不会与服务器的证书一样，然后用这个证书替换了服务器下发的证书。那么客户端收到证书后，虽然能够解密验签通过，但是显然，证书中的网址显然不是服务器网址，所以客户端应该放弃这次通信。</li>
<li>综合起来看，数字证书的作用就是证明某人是真实的某人的作用：你想访问某个网站，但是你不能肯定这个网站就是真实的网站而不是钓鱼网站，那么如果有https，那么获取到证书后，证书中的内容就能证明该网站是不是真实的网站。并且，证书中包含了该网站的公钥。</li>
</ol>
<p>反过来说，我们访问一个网站的大致过程是这样的：</p>
<ol>
<li>客户端访问某个网站，首先获取其证书，使用第三方机构的公钥（一般以CA证书的形式存在）对证书进行验证，通过证书验证该网站是不是真实的网站。</li>
<li>如果是真实的网站，就用证书中的公钥发起秘钥协商过程。</li>
<li>协商好加密秘钥后，使用该秘钥进行通信。</li>
</ol>
<h3 id="nginx使用自签名证书配https"><a href="#nginx使用自签名证书配https" class="headerlink" title="nginx使用自签名证书配https"></a>nginx使用自签名证书配https</h3><p>我们使用xca工具来制作证书，先下载安装xca工具，地址是<a href="http://xca.hohnstaedt.de/。" target="_blank" rel="noopener">http://xca.hohnstaedt.de/。</a><br>首先要制作一张CA证书，然后用CA证书签发一张或多张证书，每张证书模拟每个网站下发的证书，里边存放的就是网站服务器端的公钥及网址等信息。制作每张证书的时候，都需要一对公私钥密码。下图是制作好的证书，其中一张是CA证书，用来签发其它证书：<br><img src="/pics/cert_generation.png"><br>然后，我们将CA证书和制作的证书分别导出来：<br><img src="/pics/cert_export.png"><br>上图中 ca_wang.crt 是CA证书，只包含公钥信息，后边需要将其安装到浏览器的信任根证书列表中，这样浏览器收到服务器下发的证书时，就能用CA证书验证其是否可被信任了（因为下发的证书是经过CA证书对应的私钥签名的）。<br>localhost_cert.crt 是CA签发的服务端证书，https通信时，服务端下发的就是这张证书。<br>locahost_keypair.pem 是 localhost_cert.crt 对应的私钥，配置 nginx 时会用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       443 ssl;</span><br><span class="line">       server_name  localhost;</span><br><span class="line"></span><br><span class="line">       ssl_certificate      C:\Users\BaIcy\Documents\xca\localhost_cert.crt;</span><br><span class="line">       ssl_certificate_key  C:\Users\BaIcy\Documents\xca\localhost_keypair.pem;</span><br><span class="line"></span><br><span class="line">       ssl_session_cache    shared:SSL:1m;</span><br><span class="line">       ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">       ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">       ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">       location / &#123;</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>nginx配置好后，将 ca_wang.crt 导入到 chrome 浏览器的信任根证书列表中：<br><img src="/pics/chrome_ca.png"><br>然后以https方式访问 localhost，就会发现是信任的网站了：<br><img src="/pics/chrome_https.png"></p>
<h3 id="java-对-Https-的支持"><a href="#java-对-Https-的支持" class="headerlink" title="java 对 Https 的支持"></a>java 对 Https 的支持</h3><p>与浏览器和操作系统类似，JRE的安装目录下也保存了一份默认可信的CA证书列表，一般在 hre/lib/security/cacerts文件中，使用JDK自带的 keytool 工具可以查看其中的内容，默认密码为： changeit.</p>
<ul>
<li><code>keytool -import -alias ca_wang -keystore cacerts -file ca_wang.crt</code>:从ca_wang.crt的文件中导入证书到cacerts的 TrustStore ，别名为 ca_wang</li>
<li><code>keytool -list -cacerts -alias ca_wang</code>:显示指定别名为 ca_wang 的 TrustStore 证书信息</li>
<li><code>keytool -delete -cacerts -alias ca_wang</code>:删除指定别名的的 keystore 条目</li>
<li><code>keytool -import -alias ca_wang -file C:\Users\BaIcy\Documents\xca\ca_wang.crt -keypass &quot;&quot; -keystore C:\Users\BaIcy\Documents\xca\ca_wang.jks -storepass test123</code>:将 crt 证书文件转换为 jks 的 keystore 文件</li>
</ul>
<p>Java 平台下，证书尝尝被存储为 keystore 文件中，上面的 cacerts 就是一个 keystore 文件， keystore 文件不仅可以存储数字证书，还可以存储秘钥，存储在 keystore 文件中的对象有三种： Certificate（证书）、PrivateKey（私钥） 和 SecretKey（对称加密秘钥）。</p>
<p>keystore 只是一种文件格式而已，实际上在 Java 的世界里 KeyStore 文件分为两种： keystore 和 truststore， keystore 保存私钥，用来解密或者签名； truststore 保存信任的证书列表，访问 https 时，对被访问者进行认证，确定它是可信任的。</p>
<p>Java 使用以下主要类和接口来支持安全传输：<br><img src="pics/jsse.jpg" width="80%" height="80%"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SSLContext context = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">context.init(null,null,null);</span><br><span class="line">URL url = new URL(&quot;https://localhost&quot;);</span><br><span class="line">HttpsURLConnection httpsURLConnection = (HttpsURLConnection) url.openConnection();</span><br><span class="line">/** 下边这句会抛出 PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 异常**/</span><br><span class="line">try&#123;</span><br><span class="line">    httpsURLConnection.getInputStream();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">String keyStoreFile = &quot;C:\\Users\\BaIcy\\Documents\\xca\\ca_wang.jks&quot;;</span><br><span class="line">String password = &quot;test123&quot;;</span><br><span class="line">KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">ks.load(new FileInputStream(keyStoreFile),password.toCharArray());</span><br><span class="line"></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">tmf.init(ks);</span><br><span class="line">SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">sslContext.init(null,tmf.getTrustManagers(),null);</span><br><span class="line">httpsURLConnection.setSSLSocketFactory(sslContext.getSocketFactory());</span><br><span class="line"></span><br><span class="line">InputStream ins = httpsURLConnection.getInputStream();</span><br><span class="line">while (ins.read() &gt; 0)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Coder_Wang</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">167</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coder_Wang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
