<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="学习笔记">
<meta name="keywords" content="java sql vue web python">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder_Wang&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Coder_Wang&#39;s blog">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coder_Wang&#39;s blog">
<meta name="twitter:description" content="学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/">





  <title>Coder_Wang's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coder_Wang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/13/spring/spring_ioc/spring ioc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/13/spring/spring_ioc/spring ioc/" itemprop="url">Spring IOC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-13T21:34:23+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/IOC/" itemprop="url" rel="index">
                    <span itemprop="name">IOC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Spring的IoC容器所起的作用就是它会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息），然后根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。<br>Spring的IoC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即容器启动阶段和Bean实例化阶段。<br><img src="/pics/ioc-phase.png" height="60%" width="60%"><br>Spring的IoC容器在实现的时候，充分运用了这两个实现阶段的不同特点，在每个阶段都加入了相应的容器扩展点，以便我们可以根据具体场景的需要加入自定义的扩展逻辑。</p>
<ol>
<li><p>容器启动阶段<br> 容器启动伊始，首先会通过某种途径加载 Configuration MetaData 。除了代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（ BeanDefinitionReader ）对加载的 Configuration MetaData 进行解析和分析，并将分析后的信息编组为相应的 BeanDefinition，最后把这些保存了bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器启动工作就完成了。总地来说，该阶段所做的工作可以认为是准备性的，重点更加侧重于对象管理信息的收集。当然，一些验证性或者辅助性的工作也可以在这个阶段完成。</p>
</li>
<li><p>Bean实例化阶段<br> 容器会首先检查所请求的对象之前是否已经存在。如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。当该对象装配完毕之后，容器会立即将其返回请求方使用。如果说第一阶段只是根据图纸装配生产线的话，那么第二阶段就是使用装配好的生产线来生产具体的产品了。</p>
</li>
</ol>
<h3 id="第一阶段的扩展点-BeanFactoryPostProcessor"><a href="#第一阶段的扩展点-BeanFactoryPostProcessor" class="headerlink" title="第一阶段的扩展点 BeanFactoryPostProcessor"></a>第一阶段的扩展点 BeanFactoryPostProcessor</h3><p>Spring提供了一种叫做 BeanFactoryPostProcessor 的容器扩展机制。该机制允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做相应的修改。这就相当于在容器实现的第一阶段最后加入一道工序，让我们对最终的 BeanDefinition 做一些额外的操作，比如修改其中bean定义的某些属性，为bean定义增加其他信息等。</p>
<p>org.springframework.beans.factory.config.PropertyPlaceholderConfigurer 和 org.springframework.beans.factory.config.PropertyOverrideConfigurer 是两个比较常用的 BeanFactoryPostProcessor。另外，为了处理配置文件中的数据类型与真正的业务对象所定义的数据类型转换， Spring还允许我们通过org.springframework.beans.factory.config.CustomEditorConfigurer 来注册自定义的 PropertyEditor 以补充容器中默认的 PropertyEditor 。</p>
<h3 id="第二阶段扩展-BeanPostProcessor"><a href="#第二阶段扩展-BeanPostProcessor" class="headerlink" title="第二阶段扩展 BeanPostProcessor"></a>第二阶段扩展 BeanPostProcessor</h3><p>在已经可以借助于 BeanFactoryPostProcessor 来干预 Spring 的第一个阶段启动之后，我们就可以开始探索下一个阶段，即bean实例化阶段的实现逻辑了。</p>
<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>容器启动之后，并不会马上就实例化相应的bean定义。我们知道，容器现在仅仅拥有所有对象的 BeanDefinition 来保存实例化阶段将要用的必要信息。只有当请求方通过 BeanFactory 的 getBean() 方法来请求某个对象实例的时候，才有可能触发Bean实例化阶段的活动。 BeanFactory 的 getBean()法可以被客户端对象显式调用，也可以在容器内部隐式地被调用。隐式调用有如下两种情况:</p>
<ul>
<li>对于BeanFactory来说，对象实例化默认采用延迟初始化。通常情况下，当对象A被请求而需要第一次实例化的时候，如果它所依赖的对象B之前同样没有被实例化，那么容器会先实例化对象A所依赖的对象。这时容器内部就会首先实例化对象B，以及对象 A依赖的其他还没有实例化的对象。这种情况是容器内部调用getBean()，对于本次请求的请求方是隐式的。</li>
<li>ApplicationContext启动之后会实例化所有的bean定义，这个特性在本书中已经多次提到。但ApplicationContext在实现的过程中依然遵循Spring容器实现流程的两个阶段，只不过它会在启动阶段的活动完成之后，紧接着调用注册到该容器的所有bean定义的实例化方法getBean()。这就是为什么当你得到ApplicationContext类型的容器引用时，容器内所有对象已经被全部实例化完成。不信你查一下类org.AbstractApplicationContext的refresh()方法。</li>
</ul>
<h5 id="BeanFactory中bean的生命周期"><a href="#BeanFactory中bean的生命周期" class="headerlink" title="BeanFactory中bean的生命周期"></a>BeanFactory中bean的生命周期</h5><p><img src="/pics/beanfactory-bean-lifecycle.png" alt="BeanFactory 中bean的生命周期"></p>
<p>BeanFactory 实例化一个 <code>bean</code> 的步骤：</p>
<p><img src="/pics/spring-bean.JPG" alt="BeanFactory 中bean的生命周期"></p>
<p>注意到：自定义的 <code>bean</code> 实例化时，会调用 <code>BeanPostProcessor</code>相关的方法，<code>BeanPostProcessor</code> 不一定是 <code>bean</code> 本身实现的接口，它是 Spring 容器提供的容器级别接口，所有实现 <code>BeanPostProcessor</code> 的类在注册到容器中后，都会在 <code>spring</code> 实例化某个<code>bean</code>的时候其作用。就是说，如果我们自定义了一个 <code>BeanPostProcessor</code> 的实现类并注册到容器中，则它会在<code>spring</code>实例化所有其它<code>bean</code>的时候起作用。</p>
<h5 id="ApplicationContext中bean的生命周期"><a href="#ApplicationContext中bean的生命周期" class="headerlink" title="ApplicationContext中bean的生命周期"></a>ApplicationContext中bean的生命周期</h5><p><img src="/pics/applicationContext-bean-lifecycle.png" alt="ApplicationContext 中bean的生命周期"></p>
<p>Bean 在应用上下文中的生命周期与在 BeanFactory 中的类似，实际上，应用上下文在初始化时，会向容器中注册一个 <code>ApplicationContextAwareProcessor</code> 类型的 <code>BeanPostProcessor</code> 实现类，并实现 <code>postProcessBeforeInitialization</code> 方法，这样的话，调用 <code>getBean</code>方法时， <code>ApplicationContextAwareProcessor</code> 就会生效， <code>postProcessBeforeInitialization</code> 判断如果 Bean 实现了 <code>EnvironmentAware</code> , <code>EmbeddedValueResolverAware</code> , <code>ResourceLoaderAware</code> , <code>ApplicationEventPublisherAware</code> , <code>MessageSourceAware</code> , <code>ApplicationContextAware</code> 接口，则会分别调用它们。</p>
<p>ApplicationContext 和 BeanFactory 的一个重大区别在于：前者会利用java反射机制自动识别出注册的 <code>BeanPostProcessor</code>, <code>BeanFactoryPostProcessor</code> , <code>InstantiationAwareBeanPostProcessor</code> ,并自动将它们注册到容器中；而后者需要手工调用 <code>addBeanPostProcessor</code> 方法注册它们。</p>
<p><code>ApplicationContext</code> 的 <code>refresh</code> 方法，会在 <code>ApplicationContext</code> 初始化时调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		// Prepare this context for refreshing.</span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		// 获取beanFactory，此时会解析加载xml中的beanDefinition，但是并没有注册 bean 对象</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">           // 注册一些 BeanPostProcessor bean，开始生成 bean</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">           // Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">           postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">           // 注册并调用BeanFactoryPostProcessor的postProcessBeanFactory方法</span><br><span class="line">           invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">           // 注册 BeanPostProcessor 类型的bean，自动实现 BeanPostProcessor 注册</span><br><span class="line">           registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">           // Initialize message source for this context.</span><br><span class="line">           initMessageSource();</span><br><span class="line"></span><br><span class="line">           // Initialize event multicaster for this context.</span><br><span class="line">           initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">           // Initialize other special beans in specific context subclasses.</span><br><span class="line">           onRefresh();</span><br><span class="line"></span><br><span class="line">           // Check for listener beans and register them.</span><br><span class="line">           registerListeners();</span><br><span class="line"></span><br><span class="line">           // Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">           finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">           // Last step: publish corresponding event.</span><br><span class="line">           finishRefresh();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>看看几个主要的方法：</p>
<ol>
<li><p><code>obtainFreshBeanFactory()</code> 方法 :</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	return beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	if (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">	beanFactory.setSerializationId(getId());</span><br><span class="line">	customizeBeanFactory(beanFactory);</span><br><span class="line">	//加载beanDefinition</span><br><span class="line">	loadBeanDefinitions(beanFactory);</span><br><span class="line">	synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">		this.beanFactory = beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该方法主要是实例化一个 <code>beanFactory</code>，并加载 bean 定义。</p>
</li>
<li><p><code>prepareBeanFactory</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	// Tell the internal bean factory to use the context&apos;s class loader etc.</span><br><span class="line">	beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">	beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">	beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"></span><br><span class="line">	// Configure the bean factory with context callbacks.</span><br><span class="line">	beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">	// BeanFactory interface not registered as resolvable type in a plain factory.</span><br><span class="line">	// MessageSource registered (and found for autowiring) as a bean.</span><br><span class="line">	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">	beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"></span><br><span class="line">	// Register early post-processor for detecting inner beans as ApplicationListeners.</span><br><span class="line">	beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"></span><br><span class="line">	// Detect a LoadTimeWeaver and prepare for weaving, if found.</span><br><span class="line">	if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		// Set a temporary ClassLoader for type matching.</span><br><span class="line">		beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Register default environment beans.</span><br><span class="line">	if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">	&#125;</span><br><span class="line">	if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>registerListeners</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   protected void registerListeners() &#123;</span><br><span class="line">	// Register statically specified listeners first.</span><br><span class="line">	for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">		getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">	// uninitialized to let post-processors apply to them!</span><br><span class="line">	String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);</span><br><span class="line">	for (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">		getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Publish early application events now that we finally have a multicaster...</span><br><span class="line">	Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;</span><br><span class="line">	this.earlyApplicationEvents = null;</span><br><span class="line">	if (earlyEventsToProcess != null) &#123;</span><br><span class="line">		for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">			getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/25/分布式/redis/Redis手册/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/25/分布式/redis/Redis手册/" itemprop="url">Redis 手册</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-25T21:07:35+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis是一种基于键值对（key-value）的NoSQL数据库，与很多键值对数据库不同的是，Redis中的值可以是由string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法组成，因此Redis可以满足很多的应用场景，而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常惊人。不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。除了上述功能以外，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。总之，如果在合适的场景使用好Redis，它就会像一把瑞士军刀一样所向披靡。</p>
<h3 id="Redis-Server-启动与连接"><a href="#Redis-Server-启动与连接" class="headerlink" title="Redis Server 启动与连接"></a>Redis Server 启动与连接</h3><p><img src="/pics/redis-exe.png" alt></p>
<ol>
<li>redis-server<ol>
<li>默认配置启动：<code># redis-server</code></li>
<li>指定配置文件启动: <code># redis-server /opt/redis/redis.conf</code></li>
</ol>
</li>
<li>运行时指定配置启动：<code># redis-server --configKey1 configValue1 --configKey2 configValue2</code></li>
</ol>
<p>Redis目录下都会有一个redis.conf配置文件，里面就是Redis的默认配置，通常来讲我们会在一台机器上启动多个Redis，并且将配置集中管理在指定目录下，而且配置不是完全手写的，而是将redis.conf作为模板进行修改。</p>
<p>   一些基础配置：</p>
<ul>
<li>port : 配置监听端口</li>
<li>logfile : 配置日志文件</li>
<li>dir : Redis 工作目录（存放持久化文件和日志文件）<ul>
<li>daemonize: 是否以守护进程的方式启动</li>
</ul>
</li>
</ul>
<ol>
<li><p>redis-cli</p>
<ul>
<li><code>redis-cli -h {host} -p {port} -a {password}</code> ：使用主机、端口和密码以交互式连接 redis 服务</li>
<li><code>redis-cli -h {host} -p {port} -a {password} {command}</code> ：使用主机、端口和密码以命令式连接 redis 服务并执行一条命令</li>
</ul>
</li>
<li><p>关闭 Redis 服务</p>
<ol>
<li><code>redis-cli shutdown</code>：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式。</li>
<li>shutdown还有一个参数，代表是否在关闭Redis前，生成持久化文件：<code>redis-cli shutdown nosave|save</code></li>
<li>除了可以通过shutdown命令关闭Redis服务以外，还可以通过kill进程号的方式关闭掉Redis，但是不要粗暴地使用kill-9强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况会造成AOF和复制丢失数据的情况。</li>
</ol>
</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li>配置命令<ol>
<li>查看所有配置： <code>config get *</code></li>
<li>查看指定配置：<code>config get XXX</code></li>
<li>设置config： <code>config set xxx xxx</code></li>
</ol>
</li>
<li>键通用命令<ol>
<li>查看所有的键： <code>keys *</code>，会遍历所有的键，谨慎使用。</li>
<li>键总数： <code>dbsize</code> ,不会遍历所有键，而是直接获取 Redis内置的键总数变量的值</li>
<li>检查键是否存在： <code>exists key</code>， 存在返回1，否则返回0</li>
<li>删除键： <code>del key1 key2 ...</code>, 返回成功删除键的个数</li>
<li>键过期： <code>expire key seconds</code> ,超过过期时间后，键会自动删除</li>
<li>键剩余过期时间： <code>ttl key</code>，返回大于等于0的整数，代表剩余过期时间；如果没有设置过期时间，返回-1；键不存在，返回-2</li>
<li>查看键对应的值的数据类型： <code>type key</code>，键不存在返回 none</li>
<li>键重命名： <code>rename key newkey</code>, 如果 newkey 已经存在，那么他的值将会被 key 的值覆盖</li>
<li><code>renamenx key newkey</code>： 只有 newkey 不存在时才会重命名成功，由于重命名键期间会执行del命令删除旧的键，如果键对应的值比较大，会存在阻塞Redis的可能性，这点不要忽视。</li>
<li>随机返回一个键： <code>randomkey</code></li>
</ol>
</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串类型是 Redis 最基础的类型，所有的键都是字符串类型。字符串的值实际可以是字符串、数字，甚至二进制（图片、音视频），但是大小最大不能超过512MB。<br><img src="/pics/redis-string.png" alt></p>
<ol>
<li><p>命令</p>
<ul>
<li><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code> : 设置值</li>
<li><code>setex</code> : 相当于上面的 ex 选项</li>
<li><code>setnx</code> ：相当于上面的 nx 选项，不存在时才设置成功。</li>
<li><code>mset key value [key value...]</code> : 批量设置值</li>
<li><code>get key</code> ：获取 key 对应的值，key 不存在则返回 nil。</li>
<li><code>mget key [key...]</code> : 批量获取值</li>
<li><code>incr key</code> ：计数自增,若值不是整数，返回错误；若值是整数，返回自增后的结果；键不存在，按照值为0自增，返回结果1。</li>
<li><code>decr key</code> ：计数递减1</li>
<li><code>incrby key increment</code> ：计数 + increment</li>
<li><code>decrby key decrement</code> ：计数 - decrement</li>
<li><code>incrbyfloat key increment</code> ：浮点数 + increment</li>
<li><code>append key value</code> ：向字符串尾部追加值</li>
<li><code>strlen value</code> ：获取字符串长度</li>
<li><code>getset key value</code> ：设置并返回原值</li>
<li><code>setrange key offeset value</code> ：设置指定位置的字符</li>
<li><code>getrange key start end</code> ：获取部分字符串<br><img src="/pics/redis-string-time.png" alt></li>
</ul>
</li>
<li><p>内部编码<br>字符串类型的内部编码有3种：</p>
<ul>
<li>int：8个字节的长整型。</li>
<li>embstr：小于等于39个字节的字符串。</li>
<li>raw：大于39个字节的字符串。</li>
</ul>
</li>
</ol>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p><img src="/pics/redis-hash.png" alt></p>
<ol>
<li><p>命令</p>
<ul>
<li>设置值 ：<code>hset key field value</code>,设置 field-value，成功返回1，否则返回0。还有 <code>hsetnx</code> 命令，只有field不存在时才会设置值</li>
<li>获取值 ：<code>hget key field</code>；如果 field 不存在，返回 nil</li>
<li>删除 field ：<code>hdel key field [field ...]</code>：可以删除一个或多个 field，返回成功删除的个数</li>
<li>计算field的个数 ：<code>hlen key</code></li>
<li>批量设置field-value ：<code>hmset key field value [field value ...]</code></li>
<li>批量获取field-value ：<code>hmget key field [field....]</code></li>
<li>判断 field 是否存在 ：<code>hexists key field</code>,存在返回1，否则返回0</li>
<li>获取所有 field ：<code>hkeys key</code></li>
<li>获取所有 value ：<code>hvals key</code></li>
<li>获取所有 field-value ：<code>hgetall key</code></li>
<li>指定 field 加1：<code>hincrby key field</code></li>
<li>同上，对浮点数操作 ：<code>hincrbyfloat key field</code></li>
<li>计算value的字符串长度 ：<code>hstrlen key field</code></li>
</ul>
<p><img src="/pics/redis-hash-time.png" alt></p>
</li>
</ol>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><h3 id="Jedis-简介"><a href="#Jedis-简介" class="headerlink" title="Jedis 简介"></a>Jedis 简介</h3><ol>
<li><p>直接构造操作 Jedis </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 1. 生成一个Jedis对象，这个对象负责和指定Redis实例进行通信</span><br><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"># 2. jedis执行set操作</span><br><span class="line">jedis.set(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line"># 3. jedis执行get操作, value=&quot;world&quot;</span><br><span class="line">String value = jedis.get(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<p>还有一个包含4个参数的构造函数是比较常用的：<br><code>Jedis(final String host, final int port, final int connectionTimeout, final int
soTimeout)</code></p>
<ul>
<li>host：Redis实例的所在机器的IP。</li>
<li>port：Redis实例的端口。</li>
<li>connectionTimeout：客户端连接超时。</li>
<li>soTimeout：客户端读写超时。</li>
</ul>
<p>Jedis 对 Redis 五种数据结构的操作示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 1.string</span><br><span class="line">// 输出结果：OK</span><br><span class="line">jedis.set(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">// 输出结果：world</span><br><span class="line">jedis.get(&quot;hello&quot;);</span><br><span class="line">// 输出结果：1</span><br><span class="line">jedis.incr(&quot;counter&quot;);</span><br><span class="line">// 2.hash</span><br><span class="line">jedis.hset(&quot;myhash&quot;, &quot;f1&quot;, &quot;v1&quot;);</span><br><span class="line">jedis.hset(&quot;myhash&quot;, &quot;f2&quot;, &quot;v2&quot;);</span><br><span class="line">// 输出结果：&#123;f1=v1, f2=v2&#125;</span><br><span class="line">jedis.hgetAll(&quot;myhash&quot;);</span><br><span class="line">// 3.list</span><br><span class="line">jedis.rpush(&quot;mylist&quot;, &quot;1&quot;);</span><br><span class="line">jedis.rpush(&quot;mylist&quot;, &quot;2&quot;);</span><br><span class="line">jedis.rpush(&quot;mylist&quot;, &quot;3&quot;);</span><br><span class="line">// 输出结果：[1, 2, 3]</span><br><span class="line">jedis.lrange(&quot;mylist&quot;, 0, -1);</span><br><span class="line">// 4.set</span><br><span class="line">jedis.sadd(&quot;myset&quot;, &quot;a&quot;);</span><br><span class="line">jedis.sadd(&quot;myset&quot;, &quot;b&quot;);</span><br><span class="line">jedis.sadd(&quot;myset&quot;, &quot;a&quot;);</span><br><span class="line">// 输出结果：[b, a]</span><br><span class="line">jedis.smembers(&quot;myset&quot;);</span><br><span class="line">// 5.zset</span><br><span class="line">jedis.zadd(&quot;myzset&quot;, 99, &quot;tom&quot;);</span><br><span class="line">jedis.zadd(&quot;myzset&quot;, 66, &quot;peter&quot;);</span><br><span class="line">jedis.zadd(&quot;myzset&quot;, 33, &quot;james&quot;);</span><br><span class="line">// 输出结果：[[[&quot;james&quot;],33.0], [[&quot;peter&quot;],66.0], [[&quot;tom&quot;],99.0]]</span><br><span class="line">jedis.zrangeWithScores(&quot;myzset&quot;, 0, -1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jedis 连接池<br>Jedis提供了JedisPool这个类作为对Jedis的连接池，同时使用了Apache的通用对象池工具common-pool作为资源的管理工具，下面是使用JedisPool操作Redis的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// common-pool连接池配置，这里使用默认配置，后面小节会介绍具体配置说明</span><br><span class="line">GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();</span><br><span class="line">// 初始化Jedis连接池</span><br><span class="line">JedisPool jedisPool = new JedisPool(poolConfig, &quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">//从连接池获取 Jedis 连接对象</span><br><span class="line">Jedis jedis = null;</span><br><span class="line">try &#123;</span><br><span class="line">   // 1. 从连接池获取jedis对象</span><br><span class="line">   jedis = jedisPool.getResource();</span><br><span class="line">   // 2. 执行操作</span><br><span class="line">   jedis.get(&quot;hello&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">   logger.error(e.getMessage(),e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   if (jedis != null) &#123;</span><br><span class="line">      // 如果使用JedisPool，close操作不是关闭连接，代表归还连接池</span><br><span class="line">      jedis.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下边是 Jedis 连接池的配置参数：<br><img src="/pics/jedispool-config.png" alt></p>
</li>
</ol>
<h3 id="Redis-持久化策略"><a href="#Redis-持久化策略" class="headerlink" title="Redis 持久化策略"></a>Redis 持久化策略</h3><p>Redis 支持两种持久化方式：</p>
<ul>
<li>RDB,Snapshoting (快照，默认方式)</li>
<li>Append-only file (AOF)</li>
</ul>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为 <code>dump.rdb</code> 。</p>
<h5 id="RDB-触发方式"><a href="#RDB-触发方式" class="headerlink" title="RDB 触发方式"></a>RDB 触发方式</h5><p>触发RDB持久化过程分为手动触发和自动触发。</p>
<ol>
<li>手动触发<br>手动触发分别对应 save 和 bgsave 命令：<ul>
<li>save 命令：对于单线程的 Redis 服务器，会阻塞服务器，直到 RDB 过程完成为止，对于内存中存放大量数据的实例会造成长时间阻塞，线上环境不建议使用。</li>
<li>bgsave 命令：Redis 进程执行 fork 操作创建子进程，RDB过程由子进程负责，完成后自动结束，阻塞只发生在 fork 阶段，一般时间很短。</li>
</ul>
</li>
<li>自动触发<br>下述场景会自动触发 RDB 持久化机制：<ol>
<li>通过配置设置了自动做快照持久化的方式。我们可以配置 redis 在 n 秒内如果超过 m 个 key 被修改就自动做快照（bgsave），下面是默认的快照保存配置：<ul>
<li>save 900 1 #900 秒内如果超过 1 个 key 被修改，则发起快照保存</li>
<li>save 300 10 #300 秒内容如超过 10 个 key 被修改，则发起快照保存</li>
<li>save 60 10000 #60 秒内容如超过 10000 个 key 被修改，则发起快照保存</li>
</ul>
</li>
<li>如果从节点执行全量复制操作，主节点会自动执行 bgsave 生成 RDB 文件发送给从节点</li>
<li>执行 debug reload 命令重新加载 Redis 时，也会自动触发</li>
<li>默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave 。</li>
</ol>
</li>
</ol>
<h5 id="RDB快照保存过程"><a href="#RDB快照保存过程" class="headerlink" title="RDB快照保存过程"></a>RDB快照保存过程</h5><ol>
<li>redis 调用 fork后,于是有了子进程和父进程。</li>
<li>父进程继续处理 client 请求，子进程负责将内存内容写入到临时文件。由于 os 的实时复制机制（ copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时 os 会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程地址空间内的数据是 fork 时刻整个数据库的一个快照。</li>
<li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。 client 也可以使用 <code>save</code> 或者 <code>bgsave</code> 命令通知 redis 做一次快照持久化。 save 操作是在主线程中保存快照的，由于 redis 是用一个主线程来处理所有 client 的请求，这种方式会阻塞所有client 请求。所以不推荐使用。另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步变更数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘 io 操作，可能会严重影响性能。</li>
</ol>
<h5 id="RDB文件的处理"><a href="#RDB文件的处理" class="headerlink" title="RDB文件的处理"></a>RDB文件的处理</h5><p>RDB文件保存在<code>dir</code>配置指定的目录下，文件名通过 <code>dbfilename</code> 配置指定。可以通过执行 <code>config set dir{newDir}</code> 和 <code>config set dbfilename {newFileName}</code> 运行期动态执行，当下次运行时RDB文件会保存到新目录。</p>
<p>Redis默认采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数 <code>config set rdbcompression {yes|no}</code> 动态修改。</p>
<p>如果Redis加载损坏的RDB文件时拒绝启动，可以使用Redis提供的 <code>redis-check-dump</code> 工具检测RDB文件并获取对应的错误报告。</p>
<h5 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h5><ol>
<li>RDB的优点：<ul>
<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</li>
<li>Redis加载RDB恢复数据远远快于AOF的方式。</li>
</ul>
</li>
<li>RDB的缺点：<ul>
<li>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li>
<li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</li>
</ul>
</li>
</ol>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>首先通过 <code>appendonly yes</code> 启用 aof 持久化方式。AOF 以独立日志的方式记录每次写命令。重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。<br>由于快照方式是在一定间隔时间做一次的，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用 aof 持久化方式。</p>
<h5 id="AOF-刷盘配置"><a href="#AOF-刷盘配置" class="headerlink" title="AOF  刷盘配置"></a>AOF  刷盘配置</h5><p>aof 比快照方式有更好的持久化性能，是由于在使用 aof 持久化方式时,redis 会将每一个收到的写命令都通过 write 函数追加到日志文件中(默认是 appendonly.aof)。当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于 os 会在内核中缓存（AOF缓冲区） write 做的修改，所以可能不是立即写到磁盘上。这样 aof 方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。有三种方式如下（默认是：每秒 fsync 一次）：</p>
<ol>
<li>appendfsync always //收到写命令写入aof_buf后调用 fsync 就立即写入磁盘，fsync 完成后线程返回。最慢，但是保证完全的持久化</li>
<li>appendfsync everysec //默认方式，，命令写入 aof_buf 后调用 write 操作，write 操作完成线程返回。fsync 同步文件由专门线程每秒调用一次，在性能和持久化方面做了很好的折中</li>
<li>appendfsync no //命令写入 aof_buf 后调用系统 write 操作，不对 AOF 文件做 fsync 同步，完全依赖 os，性能最好,持久化没保证</li>
</ol>
<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。AOF重写能压缩文件体积，有以下原因：</p>
<ul>
<li>多条命令合并。例如我们调用 incr test 命令 100 次，文件中必须保存全部的 100 条命令，其实有 99 条都是多余的。因为要恢复数据库的状态其实文件中保存一条 set test 100 就够了。</li>
<li>进程内已经超时的数据不会再写入文件</li>
<li>旧的AOF文件包含无效命令，如 del key1,hdel key2,srem keys,set alll, set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</li>
</ul>
<p>AOF重写降低了文件占用空间，而且也可以更快地被 Redis 加载。为了压缩 aof 的持久化文件， redis 提供了两种方式：</p>
<ol>
<li>手动触发：<code>bgrewriteaof</code> 命令。收到此命令 redis 将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。</li>
<li>自动触发：根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数确定自动触发时机。<ul>
<li>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。</li>
<li>auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。<br>自动触发时机=aof_current_size &gt; auto-aof-rewrite-minsize &amp;&amp;（aof_current_size-aof_base_size）/aof_base_size &gt;= auto-aof-rewritepercentage<br>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</li>
</ul>
</li>
</ol>
<h3 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h3><p>在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求。Redis也是如此，它为我们提供了复制功能，实现了相同数据的多个Redis副本。复制功能是高可用Redis的基础，后面章节的哨兵和集群都是在复制的基础上实现高可用的。</p>
<p>参与复制的Redis实例划分为主节点（master）和从节点（slave）。默认情况下，Redis都是主节点。每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。复制的数据流是单向的，只能由主节点复制到从节点。配置复制的方式有以下三种：</p>
<ol>
<li>在配置文件中加入 <code>slaveof {masterHost} {masterPort}</code> 随Redis启动生效。</li>
<li>在 redis-server 启动命令后加入 <code>--slaveof {masterHost} {masterPort}</code> 选项，启动后生效。</li>
<li>直接使用命令：<code>slaveof {masterHost} {masterPort}</code> ，命令执行后生效。</li>
</ol>
<p>主从节点复制成功建立后，可以使用 <code>info replication</code> 命令查看复制相关状态。</p>
<p>slaveof命令不但可以建立复制，还可以在从节点执行 <code>slaveof no one</code> 来断开与主节点复制关系。从节点断开复制后并不会抛弃原有数据，只是无法再获取主节点上的数据变化。把当前从节点对主节点的复制切换到另一个主节点，执行 <code>slaveof {newMasterIp} {newMasterPort}</code> 命令即可，切主后从节点会清空之前所有的数据，线上人工操作时小心 slaveof 在错误的节点上执行或者指向错误的主节点。</p>
<h3 id="Redis-分布式集群"><a href="#Redis-分布式集群" class="headerlink" title="Redis 分布式集群"></a>Redis 分布式集群</h3><p>Redis 支持一主多从的主从复制和集群分片的组合模式。</p>
<h4 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h4><p>Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念.</p>
<p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p>
<p>节点 A 包含 0 到 5500号哈希槽.<br>节点 B 包含5501 到 11000 号哈希槽.<br>节点 C 包含11001 到 16384号哈希槽.<br>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p>
<h4 id="Redis-集群的主从复制模型"><a href="#Redis-集群的主从复制模型" class="headerlink" title="Redis 集群的主从复制模型"></a>Redis 集群的主从复制模型</h4><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个主节点都会有N-1个复制品.</p>
<p><strong>在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</strong><br>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了</p>
<p>不过当B和B1 都失败后，集群是不可用的.</p>
<h4 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h4><ol>
<li><p>准备节点</p>
<p>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置 cluster-enabled yes，让Redis运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分别存放配置、数据和日志相关文件。把6个节点配置统一放在conf目录下，命名规则为 redis-port.conf ,集群相关配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">port 6379</span><br><span class="line">tcp-backlog 511</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;log/node-6379.log&quot;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">\# 节点超时时间，单位毫秒</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">\# 集群内部配置文件</span><br><span class="line">cluster-config-file &quot;nodes-6379.conf&quot;</span><br></pre></td></tr></table></figure>
<p>配置文件创建好后，分别启动6个实例：</p>
<p><code>redis-server conf\redis-6379.conf</code></p>
<p>实例启动后，可以用 redis-cli 连接到任意一台机器，然后执行：<code>cluster nodes</code>，会发现只有一台机器，因为此时6台实例之间并不知道对方。</p>
</li>
<li><p>节点握手</p>
<p>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命令：<code>cluster meet {ip} {port}</code></p>
<p>分别执行上述命令将6台机器加入到集群后，集群还不能正常工作，这时集群处于下线状态，所有的数据读写都被禁止，可以使用 <code>cluster info</code> 命令查看集群的当前状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cluster_state:fail</span><br><span class="line">cluster_slots_assigned:0</span><br><span class="line">cluster_slots_ok:0</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:0</span><br><span class="line">cluster_current_epoch:1</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:101</span><br><span class="line">cluster_stats_messages_meet_sent:5</span><br><span class="line">cluster_stats_messages_sent:106</span><br><span class="line">cluster_stats_messages_pong_received:106</span><br><span class="line">cluster_stats_messages_received:106</span><br></pre></td></tr></table></figure>
<p>因为此时还没有为各个节点分配槽，所以现在集群还是不可用的。</p>
</li>
<li><p>分配槽</p>
<p>Redis集群把所有的数据映射到16384个槽中。每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 <code>cluster addslots</code> 命令为节点分配槽。这里利用bash特性批量设置槽（slots），命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125;</span><br><span class="line">windows:FOR /L %i IN (0,1,5461) DO ( redis-cli.exe -h 127.0.0.1 -p 6379 CLUSTER ADDSLOTS %i )</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125;</span><br><span class="line">windows:FOR /L %i IN (5462,1,10922) DO ( redis-cli.exe -h 127.0.0.1 -p 6380 CLUSTER ADDSLOTS %i )</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;10923...16383&#125;</span><br><span class="line">windows:FOR /L %i IN (10923,1,16383) DO ( redis-cli.exe -h 127.0.0.1 -p 6381 CLUSTER ADDSLOTS %i )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   分配好槽以后，整个集群就是可用的了：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:1</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:10253</span><br><span class="line">cluster_stats_messages_sent:10253</span><br><span class="line">cluster_stats_messages_pong_received:10017</span><br><span class="line">cluster_stats_messages_received:10017</span><br></pre></td></tr></table></figure>
<p>   目前还有三个节点没有使用，作为一个完整的集群，每个负责处理槽的节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。集群模式下，Reids节点角色分为主节点和从节点。首次启动的节点和被分配槽的节点都是主节点，从节点负责复制主节点槽信息和相关的数据。使用<code>cluster replicate {nodeId}</code>命令让一个节点成为从节点。其中命令执行必须在对应的从节点上执行，<code>nodeId</code> 是要复制主节点的节点ID，命令如下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6382 cluster replicate a62b0061a541872d5c41e75efe987283aed167f6</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6383 cluster replicate a935e92708b09b6ad2f4ae10c433be519c4ecfd0</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6384 cluster replicate c94dde54d0f6aa124356d8a58c6be0a8c4ae8058</span><br></pre></td></tr></table></figure>
<p>   执行完后，就会发现此时的集群是3主3从的集群了：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">55ab7f5801001c9c71809a86b394f4fd029e87a2 127.0.0.1:6382@16382 slave a62b0061a541872d5c41e75efe987283aed167f6 0 1612365584000 4 connected</span><br><span class="line">a9f663f870d15f1d2c13665d49e4b8a877ce7467 127.0.0.1:6384@16384 slave c94dde54d0f6aa124356d8a58c6be0a8c4ae8058 0 1612365582000 5 connected</span><br><span class="line">def8275ed31a1542892ff3444153476484f3934c 127.0.0.1:6383@16383 slave a935e92708b09b6ad2f4ae10c433be519c4ecfd0 0 1612365584293 2 connected</span><br><span class="line">a62b0061a541872d5c41e75efe987283aed167f6 127.0.0.1:6379@16379 myself,master - 0 1612365583000 1 connected 0-5460</span><br><span class="line">c94dde54d0f6aa124356d8a58c6be0a8c4ae8058 127.0.0.1:6381@16381 master - 0 1612365585386 3 connected 10923-16383</span><br><span class="line">a935e92708b09b6ad2f4ae10c433be519c4ecfd0 127.0.0.1:6380@16380 master - 0 1612365583000 2 connected 5461-10922</span><br></pre></td></tr></table></figure>
<p>   使用 <code>redis-cli -c</code> 参数连接到集群中任意一台机器上，然后使用 <code>get/set</code> 命令存取数据，这样会用 key 计算 hash 然后算出对应的槽，客户端也会自动重定向到槽所对应的节点上存取数据。<br>   <code>redis-cli -c --cluster call 127.0.0.1:6379 keys *</code> 查看集群中的所有key</p>
<h4 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h4><p>Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p>
<p>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<p>客户端向主节点B写入一条命令.<br>主节点B向客户端回复命令状态.<br>主节点将写操作复制给他得从节点 B1, B2 和 B3.<br>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。<br>Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p>
<p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p>
<p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/11/nginx/nginx安装与启动及命令行参数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/nginx/nginx安装与启动及命令行参数/" itemprop="url">Nginx安装与启动及命令行参数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-11T11:02:00+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nginx/" itemprop="url" rel="index">
                    <span itemprop="name">nginx</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nginx安装与启动及命令行参数"><a href="#Nginx安装与启动及命令行参数" class="headerlink" title="Nginx安装与启动及命令行参数"></a>Nginx安装与启动及命令行参数</h1><hr>
<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><p>下载<a href="http://nginx.org" target="_blank" rel="noopener">nginx官网</a>下载安装即可。</p>
<h2 id="Nginx启动、停止及重新加载配置文件"><a href="#Nginx启动、停止及重新加载配置文件" class="headerlink" title="Nginx启动、停止及重新加载配置文件"></a>Nginx启动、停止及重新加载配置文件</h2><p>nginx有一个master线程和若干个工作线程，master线程主要用来读取配置文件、加载配置以及维护工作线程，工作线程才会真正的处理请求。</p>
<ol>
<li>安装目录下，直接双击nginx启动。或者，cmd模式切换到安装目录，运行nginx.exe文件。</li>
<li>一旦nginx启动后，可以使用以下命令：<blockquote>
<p>nginx -s signal</p>
</blockquote>
</li>
</ol>
<p>signal可以是以下参数：</p>
<ul>
<li><em>stop</em> — 快速停止</li>
<li><em>quit</em> — 优雅停止</li>
<li><em>reload</em> — 重新加载配置文件</li>
<li><em>reopen</em> — 重新打开日志文件</li>
</ul>
<h2 id="Nginx命令行参数"><a href="#Nginx命令行参数" class="headerlink" title="Nginx命令行参数"></a>Nginx命令行参数</h2><ul>
<li><em>-h</em> 显示命令行参数帮助信息</li>
<li><em>-c file</em> 指定file为nginx的配置文件</li>
<li><em>-g directives</em> 设置全局的配置指令，如：</li>
</ul>
<blockquote>
<p>nginx -g “pid /var/run/nginx.pid; worker_processes <code>sysctl -n hw.ncpu</code>;”</p>
</blockquote>
<ul>
<li><em>-p prefix</em> 设置nginx路径前缀，即保存nginx服务文件的文件夹</li>
<li><em>-t</em> 测试配置文件，检查配置文件语法，然后加载配置文件</li>
<li><em>-T</em> 与-t相同，但是会在标准输出打印出配置文件</li>
<li><em>-q</em> 测试配置文件，不输出费错误信息</li>
<li><em>-v</em> 输出nginx的版本</li>
<li><em>-V</em> 输出nginx的版本，编译器版本及配置参数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/07/other/homebrew/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/other/homebrew/" itemprop="url">Mac Homebrew 的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-07T19:42:30+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li>brew install [formula]:安装 formula</li>
<li>brew uninstall [formula]:卸载 formula</li>
<li>brew list: 显示所有安装的 formula</li>
<li>brew search (text|/text/)： 查找 formula</li>
</ol>
<blockquote>
<p>摘译自 <a href="http://robots.thoughtbot.com/starting-and-stopping-background-services-with-homebrew" target="_blank" rel="noopener">robots.thoughtbot.com</a></p>
</blockquote>
<p><code>launchctl</code> 命令加载，卸载开机自动运行的服务，在 OS X 中，服务本身存储在 <code>.plist</code> 文件中（即 property list），这些文件的位置一般在 <code>~/Library/LaunchAgents</code> 或 <code>/Library/LaunchAgents</code>。可以使用 <code>launchctl load $PATH_TO_LIST</code> 和 <code>unload them with launchctl unload $PATH_TO_LIST</code> 命令来加载/卸载他们。加载就是允许这个程序开机执行，卸载反之。</p>
<p>如果你使用 <code>Homebrew</code> 安装过 <code>mysql</code> 那么下面的安装后提示你可能比较熟悉<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To have launchd start mysql at login:</span><br><span class="line">    ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents</span><br><span class="line">Then to load mysql now:</span><br><span class="line">    launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</span><br><span class="line">Or, if you don&apos;t want/need launchctl, you can just run:</span><br><span class="line">    mysql.server start</span><br></pre></td></tr></table></figure></p>
<p>如果按上面的说明操作的话，未免太麻烦了，而且也很难记住 plist 的位置。还好 Homebrew 提供了一个易用的接口来管理 plist，然后你就不用再纠结什么 <code>ln</code>，<code>launchctl</code>，和 plist 的位置了。</p>
<h2 id="brew-services"><a href="#brew-services" class="headerlink" title="brew services"></a>brew services</h2><p>首先安装 <code>brew services</code> 命令<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap gapple/services</span><br></pre></td></tr></table></figure></p>
<p>下面举个例子<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> $ brew services start mysql</span><br><span class="line">==&gt; Successfully started `mysql` (label: homebrew.mxcl.mysql)</span><br></pre></td></tr></table></figure></p>
<p>在后台，<code>brew services start</code> 其实执行了最上面的安装后消息里面提到的所有命令，比如首先运行 <code>ln -sfv ...</code>，然后 <code>launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</code> 。</p>
<p>假设突然 MySQL 出毛病了，我们要重启一下，那么执行下面的命令就行了<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew services restart mysql</span><br><span class="line">Stopping `mysql`... (might take a while)</span><br><span class="line">==&gt; Successfully stopped `mysql` (label: homebrew.mxcl.mysql)</span><br><span class="line">==&gt; Successfully started `mysql` (label: homebrew.mxcl.mysql)</span><br></pre></td></tr></table></figure></p>
<p>想看所有的已启用的服务的话：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> $ brew services list</span><br><span class="line">redis      started      442 /Users/gabe/Library/LaunchAgents/homebrew.mxcl.redis.plist</span><br><span class="line">postgresql started      443 /Users/gabe/Library/LaunchAgents/homebrew.mxcl.postgresql.plist</span><br><span class="line">mongodb    started      444 /Users/gabe/Library/LaunchAgents/homebrew.mxcl.mongodb.plist</span><br><span class="line">memcached  started      445 /Users/gabe/Library/LaunchAgents/homebrew.mxcl.memcached.plist</span><br><span class="line">mysql      started    87538 /Users/gabe/Library/LaunchAgents/homebrew.mxcl.mysql.plist</span><br></pre></td></tr></table></figure></p>
<p>要注意的是，这里不止显示通过 <code>brew services</code> 加载的服务，也包含 <code>launchctl load</code> 加载的。</p>
<p>如果你卸载了 MySQL 但是 <code>Homebrew</code> 没把 plist 文件删除的话，你可以<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew services cleanup</span><br><span class="line">Removing unused plist /Users/gabe/Library/LaunchAgents/homebrew.mxcl.mysql.plist</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>最后一提，这玩意路径不一样，会直接复制到 LaunchAgents 目录，结果就是两个一样的启动项了，系统 log 里会很烦人的。。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/20/linux/linux环境变量总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/linux/linux环境变量总结/" itemprop="url">Linux环境变量总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-20T22:09:32+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自： <a href="https://www.jianshu.com/p/ac2bc0ad3d74" target="_blank" rel="noopener">https://www.jianshu.com/p/ac2bc0ad3d74</a></p>
<h2 id="Linux环境变量分类"><a href="#Linux环境变量分类" class="headerlink" title="Linux环境变量分类"></a>Linux环境变量分类</h2><p>一、按照生命周期来分，Linux环境变量可以分为两类：</p>
<ol>
<li>永久的：需要用户修改相关的配置文件，变量永久生效。</li>
<li>临时的：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。</li>
</ol>
<p>二、按照作用域来分，Linux环境变量可以分为：</p>
<ol>
<li>系统环境变量：系统环境变量对该系统中所有用户都有效。</li>
<li>用户环境变量：顾名思义，这种类型的环境变量只对特定的用户有效。</li>
</ol>
<h2 id="Linux设置环境变量的方法"><a href="#Linux设置环境变量的方法" class="headerlink" title="Linux设置环境变量的方法"></a>Linux设置环境变量的方法</h2><p>一、在/etc/profile文件中添加变量 对所有用户生效（永久的）<br>用vim在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。修改文件后要想马上生效还要运行<code>source /etc/profile</code> 不然只能在下次重启时生效。</p>
<p>二、在用户目录下的 <code>.bash_profile</code> 文件中增加变量 【对单一用户生效（永久的）】<br>用 <code>vim ~/.bash_profile</code> 文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。修改文件后要想马上生效还要运行 <code>source ~/.bash_profile</code> 不然只能在下次重进此用户时生效。</p>
<p>三、直接运行 <code>export</code> 命令定义变量 【只对当前shell（BASH）有效（临时的）】<br>在shell的命令行下直接使用 <code>export 变量名=变量值</code><br>定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p>
<h2 id="Linux环境变量使用"><a href="#Linux环境变量使用" class="headerlink" title="Linux环境变量使用"></a>Linux环境变量使用</h2><p>一、Linux中常见的环境变量有：</p>
<ul>
<li>PATH：指定命令的搜索路径</li>
<li>HOME：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）。</li>
<li>HISTSIZE：指保存历史命令记录的条数。</li>
<li>LOGNAME：指当前用户的登录名。</li>
<li>HOSTNAME：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的</li>
<li>SHELL：指当前用户用的是哪种Shell。</li>
<li>LANG/LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。</li>
<li>MAIL：指当前用户的邮件存放目录。</li>
</ul>
<p>二、Linux也提供了修改和查看环境变量的命令，下面通过几个实例来说明：</p>
<ul>
<li>echo         显示某个环境变量值 echo $PATH</li>
<li>export   设置一个新的环境变量 export HELLO=”hello” (可以无引号)</li>
<li>env      显示所有环境变量</li>
<li>set      显示本地定义的shell变量  </li>
<li>unset        清除环境变量 unset HELLO</li>
<li>readonly     设置只读环境变量 readonly HELLO</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/linux/linux 权限/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/11/linux/linux 权限/" itemprop="url">Linux权限</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-11T22:01:23+08:00">
                2019-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux的安全性"><a href="#Linux的安全性" class="headerlink" title="Linux的安全性"></a>Linux的安全性</h2><p>Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配一个唯一的用户账户。用户系统对系统中各种对象的访问权限取决于他们登录系统时用的账户。</p>
<p>用户权限是通过创建用户时分配的用户ID（UID）来跟踪的，每个用户都会有一个UID和一个对应的密码</p>
<h3 id="etc-passwd-文件"><a href="#etc-passwd-文件" class="headerlink" title="/etc/passwd 文件"></a>/etc/passwd 文件</h3><p>Linux系统使用一个专门的文件栏来将用户的登录名匹配到UID值，这个文件就是 /etc/passwd 文件。它包含了以下信息：</p>
<ul>
<li>登录用户名</li>
<li>用户密码</li>
<li>UID</li>
<li>GID（用户组ID）</li>
<li>用户账户的文本描述</li>
<li>用户HOME目录的位置</li>
<li><p>用户默认的Shell<br>root用户账户是Linux系统的管理员，固定分配的UID是0。Linux系统会为各种各样的功能创建不同的用户账户，这些账户不是真正的账户。它们叫做系统账户，是系统上运行各种服务进程访问资源的特殊账户。所有运行在后台的服务都需要一个系统用户登录到Linux系统上。通常系统账户的UID是500以下的值。</p>
<p>/etc/passwd 文件中用户密码都被设置成了x，真实的密码被保存到了 /etc/shadow 文件中，只有特定的程序（比如登录程序）才能访问这个文件。</p>
<h3 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a>/etc/shadow 文件</h3><p>/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow<br>文件，这让它比起/etc/passwd安全许多。</p>
</li>
</ul>
<p>/etc/shadow文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样：<br><code>rich:$1$.FfcK0ns$f1UgiyHQ25wrB/hykCn020:11627:0:99999:7:::</code></p>
<p>在/etc/shadow文件的每条记录中都有9个字段：</p>
<ul>
<li>与/etc/passwd文件中的登录名字段对应的登录名</li>
<li>加密后的密码</li>
<li>自上次修改密码后过去的天数密码（自1970年1月1日开始计算）</li>
<li>多少天后才能更改密码</li>
<li>多少天后必须更改密码</li>
<li>密码过期前提前多少天提醒用户更改密码</li>
<li>密码过期后多少天禁用用户账户</li>
<li>用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）</li>
<li>预留字段给将来使用</li>
</ul>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h3><p>用来向Linux系统添加新用户的主要工具是 <code>useradd</code>,需要root权限或 sudo 。这个命令简单快捷，可以一次性创建新用户账户及设置用户HOME目录结构。<code>useradd</code> 命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在 <code>/etc/default/useradd</code> 文件中。可以使用加入了 -D 选项的 <code>useradd</code><br>命令查看所用Linux系统中的这些默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># /usr/sbin/useradd -D</span><br><span class="line">GROUP=100 新用户会被添加到GID为 100 的公共组</span><br><span class="line">HOME=/home 新用户的HOME目录将会位于/home/loginname</span><br><span class="line">INACTIVE=-1 新用户账户密码在过期后不会被禁用</span><br><span class="line">EXPIRE=   新用户账户未被设置过期日期</span><br><span class="line">SHELL=/bin/bash 新用户账户将bash shell作为默认shell</span><br><span class="line">SKEL=/etc/skel 系统会将/etc/skel目录下的内容复制到用户的HOME目录下</span><br><span class="line">CREATE_MAIL_SPOOL=yes  系统为该用户账户在mail目录下创建一个用于接收邮件的文件</span><br></pre></td></tr></table></figure></p>
<p>倒数第二个值很有意思。 useradd 命令允许管理员创建一份默认的HOME目录配置，然后把<br>它作为创建新用户HOME目录的模板。这样就能自动在每个新用户的HOME目录里放置默认的系<br>统文件。在Ubuntu Linux系统上，/etc/skel目录有下列文件：</p>
<ul>
<li>.bash_logout</li>
<li>.bashrc</li>
<li>.profile</li>
</ul>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>如果你想从系统中删除用户， <code>userdel</code> 可以满足这个需求。默认情况下， <code>userdel</code> 命令会只<br>删除 <code>/etc/passwd</code> 文件中的用户信息，而不会删除系统中属于该账户的任何文件。要删除用户的 home 目录，加上 -r 选项即可。</p>
<h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><p>用户账户修改工具：</p>
<p>命令 | 描述<br>|-|-|<br>|usermod |修改用户账户的字段，还可以指定主要组以及附加组的所属关系|<br>|passwd | 修改已有用户的密码|<br>|chpasswd | 从文件中读取登录名密码对，并更新密码|<br>|chage | 修改密码的过期日期|<br>|chfn | 修改用户账户的备注信息|<br>|chsh | 修改用户账户的默认登录shell|</p>
<h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p><code>usermod</code> 命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟 useradd 命令的参数一样（比如， -c 修改备注字段， -e 修改过期日期， -g 修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项:</p>
<ul>
<li>-l: 修改用户账户的登录名</li>
<li>-L: 锁定账户，使用户无法登录</li>
<li>-p: 修改账户的密码</li>
<li>-U: 解除锁定，使用户能够登录</li>
</ul>
<h4 id="passwd-和-chpasswd"><a href="#passwd-和-chpasswd" class="headerlink" title="passwd 和 chpasswd"></a>passwd 和 chpasswd</h4><p>只用 passwd 命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只有root用户才有权限改别人的密码。</p>
<p>如果需要为系统中的大量用户修改密码， chpasswd 命令可以事半功倍。 chpasswd 命令能从标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你也可以用重定向命令来将含有 userid:passwd 对的文件重定向给该命令。<br><code># chpasswd &lt; users.txt</code></p>
<h2 id="Linux-组"><a href="#Linux-组" class="headerlink" title="Linux 组"></a>Linux 组</h2><h3 id="etc-group-文件"><a href="#etc-group-文件" class="headerlink" title="/etc/group 文件"></a>/etc/group 文件</h3><p>与用户账户类似，组信息也保存在系统的一个文件中。/etc/group文件包含系统上用到的每个组的信息。系统账户用的组通常会分配低于500的GID值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>
<ul>
<li>组名</li>
<li>组密码</li>
<li>GID</li>
<li>属于该组的用户列表<br>查看用户所属组信息：<code>groups</code>|<code>grooups [username]</code>.</li>
</ul>
<h3 id="创建新组"><a href="#创建新组" class="headerlink" title="创建新组"></a>创建新组</h3><p><code>groupadd</code>  命令可在系统上创建新组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd shared</span><br><span class="line">usermod -G shared test #添加用户 test 到 shared 组</span><br></pre></td></tr></table></figure></p>
<h3 id="修改组"><a href="#修改组" class="headerlink" title="修改组"></a>修改组</h3><p><code>groupmod</code> 命令可以修改组：</p>
<ul>
<li>-g: 修改GID</li>
<li>-n: 修改组名</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/25/分布式/kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/25/分布式/kafka/" itemprop="url">Kafka 相关问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-25T22:02:12+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Kafka Producer如何保证消息可靠<br>request.required.acks有三个值 0 1 -1<ol>
<li>0:生产者不会等待broker的ack，这个延迟最低但是存储的保证最弱当server挂掉的时候就会丢数据</li>
<li>1：服务端会等待ack值 leader副本确认接收到消息后发送ack但是如果leader挂掉后他不确保是否复制完成新leader也会导致数据丢失</li>
<li>-1：同样在1的基础上 服务端会等所有的follower的副本受到数据后才会受到leader发出的ack，这样数据不会丢失</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/22/java/java基础-流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/22/java/java基础-流/" itemprop="url">Java基础-流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-22T22:32:18+08:00">
                2021-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java-流概述"><a href="#Java-流概述" class="headerlink" title="Java 流概述"></a>Java 流概述</h3><p>Java 8 中增加了 Stream API，简化了串行或并行的大批量操作。这个 API 提供了两个关键抽象：</p>
<ol>
<li><p>Stream（流）<br>代表数据元素的有限或无限顺序，这些元素可能来自任何位置，常见的来源包括集合、数组、文件、正则表达式模式匹配器、伪随机数生成器，以及其他 Stream 。Stream 中的数据元素可以是对象引用、或者基本类型值。它支持三种基本类型：int、long 和 double 。</p>
</li>
<li><p>Strean pipeline（流管道）<br>代表这些元素的一个多级计算。一个 Strean pipeline 中包含一个源 Stream ，接着是 0 或者多个中间操作和一个终止操作。每个中间操作都会通过某种方式对 Stream 进行转换，例如将每个元素通过一个函数映射到另一元素，或者过滤掉某些不满足条件的元素。所有的中间操作都会将 Stream 转换成另一个 Stream， 其元素类型可能与输入的 Stream 一样，也可能不同。终止操作会在最后一个中间操作产生的 Stream 上执行一个最终计算，例如将其元素保存到一个集合中，并返回某一个元素，或打印出所有元素等。<br>Stream pipeline 通常是 lazy 的：直到调用终止操作时才会开始计算，对于完成终止操作不需要的数据元素，将永远都不会被计算。正是这种 lazy 计算，使无限 Stream 成为可能。没有终止操作的 Stream pipeline 将是一个静默的无操作指令，因此千万不能忘记终止操作。<br>Stream API 是流式的：所有的 pipeline 的调用可以链接成一个表达式。事实上，多个 pipeline 也可以链接在一起，成为一个表达式。<br>默认情况下，Stream pipeline 是按顺序运行的。要使 pipeline 并发执行，只需在该 pipeline 的任何 Stream 上调用 parallel 方法即可，但是通常不建议这么做。</p>
</li>
</ol>
<h3 id="Collectors-API"><a href="#Collectors-API" class="headerlink" title="Collectors API"></a>Collectors API</h3><p>Collectors API 又叫收集器，它的作用是将 Stream 的元素合并到单个对象中去，收集器产生的对象一般是一个集合。<br>将 Stream 的元素集中到一个真正的 Collection 里去的收集器比较简单，它有三个这样的收集器： <code>toList()</code>、<code>toSet()</code>、<code>toCollection(collectionFactory)</code>，它们分别返回一个列表、一个集合和程序员指定的集合类型。<code>toMap(keyMapper,valueMapper)</code> 将 Stream 元素集合到 Map 中，keyMapper 是一个将 Stream 元素映射到 Map 中键的函数，而 valueMapper 是将 Stream 元素映射到 Map 中值的函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/18/java/IO/java基础-序列化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/java/IO/java基础-序列化/" itemprop="url">Java基础-序列化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T20:13:04+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h3><p>实现 Serializable 或者 Externailizable 接口。</p>
<h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>一旦某个类实现了 Serializable 接口，就可以使用如下方式序列化：</p>
<ol>
<li>创建 ObjectOutputStream 对象.</li>
<li>调用 ObjectOutputStream 的 writeObject(object)输出可序列化对象</li>
</ol>
<p>反序列化：</p>
<ol>
<li>创建 ObjectInputStream 对象.</li>
<li>调用 ObjectOutputStream 的 readObject()反序列化.</li>
</ol>
<p>反序列化时读取的只是对象的数据，而不包含类的信息，其实，序列化时也仅仅是保存了对象的信息。因此，反序列化时需要提供类信息，让JVM知道还原成什么类型对象及如何还原对象。</p>
<p>反序列化时，并没有调用类的构造器来构造对象。</p>
<p>当一个可序列化类有一个或多个父类时（直接父类和间接父类），这些父类要么有无参构造函数，要么也是可序列化的。如果是不可序列化的，只有无参构造函数，则父类成员变量中的值不会被序列化到二进制流中。</p>
<h4 id="引用成员的序列化"><a href="#引用成员的序列化" class="headerlink" title="引用成员的序列化"></a>引用成员的序列化</h4><p>递归序列化：当实例化某个对象时，系统会递归地序列化对象的实例变量，如果实例变量是引用类型，则被引用的对象也会被实例化。</p>
<p>如果一个类中含有引用类型的成员变量，那么引用类型的类必须也是可序列化的，这个类才是可序列化的，否则即使实现了 Serializable 接口，也是不可序列化的。</p>
<p>假设同一个对象被多个其它对象引用，如果同时序列化这些对象，那么这个对象可能会被序列化多次，一来浪费空间，二来在反序列化时，可能会生成多个对象，这与实际情况不符。所以 Java 使用了下面特殊的序列化算法：</p>
<ol>
<li>所有保存到二进制流中的对象都有一个序列化编号</li>
<li>当程序试图序列化一个对象时，程序将检查对象是否已经被序列化过，只有对象从未被序列化过，系统才会将对象转换成字节序列并输出。</li>
<li>如果某个对象已经被序列化过，程序将只会输出一个序列化编号，而不会再次序列化该对象<br><img src="/pics/serialize.jpg" alt="对象序列化示意"></li>
</ol>
<p>上述机制会引入一个问题：假设有一个可变对象，当第一次序列化后，改变了对象的状态（某些成员变量值），再次序列化时，因为已经被序列化过，所以系统只是输出一个编号，所以序列化的值并不是修改后的值。</p>
<h4 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h4><ol>
<li>通过在实例变量前添加 transient 关键字，可以让 JAVA 序列化机制在序列化时完全忽略该实例变量。</li>
<li>还可以通过下述签名方法来完全控制某个实例变量的序列化：<ul>
<li>private void writeObject(ObjectOutputStream out) throws IOException</li>
<li>private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException</li>
<li>private void readObjectNoData(ObjectOutputStream out) throws ObjectStreamException</li>
</ul>
</li>
</ol>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(ObjectOutputStream out) throws IOException&#123;</span><br><span class="line">    out.writeObject(new String(name).reverse());</span><br><span class="line">    out.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException&#123;</span><br><span class="line">    this.name = (String)in.readObjetc().reverse();</span><br><span class="line">    this.age = in.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>Java序列化机制允许为序列化类提供一个 <code>private static final long serialVersionUID</code> 的值，用于标识 Java 类序列化的版本，也就是说，如果一个类升级后，只要它的 serialVersionUID 类变量值保持不变，序列化机制也会把它们当成同一个序列化版本。如果不显示定义 serialVersionUID 类变量的值，该类变量值将由 JVM 根据类的相关信息计算，而修改后的类计算结果与修改前的类的计算结果往往不同，从而造成对象的反序列化因为类版本不兼容而失败。</p>
<p>可以通过 JDK 安装路径 bin 下的 serialver.exe 工具来获得该类的 serialVersionUID 类变量的值： <code>serialver Person</code></p>
<h3 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void writeExternal(ObjectOutput out) throws IOException;</span><br><span class="line">void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<p>实际上，使用实现 Externalizable 接口方式的序列化方式与前面介绍的自定义序列化方式非常相似，只是 Externalizable 接口强制自定义序列化。<br><img src="/pics/serialize-compare.jpg" alt="两种序列化机制的对比"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>对象的类名、实例变量（包括基本类型、数组、其它对象的引用）都会被序列化；方法、类变量、 transient 实例变量都不会被序列化</li>
<li>实现 Serializable 接口的类如果需要让某个实例变量不被序列化，则在该实例变量前加 transient 修饰.</li>
<li>保证类是可序列化的必须保证引用的实例变量类型也是可序列化的，否则需要时用 transient 修饰，否则该类也是不可序列化的</li>
<li>反序列化时必须要有序列化对象的 class 文件</li>
<li>当通过文件、网络来反序列化对象时，必须按实际写入的顺序来读取。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/java/java基础-Lambda表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/java/java基础-Lambda表达式/" itemprop="url">Java基础-Lambda表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-06T17:30:09+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注：转载自 <a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="noopener">http://blog.oneapm.com/apm-tech/226.html</a></p>
<h3 id="Lambda-表达式简介"><a href="#Lambda-表达式简介" class="headerlink" title="Lambda 表达式简介"></a>Lambda 表达式简介</h3><p>我们知道类和对象是 Java 中的一等公民，也就是说Java中几乎所有的语言都是要先定义一个类或接口，然后创建对象，然后调用对象的方法。不像C那样可以直接定义一个函数然后直接调用这个函数而无需创建对象。Java中的方法参数都是对象类型的，如果我想要传入一个函数作为参数，就比较麻烦，通常是使用一个匿名内部类的方式，语法显得很臃肿。Lambda 表达式正是为了解决这一个问题的，它是一种匿名函数(对 Java 而言这并不完全正确，但现在姑且这么认为)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。</p>
<p>你可以将其想做一种速记，在你需要使用某个方法的地方写上它。当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。</p>
<p>Java 中的 Lambda 表达式通常使用 <code>(argument) -&gt; (body)</code> 语法书写，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class="line">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是一些 Lambda 表达式的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(int a, int b) -&gt; &#123;  return a + b; &#125; ;</span><br><span class="line">() -&gt; System.out.println(&quot;Hello World&quot;); </span><br><span class="line">(String s) -&gt; &#123; System.out.println(s); &#125; ;</span><br><span class="line">() -&gt; 42 </span><br><span class="line">() -&gt; &#123; return 3.1415 &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Lambda-表达式的结构"><a href="#Lambda-表达式的结构" class="headerlink" title="Lambda 表达式的结构"></a>Lambda 表达式的结构</h3><p>让我们了解一下 Lambda 表达式的结构。</p>
<ol>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</li>
<li>空圆括号代表参数集为空。例如：() -&gt; 42</li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a</li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ol>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口，可以包含多个默认方法、类方法，但只能有一个抽象方法。</p>
<p>java.lang.Runnable 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 void run()，相似地，ActionListener 接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。</p>
<p>每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure></p>
<p>当不指明函数式接口时，编译器会自动解释这种转化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Thread(</span><br><span class="line">   () -&gt; System.out.println(&quot;hello world&quot;)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure></p>
<p>因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 <code>public Thread(Runnable r) { }</code>，将该 Lambda 表达式赋给 Runnable 接口。</p>
<p>以下是一些 Lambda 表达式及其函数式接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Integer&gt;  c = (int x) -&gt; &#123; System.out.println(x) &#125;;</span><br><span class="line">BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + &quot; : &quot; + y);</span><br><span class="line">Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == null &#125;;</span><br></pre></td></tr></table></figure></p>
<p>@FunctionalInterface 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</p>
<p>以下是一种自定义的函数式接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface WorkerInterface &#123;</span><br><span class="line">   public void doSomeWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface WorkerInterface &#123;</span><br><span class="line">    public void doSomeWork();</span><br><span class="line">    public void doSomeMoreWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unexpected @FunctionalInterface annotation </span><br><span class="line">    @FunctionalInterface ^ WorkerInterface is not a functional interface multiple </span><br><span class="line">    non-overriding abstract methods found in interface WorkerInterface 1 error</span><br></pre></td></tr></table></figure></p>
<p>函数式接口定义好后，我们可以在 API 中使用它，同时利用 Lambda 表达式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> //定义一个函数式接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface WorkerInterface &#123;</span><br><span class="line">   public void doSomeWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class WorkerInterfaceTest &#123;</span><br><span class="line">    public static void execute(WorkerInterface worker) &#123;</span><br><span class="line">        worker.doSomeWork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args) &#123;</span><br><span class="line">        //invoke doSomeWork using Annonymous class</span><br><span class="line">        execute(new WorkerInterface() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void doSomeWork() &#123;</span><br><span class="line">                System.out.println(&quot;Worker invoked using Anonymous class&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //invoke doSomeWork using Lambda expression </span><br><span class="line">        execute( () -&gt; System.out.println(&quot;Worker invoked using Lambda expression&quot;) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker invoked using Anonymous class </span><br><span class="line">Worker invoked using Lambda expression</span><br></pre></td></tr></table></figure></p>
<p>这上面的例子里，我们创建了自定义的函数式接口并与 Lambda 表达式一起使用。execute() 方法现在可以将 Lambda 表达式作为参数。</p>
<h3 id="Lambda-表达式与匿名类的区别"><a href="#Lambda-表达式与匿名类的区别" class="headerlink" title="Lambda 表达式与匿名类的区别"></a>Lambda 表达式与匿名类的区别</h3><p>使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写就 Lambda 的外部类。</p>
<p>Lambda 表达式与匿名类的另一不同在于两者的编译方法。Java 编译器编译 Lambda 表达式并将他们转化为类里面的私有函数，它使用 Java 7 中新加的 invokedynamic 指令动态绑定该方法，关于 Java 如何将 Lambda 表达式编译为字节码，Tal Weiss 写了一篇很好的文章。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/29/js/00-JS运行机制详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/29/js/00-JS运行机制详解/" itemprop="url">JavaScript的运行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-29T15:37:30+08:00">
                2018-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>说到JS，脑海里首先会想到的是单线程、事件循环、异步等等概念，这些名词到底代表什么，之前了解的不是很深入。后来，看到这个Philip Roberts的演讲：《<a href="https://vimeo.com/96425312" target="_blank" rel="noopener">Help, I’m stuck in an event-loop.</a>》.感觉对这些概念的理解又深入了一些。</p>
<p>首先，引入一张图：<br><img src="/pics/js_eventloop.png" alt="V8 JS运行原理"></p>
<p>首先按照我的理解来描述一下上图：<br>我们写了一个JS脚本文件，JS引擎执行的时候，会产生执行栈和堆，JS引擎在执行代码的时候，代码可能会调用WebApi执行一些异步操作，比如执行ajax、调用setTimeout、绑定响应DOM事件的函数等等。这些webApi函数往往都是需要一个回调函数作为参数来调用的。但是这些回调函数不会立即被调用，而是在一定条件下，由webApi内部将这些回调函数放到call-back-queue中，JS引擎在执行完脚本代码后，最后会在event-loop上死循环。</p>
<p>用一句话来总结JS引擎的工作流程：执行JS脚本中的代码，JS代码要么立即执行一些操作，要么就是调用webAPi，WebApi在某些时候会向call-back-queue中放入回调函数，JS引擎执行完这些JS代码后，就会执行一个event-loop,循环执行call-back-queue中的回调函数。</p>
<p>所以说，JS脚本中的代码总是先于call-back-queue中的代码执行。<br>对照上图，我们一一来解释上述名词</p>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>单线程指的是JS引擎执行JS代码是单线程的，但是一些WebApi调用如ajax,setTimeout,事件响应等是由其它线程完成的。之前一直困扰我的一个问题是：既然JS是单线程的，那么它是如何做到并发的执行JS代码，又去发起异步ajax请求的呢？其实，ajax请求是由webApi实现者完成的。它可以是多线程的。<br>所以这里单线程的范畴应该是指图中的call stack、堆、event-loop和call-back-queue。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>JS引擎最后总是陷入event-loop循环执行call-back-queue中的回调函数。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>webApi的某些调用执行是在另一个线程中完成的，与JS执行线程是异步的。JS通过执行回调函数来响应webApi产生的事件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/29/js/03-JS数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/29/js/03-JS数据类型/" itemprop="url">JavaScript 基本概念和数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-29T15:37:30+08:00">
                2018-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。</li>
<li>标识符:<ul>
<li>第一个字符必须时字母、下划线或美元符号；</li>
<li>其他字符可以是字母、数字、下划线或美元符号。</li>
</ul>
</li>
<li><p>严格模式为JS的执行定义了一种不同的解析与执行模式。要在整个脚本中启用严格模式，在脚本顶部添加如下代码：<br> <code>&#39;use strict&#39;</code><br>在某个函数中启用严格模式，可以在函数体顶部加入上述代码：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">    &apos;use strict&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量<br>ECMAScript 使用 var 操作符来定义一个变量，ECMAScript 中的变量时松散类型的，可以用来保存任何类型的数据。</p>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 有5种基本数据类型： <code>Undefined</code> , <code>Null</code> , <code>Boolean</code> , <code>Number</code> , <code>String</code>。<br>还有一种复杂数据类型： <code>Object</code> 。<br>ECMAScript 不支持任何创建自定义类型的机制，所有值最终都将是上述6种数据类型之一。</p>
<h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p>对一个值使用 typeof 操作符，会返回下列某个字符串：</p>
<ul>
<li>undefined——-如果这个值未定义或未初始化</li>
<li>boolean———-如果这个值是布尔值</li>
<li>string————如果这个值是字符串</li>
<li>number————如果这个值是数值</li>
<li>object————如果这个值是对象或 null</li>
<li>function————如果这个值是函数</li>
</ul>
<h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p>Undefined 类型只有一个值，即特殊的 <code>undefinded</code> 。使用 var 操作符声明变量但是未对其加以初始化时，这个变量的值就是 <code>undefinded</code> 。<br><code>undefinded</code> 值的变量和未定义的变量是不一样的，可以引用 <code>undefinded</code> 值的变量，但是引用未定义的变量很可能会报错。对于未定义的变量，只能执行一项操作，即使用 typeof 操作符检测其数据类型。</p>
<p>但是，对于未定义的变量和未初始化的变量执行 typeof 操作，返回值都是 undefinded 。</p>
<h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p>Null 类型也只有一个值，即 <code>null</code> 。 <code>null</code> 值表示一个空对象指针，这也是使用 typeof 操作符检测 <code>null</code> 值时会返回 <code>object</code> 的原因。如果定义的变量准备在将来用于保存对象，那么最好将其初始化为 <code>null</code> 而不是其它值。</p>
<p><code>undefinded</code> 值是 派生于 <code>null</code> 值的，因此：<br><code>null == undefined     //true</code><br>但是，两者的应用场景还是有很大区别的。 <code>undefinded</code> 用来表示未初始化的变量，而只要是想在将来用来保存对象引用的变量，就用 <code>null</code> 初始化。</p>
<h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>Boolean 类型只有两个字面值： <code>true</code> 和 <code>false</code>。所有类型的值都有与这两个值等价的值。要将一个值转换为对应的 Boolean 值，可以使用转型函数 <code>Boolean()</code>。<br>各种数据类型的转换规则如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>空字符串</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值(包括无穷大)</td>
<td>0和 NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a</td>
<td>undefined</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>ECMAScript 使用 IEEE-754 标准来表示整数和浮点数。</p>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>Object的每个实例都具有下列属性和方法：</p>
<ul>
<li>constructor: 保存用于创建当前对象的函数。</li>
<li>hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。 <code>property</code> 必须是字符串。</li>
<li>isPrototypeOf(object): 用于检查调用对象是否是传入对象参数的原型。</li>
<li>propertyIsEnumerable(propertyName): 用于检查传入的属性是否能够用 <code>for-in</code> 语句来枚举。 <code>property</code> 必须是字符串.</li>
<li>toLocalString(): 返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>valueOf(): 返回对象的字符串、整数值或不二值表示。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/09/js/06-JS原型模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/09/js/06-JS原型模式/" itemprop="url">JavaScript 原型模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-09T20:52:37+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/08/js/05-JS创建对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/08/js/05-JS创建对象/" itemprop="url">JavaScript 创建对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-08T20:52:37+08:00">
                2018-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age)&#125;&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = createPerson(&apos;A&apos;,18);</span><br><span class="line">var p2 = createPerson(&apos;B&apos;,20);</span><br></pre></td></tr></table></figure>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Person(&apos;A&apos;,18);</span><br><span class="line">var p2 = new Person(&apos;B&apos;,20);</span><br></pre></td></tr></table></figure>
<p>与工厂模式相比有以下几点不同：</p>
<ul>
<li>没有显示地创建对象</li>
<li>直接将属性和方法赋给了 <code>this</code> 对象</li>
<li>没有 return 语句，即使有的话，使用 new 构造对象时，也会被忽略。</li>
</ul>
<h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h3><p>使用 <code>new</code> 操作符调用构造函数会经历以下4个阶段：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（因此 <code>this</code> 指向了这个新对象）</li>
<li>执行构造函数代码</li>
<li>返回新对象</li>
</ol>
<h3 id="构造函数也是普通的函数"><a href="#构造函数也是普通的函数" class="headerlink" title="构造函数也是普通的函数"></a>构造函数也是普通的函数</h3><p>构造函数与其它函数的唯一区别，就在于它的调用方式不同（通过 <code>new</code> 操作符调用）。任何其它函数，只要通过 <code>new</code> 操作符来调用，那么它就可以成为构造函数，如果不通过  <code>new</code> 操作符调用，那它普通函数就没什么两样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = new person(&apos;A&apos;,18); //构造函数调用</span><br><span class="line">Person(&apos;A&apos;,18); //普通函数调用，this指向 global或window对象</span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o,&apos;A&apos;,18);//在另一个对象作用域中调用，this 指向 o。</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述构造函数在实例化对象时，会在每个对象上创建一个 sayName 方法，这些方法并不是同一个实例。这样一方面会加大内存耗用，另一方面也无法体现出方法是共享的这一特性。</p>
<p>一个简单的方法是将 sayName 定义为全局函数，然后在构造函数中，将其赋值给每个实力属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line">function sayName()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，实例化多个实例时，各个实例是共享的同一个方法实例，但是破坏了对象的封装性，如果一个对象需要定义很多方法，那么就要定义很多全局函数，那么就毫无封装性可言了。</p>
<p>好在，这些问题可以通过原型模式解决，下一篇文章讲解原型模式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/js/04-JS函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/js/04-JS函数/" itemprop="url">JavaScript 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-07T21:05:24+08:00">
                2018-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ecmascript 中的函数使用 <code>function</code> 关键字来声明，后跟一组参数和函数体。定义函数时，不必指明函数是否返回值，如果想要返回值，使用 <code>return</code> 语句即可，如果 <code>return</code>后边没有值或表达式，则默认返回 <code>undefined</code>。</p>
<h2 id="理解函数参数"><a href="#理解函数参数" class="headerlink" title="理解函数参数"></a>理解函数参数</h2><p>Ecmascript 中的参数在内部是用一个数组来表示的，在函数体内可以通过 <code>arguments</code>对象来访问这个数组。<code>arguments[0]</code> 、 <code>arguments[1]</code> 、 <code>arguments[2]</code> …分别代表第一个、第二个、第三个…参数。也正是因为这个原因，调用函数时，不介意传递多少个参数，也不在乎传递的是什么类型。</p>
<p>函数的命名参数只是提供便利，不是必须的，完全可以通过 <code>arguments</code> 对象来访问参数， <code>arguments</code> 的 <code>length</code> 属性表示有多少个参数传递给了函数。没有传递值的命名参数将自动赋予 <code>undefined</code> 值。</p>
<p><code>arguments</code> 的值永远与对应的命名参数保持同步，但两者并不是同一内存空间。</p>
<p>因为 Ecmascript 函数使用数组来保存参数，可以传递任意数量参数，所以没有函数签名，也就没有真正意义上的函数重载。                                                                                                              </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/26/java/javaee/javaEE基础之Web程序基本结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/26/java/javaee/javaEE基础之Web程序基本结构/" itemprop="url">JavaEE基础之Web程序基本结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-26T22:07:35+08:00">
                2019-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录结构和War文件"><a href="#目录结构和War文件" class="headerlink" title="目录结构和War文件"></a>目录结构和War文件</h2><p>所有的 Java EE 服务器都支持War应用程序归档，大部分服务器还支持未归档的应用程序目录。如下图所示：<br><img src="/pics/java-web程序目录结构.png" alt="Java Web应用目录结构"><br>无论是未归档的文件还是 War归档文件，它们的目录结构都是一样的。<br>/META-INF:包含应用程序清单文件，也可以存储Web容器或服务器需要使用的资源。<br>/WEB-INF:存放一些包含了信息或指令的文件。<br>/WEB-INF/classes : 存放编译好的class类文件和资源文件。<br>/WEB-INF/classes/META-INF : 存放编译好的class类文件和资源文件。<br>/WEB-INF/lib : 存放依赖的jar包，在类路径上可用。<br>/WEB-INF/i18n : 存放国际化（i18n）和本地化(L10n)文件。<br>/WEB-INF/tags : 存放JSP标签文件。<br>/WEB-INF/tld : 存放JSP标签库描述符。</p>
<p>根路径下的 <em>/META-INF</em> 不在类路径下，但是 <em>/WEB-INF/classes/META-INF</em>在路径下。根路径下的资源文件一般可以通过URL直接访问。但是 <em>/WEB-INF</em> 和 <em>/META-INF</em> 下的文件是受保护的，不能直接通过URL访问。</p>
<h2 id="部署描述符"><a href="#部署描述符" class="headerlink" title="部署描述符"></a>部署描述符</h2><p>部署描述符是用于描述Web应用程序的元数据，并为Java EE Web 应用程序服务器部署和运行程序提供指令。一般部署描述符文件在 <em>/WEB-INF/web.xml</em> 中。该文件通常包含Servlet、监听器和过滤器的定义，以及HTTP会话、JSP和应用程序的配置选项。  </p>
<p>Servlet 3.0及之后更高版本的环境将扫描 Web应用程序和Web片段中的 Java EE Web应用程序注解，用于配置 Servlet、监听器和过滤器等，也就是说提供了注解配置应用程序的能力。如果需要，可以在在根&lt;web-app&gt; 或&lt;web-fragment&gt;元素中添加特性 metadata-complete=”true”，禁止扫描和注解配置。</p>
<h2 id="类加载器架构"><a href="#类加载器架构" class="headerlink" title="类加载器架构"></a>类加载器架构</h2><p>不同于 JAVA SE 中的双亲优先委托模式，Java EE Web应用程序并不完全适用这种模式。考虑以下两种情况：</p>
<ol>
<li>Java EE Web容器适用了与应用程序相同的第三方库，可能存在版本冲突。</li>
<li>不同的web应用程序之间也可能存在版本冲突。</li>
</ol>
<p>Java EE中，每个Web程序都被分配了一个自由的相互隔离的类加载器，它们都继承自公共的Web容器的类加载器。通过隔离不同的应用程序，它们不能访问相互的类（解决了上述第二个问题），不仅消除了类冲突的风险，还是一种防止web应用程序之间互相干扰的方式。</p>
<p>另外，Web应用程序使用子女优先的类加载模式，即类加载器通常只会在自己无法加载某个类的时候，才请求父类加载器帮助加载（解决上述第二个问题），Java EE服务器也提供了修改类加载模式的方法，可以改为双亲优先加载模式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/27/java/javaee/javaEE基础之Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/java/javaee/javaEE基础之Servlet/" itemprop="url">JavaEE基础之Servlet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-27T22:07:35+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Servlet是所有Java Web应用程序的核心类，它是唯一的既可以直接处理和相应用户请求，也可以将处理工作委托给应用中其它部分的类。除非某些过滤器提前终止了客户端的请求，否则所有的请求都将被发送到某些Servlet中。</p>
<p>Java EE 容器会有一个或多个内建的 Servlet，用于处理 JSP、显示目录列表和访问静态资源。</p>
<p><code>javax.servlet.Servlet</code> 是个接口，只包含了初始化并销毁 Servlet 和处理请求的方法。不过，无论什么类型的请求，甚至是非HTTP请求（假设容器支持这样的请求），也将会调用 service 方法。目前 Java EE 7支持的唯一 Servlet 协议就是 HTTP。</p>
<p>大多数情况下，Servlet都会继承自 <code>javax.servlet.http.HttpServlet</code> ，它提供了相应每种 HTTP 方法类型的方法空实现：<br><img src="/pics/httpservlet方法.png" alt="HttpServlet实现的方法"><br><code>HttpServlet</code> 各个方法接收的是 <code>javax.servlet.http.HttpServletRequest</code> 和 <code>javax.servlet.http.HttpServletResponse</code> 参数，而不是 <code>javax.servlet.http.ServletRequest</code> 和 <code>javax.servlet.http.HttpServletResponse</code> ，这样就可以轻松访问 Servlet 服务所处理的请求中的 HTTP 特定的特性。</p>
<h2 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h2><p><code>init()</code> 方法在 Servlet 构造完成之后调用，但在相应第一个请求之前。与构造器不同，调用 <code>init()</code> 方法时， Servlet 中所有的属性都已经设置完成，并提供了对 <code>javax.servlet.ServletConfig</code> 和 <code>javax.servlet.ServletContext</code> 对象的访问。所以，可以使用该方法<em>读取属性文件</em>，或者使用 <em>JDBC连接数据库</em>。</p>
<p><code>init()</code> 方法将在 Servlet 启动时调用。 Servlet 会在第一次映射到的请求访问它的时候启动，如果配置了在Web应用程序部署和启动时自动启动，那么 <code>init()</code> 方法也会被调用。</p>
<h2 id="destory-方法"><a href="#destory-方法" class="headerlink" title="destory 方法"></a>destory 方法</h2><p><code>destory()</code> 方法在 Servlet 不再接受请求之后立即调用，这通常发生在 Web 应用程序被停止或卸载，或者 Web 容器关闭时。因为它将在卸载或关闭时立即调用，所以不需要等待垃圾收集器启动垃圾回收就可以清理资源。</p>
<p>这对于应用程序被卸载了但是服务器仍然运行的环境来说非常重要（服务器还要支持其它应用运行），因为垃圾收集器可能在几分钟或数小时之后运行。如果在垃圾收集时清理资源而不是在 <code>destory()</code> 方法清理资源，则会导致应用程序占用的资源无法释放。</p>
<p>因此，应当总是使用 <code>destory()</code> 方法清理 Servlet 持有的资源。</p>
<h2 id="配置可部署的-Servlet"><a href="#配置可部署的-Servlet" class="headerlink" title="配置可部署的 Servlet"></a>配置可部署的 Servlet</h2><p>在编写创建好 Servlet 之后，需要告诉容器如何部署应用程序中的 Servlet。</p>
<h3 id="部署描述符"><a href="#部署描述符" class="headerlink" title="部署描述符"></a>部署描述符</h3><p>在部署描述符中进行正确的配置：</p>
<ol>
<li>在 web.xml 中添加 Servlet<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.servlet.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果没有 load-on-startup 标签， Servlet 会在第一个请求到达的时候被初始化及调用init方法。可能需要很长时间。加上 load-on-startup 标签后，表示在部署时就创建相应的 Servlet。 load-on-startup 标签值的大小表示启动顺序，越小越先启动。相同则按在描述符文件中出现的顺序启动。</p>
<ol>
<li>将 Servlet 映射到 URL<br>告诉容器如何启动 Servlet 之后，还需要告诉容器不同的 Servlet 分别处理对应哪些URL的请求。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用了上述标签后，所有访问应用程序相对URL/hello和/hello2 的请求都将由上面配置的helloServlet来处理。此处的 servlet-name要和上面的一样。</p>
<h3 id="WebServlet注解"><a href="#WebServlet注解" class="headerlink" title="@WebServlet注解"></a>@WebServlet注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(</span><br><span class="line">    name = &quot;helloServlet&quot;,</span><br><span class="line">    urlPatterns = &#123;&quot;/hello1&quot;,&quot;/hello2&quot;&#125;,</span><br><span class="line">    loadOnStartup = 1</span><br><span class="line">)</span><br><span class="line">public class HelloServlet extends HttpServlet&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编程式配置"><a href="#编程式配置" class="headerlink" title="编程式配置"></a>编程式配置</h3><p>除了上述两种方法，还可以使用编程的方式配置 Servlet.<br><code>ServletContext</code> 接口提供了动态添加 Servlet 的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Dynamic addServlet(String var1, String var2); </span><br><span class="line">2. Dynamic addServlet(String var1, Servlet var2); </span><br><span class="line">3. Dynamic addServlet(String var1, Class&lt;? extends Servlet&gt; var2);</span><br></pre></td></tr></table></figure></p>
<p>与编程式添加 Listener 和 Filter 一样，这必须要在在 <code>ServletContext</code> 配置完成之前完成，因为容器会根据 <code>ServletContext</code> 配置决定加载哪些 Listener/Filter/Servlet. 所以要在 <code>ServletContextListener</code> 的 <code>contextInitialized()</code> 方法或者 <code>ServletContainerInitializer</code> 中的 <code>onStartup()</code> 中注册 Servlet 。</p>
<h2 id="使用-HttpServletRequest"><a href="#使用-HttpServletRequest" class="headerlink" title="使用 HttpServletRequest"></a>使用 HttpServletRequest</h2><p><code>HttpServletRequest</code> 是对 <code>ServletRequest</code> 的扩展，可以提供关于收到请求的额外的与 HTTP 协议相关的信息。通过它可以获取 HTTP 请求的详细信息。</p>
<h3 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h3><p> <code>HttpServletRequest</code> 最重要的功能就是从客户端发送的请求中获取查询参数。请求参数有两种不同的形式：</p>
<ol>
<li>查询参数</li>
<li>以 <code>application/x-www-form-yrlencoded</code> / <code>multipart/form-data</code>  编码的请求正文。<br>常用方法：<ol>
<li>String getParameter(String var1)</li>
<li>String[] getParameterValues(String var1)</li>
<li>Map<string, string[]> getParameterMap()</string,></li>
<li>Enumeration<string> getParameterNames()</string></li>
</ol>
</li>
</ol>
<h3 id="获取与请求内容相关的信息"><a href="#获取与请求内容相关的信息" class="headerlink" title="获取与请求内容相关的信息"></a>获取与请求内容相关的信息</h3><p>与请求内容相关的信息包括：HTTP 请求内容的类型、长度和编码等。</p>
<ol>
<li>String getContentType()</li>
<li>int getContentLength()</li>
<li>long getContentLengthLong()</li>
<li>String getCharacterEncoding()</li>
</ol>
<h3 id="获取请求内容（请求体中的内容，如上传的附件）"><a href="#获取请求内容（请求体中的内容，如上传的附件）" class="headerlink" title="获取请求内容（请求体中的内容，如上传的附件）"></a>获取请求内容（请求体中的内容，如上传的附件）</h3><ol>
<li>ServletInputStream getInputStream() throws IOException: 二进制</li>
<li>BufferedReader getReader() throws IOException：文本<br>请求流只能被读取一次，多次读取会导致 IllegalStateException 异常，如果请求中含有 POST 的请求参数，且使用了获取请求参数的方法获取了POST变量，则不能再次调用上述方法，否则也会导致 IllegalStateException 异常。不要在含有 POST 变量的请求上使用上述方法。</li>
</ol>
<h3 id="获取请求特有的数据，如URL、URI和请求头"><a href="#获取请求特有的数据，如URL、URI和请求头" class="headerlink" title="获取请求特有的数据，如URL、URI和请求头"></a>获取请求特有的数据，如URL、URI和请求头</h3><ol>
<li>StringBuffer getRequestURL()</li>
<li>String getRequestURI()</li>
<li>String getServletPath()</li>
<li>String getHeader(String var1)</li>
<li>Enumeration<string> getHeaders(String var1)</string></li>
<li>Enumeration<string> getHeaderNames()</string></li>
<li>long getDateHeader(String var1)</li>
<li>int getIntHeader(String var1)</li>
</ol>
<h3 id="会话和Cookise"><a href="#会话和Cookise" class="headerlink" title="会话和Cookise"></a>会话和Cookise</h3><ol>
<li>Cookie[] getCookies()</li>
<li>HttpSession getSession()/HttpSession getSession(boolean var1)</li>
</ol>
<h2 id="使用-HttpServletResponse"><a href="#使用-HttpServletResponse" class="headerlink" title="使用 HttpServletResponse"></a>使用 HttpServletResponse</h2><p>HttpServletResponse 提供了对响应中与HTTP协议相关属性的访问。可以使用 HttpServletResponse 完成响应头设置、编写响应正文、重定向请求、设置 HTTP 状态码、设置 Cookies等任务。</p>
<h3 id="编写响应正文"><a href="#编写响应正文" class="headerlink" title="编写响应正文"></a>编写响应正文</h3><p>HttpServletResponse 最重要的功能就是向客户端返回数据内容，可以是在浏览器中显示的HTML、浏览器希望获取的图像或客户端下载的文件内容等。</p>
<ol>
<li>ServletOutputStream getOutputStream() throws IOException</li>
<li>PrintWriter getWriter() throws IOException<br>同样，不要对同一个响应对象同时调用上述方法，也不能调用两次其中一个方法。</li>
</ol>
<h3 id="设置响应头和其它属性"><a href="#设置响应头和其它属性" class="headerlink" title="设置响应头和其它属性"></a>设置响应头和其它属性</h3><ol>
<li>void addHeader(String var1, String var2)</li>
<li>void setHeader(String var1, int var2)</li>
<li>void setStatus(int var1)</li>
<li>void sendError(int var1) throws IOException</li>
<li>void sendRedirect(String var1) throws IOException</li>
<li>void setDateHeader(String var1, long var2)</li>
<li>void addDateHeader(String var1, long var2)</li>
</ol>
<h2 id="使用初始化参数配置应用程序"><a href="#使用初始化参数配置应用程序" class="headerlink" title="使用初始化参数配置应用程序"></a>使用初始化参数配置应用程序</h2><p>编写 Java Web 应用程序时，不可避免地会需要提供一些配置应用程序和Servlet的方式。通过上下文初始化参数和Servlet初始化参数可对它们进行配置。可以定义数据库连接信息、提供发送订单警告的邮件地址等。这些配置在程序启动时被读取，修改后只有重启应用才会生效。</p>
<h3 id="上下文初始化参数"><a href="#上下文初始化参数" class="headerlink" title="上下文初始化参数"></a>上下文初始化参数</h3><p>在部署描述符中使用 <context-param> 标签声明上下文初始化参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;settingOne&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;foo&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;settingTwo&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;bar&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure></context-param></p>
<p>上述参数会被加载到 <code>ServletContext</code> 中，使用 <code>ServletContext</code> 的<br><code>String getInitParameter(String var1)</code> 方法可以获取到初始化参数。 <code>ServletContext</code> 是所有 Servlet 共享的，在任意 Servlet 中都可以获取它的引用，因此，上下文初始化参数是所有 Servlet 共享的。</p>
<p><code>GenericServlet</code> 中有一个 <code>ServletConfig</code> 类型的成员，使用 <code>ServletConfig</code> 的 <code>getServletContext()</code> 可以获取到 <code>ServletContext</code> 。实际上，<code>GenericServlet</code> 提供了 <code>getServletContext()</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ServletContext getServletContext() &#123;</span><br><span class="line">    return this.getServletConfig().getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Servlet初始化参数"><a href="#Servlet初始化参数" class="headerlink" title="Servlet初始化参数"></a>Servlet初始化参数</h3><ol>
<li>在部署描述符中使用下属代码可以为特定 Servlet 配置初始化参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">       &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;</span><br><span class="line">       &lt;servlet-class&gt;com.servlet.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;database&lt;/param-name&gt;</span><br><span class="line">           &lt;param-value&gt;db&lt;/param-value&gt;</span><br><span class="line">       &lt;/init-param&gt;</span><br><span class="line">           &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;server&lt;/param-name&gt;</span><br><span class="line">           &lt;param-value&gt;10.1.21.3&lt;/param-value&gt;</span><br><span class="line">       &lt;/init-param&gt;</span><br><span class="line">       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">   &lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Servlet初始化参数会被加载到各个Servlet的 <code>ServletConfig</code> 中，因此，它们是Servlet专有的。通过 <code>ServletConfig</code> 的 <code>String getInitParameter(String var1)</code> 方法获取参数值。</p>
<ol>
<li>使用注解：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(</span><br><span class="line">    name = &quot;helloServlet&quot;,</span><br><span class="line">    urlPatterns = &#123;&quot;/hello1&quot;,&quot;/hello2&quot;&#125;,</span><br><span class="line">    loadOnStartup = 1,</span><br><span class="line">    initParams = &#123;</span><br><span class="line">        @WebInitParam(name = &quot;database&quot;,value = &quot;db&quot;),</span><br><span class="line">        @WebInitParam(name = &quot;server&quot;,value = &quot;10.1.21.3&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">public class HelloServlet extends HttpServlet&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用注解的缺点是，修改配置后，需要重新编译程序；而使用部署描述符的方式，修改完后只要重新启动程序即可，无需重新编译。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/java/javaee/javaEE基础之Listener/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/java/javaee/javaEE基础之Listener/" itemprop="url">JavaEE基础之Listener</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T15:56:39+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java-EE-中的-Listener"><a href="#Java-EE-中的-Listener" class="headerlink" title="Java EE 中的 Listener"></a>Java EE 中的 Listener</h2><p>下面是 Java EE 中的 8 个 Listener 接口，可分为三类：</p>
<ol>
<li><code>ServletContext</code> 相关接口</li>
</ol>
<p><code>ServletContextListener</code> ：用于监听 <code>ServletContext</code> 的启动和销毁。<br><code>ServletContextAttributeListener</code> ：用于监听 application 范围的属性变化。</p>
<ol>
<li><code>HttpSession</code> 相关接口</li>
</ol>
<p><code>HttpSessionListener</code> ：用于监听 session 的创建和销毁。<br><code>HttpSessionIdListener</code>  ：用于监听 session 的 id 是否被更改。<br><code>HttpSessionAttributeListener</code> ：用于监听 session 范围的属性变化。<br><code>HttpSessionActivationListener</code> ：用于监听绑定在 HttpSession 对象中的 JavaBean 状态。<br><code>HttpSessionBindingListener</code> ：用于监听对象与 session 的绑定和解绑。</p>
<ol>
<li><code>ServletRequest</code> 相关接口</li>
</ol>
<p><code>ServletRequestListener</code> ：用于监听 ServletRequest 对象的初始化和销毁。<br><code>ServletRequestAttributeListener</code> ：用于监听 ServletRequest 对象的属性变化。</p>
<ol>
<li>异步接口</li>
</ol>
<p><code>AsyncListener</code> : 用于监听异步请求。</p>
<h2 id="配置-Listener"><a href="#配置-Listener" class="headerlink" title="配置 Listener"></a>配置 Listener</h2><p>可以使用3种方式配置：</p>
<ol>
<li>使用部署描述符</li>
</ol>
<p>在部署描述符中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;</span><br><span class="line">    com.journaldev.listener.AppContextListener</span><br><span class="line">    &lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用 <code>@WebListener</code> 注解</li>
</ol>
<p>在实现了一个或多个上述Listener接口的类上标注 <code>@WebListener</code> 注解，即可将这个类声明为 Listener。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@WebListener</span><br><span class="line">public class AppContextListener implements ServletContextListener &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>编程式配置</li>
</ol>
<p><code>ServletContext</code> 接口提供了动态添加 Listener 的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. void addListener(String var1);</span><br><span class="line">2. &lt;T extends EventListener&gt; void addListener(T var1);</span><br><span class="line">3. void addListener(Class&lt;? extends EventListener&gt; var1);</span><br></pre></td></tr></table></figure></p>
<p>与编程式添加 Servlet 和 Filter 一样，这必须要在在 <code>ServletContext</code> 配置完成之前完成，因为容器会根据 <code>ServletContext</code> 配置决定加载哪些 Listener/Filter/Servlet. 所以要在 <code>ServletContextListener</code> 的 <code>contextInitialized()</code> 方法或者 <code>ServletContainerInitializer</code> 中的 <code>onStartup()</code> 中注册 Listener。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/java/javaee/javaEE基础之Filter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/java/javaee/javaEE基础之Filter/" itemprop="url">JavaEE基础之 Filter</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:30:12+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建-FIlter"><a href="#创建-FIlter" class="headerlink" title="创建 FIlter"></a>创建 FIlter</h2><p>Filter 主要用来在 Servlet 处理请求的前后完成某些操作。</p>
<p>创建 Filter 只要实现 <code>Filter</code> 接口即可。过滤器在初始化时将调用 <code>init()</code> 方法，可以访问过滤器配置、初始化参数和 ServletContext ,和 Servlet 的 <code>init()</code> 方法一样。类似的，应用程序关闭时也会调用 <code>destory()</code> 方法。</p>
<p>当请求进入到 Filter 时， 过滤器的 <code>diFilter()</code> 方法将会被调用，在该方法中提供了对 ServletRequest 、 ServletResponse 和 FilterChain 对象的访问。因此可以对请求和相应进行处理。</p>
<p><img src="/pics/filterchain.png" alt="过滤器链"><br>过滤器炼的工作方式非常像栈。当请求进入时，首先进入第一个过滤器，该过滤器被添加到栈中。当过滤器调用 <code>FilterChain.diFilter()</code> 时，下一个过滤器将被添加到栈中，一直到请求进入Servlet中，它是最后一个被加入到栈的元素。</p>
<p>当Servlet的 <code>service()</code> 方法返回时，Servlet出栈，然后控制权返回最后一个加入到栈的 Fliter 中，当它的 <code>diFilter()</code> 方法返回时，过滤器将从栈中移除，控制权返回到之前的过滤器中，一直到第一个过滤器。当第一个过滤器的 <code>diFilter()</code> 方法返回时，请求处理就完成了。</p>
<h2 id="配置-Filter"><a href="#配置-Filter" class="headerlink" title="配置 Filter"></a>配置 Filter</h2><p>可以是用3种方式配置：</p>
<ol>
<li>使用部署描述符</li>
</ol>
<p>在部署描述符中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;listener-class&gt;</span><br><span class="line">    com.journaldev.filter.MyFilter</span><br><span class="line">    &lt;/listener-class&gt;</span><br><span class="line">    &lt;url-pattern&gt;/foo&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;/bar&lt;/url-pattern&gt;</span><br><span class="line">    &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;count&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;5&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br></pre></td></tr></table></figure></p>
<p>与Servlet不同的是，过滤器不是在第一个请求到达时加载的，过滤器的 <code>init()</code> 方法总是在应用程序启动时被调。在 <code>ServletContextListener</code> 初始化之后，Servlet初始化之前，它们将按部署描述符中的顺序加载。处理请求时也按顺序处理。</p>
<ol>
<li>使用 <code>@WebFilter</code> 注解</li>
</ol>
<p>在实现了 Filter 接口的类上标注 <code>@WebFilter</code> 注解，即可将这个类声明为 Filter .<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(filterName = &quot;FilterDemo02&quot;, </span><br><span class="line">urlPatterns = &#123; &quot;/*&quot; &#125;, </span><br><span class="line">initParams = &#123; @WebInitParam(name = &quot;name&quot;, value = &quot;xc&quot;),</span><br><span class="line">        @WebInitParam(name = &quot;like&quot;, value = &quot;java&quot;) &#125;)</span><br><span class="line">public class FilterDemo02 implements Filter &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注解配置的缺点在于：无法指定各个Filter的加载顺序，也就无法指定各个Filter处理请求的顺序。而这同通常是很重要的。</p>
<ol>
<li>编程式配置</li>
</ol>
<p><code>ServletContext</code> 接口提供了动态添加 Filter 的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. javax.servlet.FilterRegistration.Dynamic addFilter(String var1, String var2); </span><br><span class="line">2. javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Filter var2); </span><br><span class="line">3. javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Class&lt;? extends Filter&gt; var2);</span><br></pre></td></tr></table></figure></p>
<p>与编程式添加 Servlet 和 Listener 一样，这必须要在在 <code>ServletContext</code> 配置完成之前完成，因为容器会根据 <code>ServletContext</code> 配置决定加载哪些 Listener/Filter/Servlet. 所以要在 <code>ServletContextListener</code> 的 <code>contextInitialized()</code> 方法或者 <code>ServletContainerInitializer</code> 中的 <code>onStartup()</code> 中注册 Filter。</p>
<h2 id="过滤器排序"><a href="#过滤器排序" class="headerlink" title="过滤器排序"></a>过滤器排序</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/03/TCP-IP/IP协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Coder_Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder_Wang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/03/TCP-IP/IP协议/" itemprop="url">IP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-03T22:51:40+08:00">
                2021-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络协议/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输(见图1-4)。许多刚开始接触TCP/IP的人对IP提供不可靠、无连接的数据报传送服务感到很奇怪，特别是那些具有X.25或SNA背景知识的人。<br>不可靠(unreliable)的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法:丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供(如TCP)。<br>无连接(connectionless)这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报(先是A，然后是B)，每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><img src="/pics/ip-address.png" alt="IP地址分类"><br>全0和全1的主机号都是无效的。<br>子网划分：将主机号范围内部分比特作为子网号来划分子网。</p>
<h4 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h4><p>下图中0表示所有比特全为0；-1表示所有比特全为1；netid/subnetid/hostid代表不全为0或全为1的对应字段；子网号栏为空表示没有子网划分。<br><img src="/pics/special-ip.png" alt="特殊IP地址"><br>表的头两项是特殊的源地址，中间项是特殊换回地址，最后四项是广播地址。</p>
<h3 id="IP首部"><a href="#IP首部" class="headerlink" title="IP首部"></a>IP首部</h3><p><img src="/pics/ip-header.png" alt="IP首部"></p>
<ul>
<li>协议版本：目前的协议版本是4，也就是 IPv4</li>
<li>首部长度：4位，单位是4字节，因此IP首部最大长度是 $(2^4-1)*4=60$ 字节。</li>
<li>8位服务类型（TOS）:3位优先权字段（现在已被忽略）+ 4位TOS子字段+1位保留字段（设0）</li>
<li>总长度字段:代表整个IP数据报总长度，16位，因此IP数据报最大度是$2^{16}=65535$字节</li>
<li>标识字段：标识字段唯一地标识主机发送的每一份数据报。通常每发一份报文它的值就会加1</li>
<li>3位标志:</li>
<li>片偏移:</li>
<li>TTL(Time to live)生存时间：设置数据报可以经过的最多路由数，一旦经过一个路由，它的值就减1，当为0时，数据报被丢弃</li>
<li>8位协议: 根据它可以识别是哪个协议向IP传送数据.</li>
<li>16位首部校验和:针对IP首部的校验和。先把校验和字段置为0，然后对首部中每个16bit进行二进制反码求和，结果存在校验和字段中。</li>
<li>32位源IP</li>
<li>32位目的IP</li>
<li>任选项：目前包括<ol>
<li>安全和处理限制（用于军事领域）</li>
<li>记录路径（让每个路由器都记下它的地址）</li>
<li>时间戳</li>
<li>宽松的源站选路（为数据指定一系列必须经过的IP地址）</li>
<li>严格的源站选路（与4类似，但是只能经过这些地址，不能经过其它地址</li>
</ol>
</li>
</ul>
<h3 id="IP路由表"><a href="#IP路由表" class="headerlink" title="IP路由表"></a>IP路由表</h3><p>IP路由表中的每一项都包含如下信息：<br>+目的IP地址，可以是一个完整的主机地址，也可以是一个网络地址，由表中的标志字段来指定。主机地址的有一个非0的主机号，而网络地址的主机号为0，用以指定网络中的所有主机。<br>+下一跳路由的IP地址。<br>+标志。其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一跳路由器，还是一个直接相连的接口。<br>+数据报传输接口</p>
<h4 id="IP路由过程"><a href="#IP路由过程" class="headerlink" title="IP路由过程"></a>IP路由过程</h4><p>当IP层收到某个接口来的数据报时：<br>1.如果目的IP地址是本机IP地址之一或者是IP广播地址，那么数据报被送到由IP首部协议字段指定的上层协议模块处理。<br>2.否则如果IP层没有设置路由功能，则丢弃该数据报。如果设置了路由功能，则按下述过程对数据报进行转发：<br>1.搜索路由表寻找能与目标IP地址完全匹配的条目（网络号和主机号都匹配），如果找到，则把数据报转发给该表目指定的下一跳路由器或者直接相连的接口。<br>2.搜索路由表查找能与目的网络号相匹配的表目。这里需要用到子网掩码。<br>3.搜索路由表寻找标位默认的表目，将数据报转发给该表目指定的下一跳路由或接口。<br>4.如果上面这些步骤都没有成功，则返回一个“主机不可达”或“网络不可达”的错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Coder_Wang</p>
              <p class="site-description motion-element" itemprop="description">学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">170</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coder_Wang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
